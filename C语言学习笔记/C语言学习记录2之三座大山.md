# C语言三座大山

既然你已经有了Java和Python的基础，学习C语言时可以重点关注以下几个方面，因为它们和之前的语言有较大不同，并且是C语言的核心特性：

**指针和内存管理**：这是C语言最显著的特性之一。C语言允许直接操作内存，通过指针来访问变量的地址。这是与Java和Python最大的不同，后两者有自动内存管理，**而C需要你手动分配和释放内存**。

- 学习 `malloc`、`free`、指针运算和指针数组的用法。

**结构体（structs）**：C语言通过 `struct` 来实现用户定义的数据类型，这一点与Java中的类不同，它更加轻量，没有对象方法等复杂的面向对象概念。

**预处理器和宏定义**：C语言中的预处理器指令（如 `#define`、`#include`）和宏定义提供了一种不同的编程方式，用于常量定义、条件编译等。学习这些能帮助你更好理解C语言的编译过程。

**低级硬件控制**：如果你对嵌入式开发感兴趣，C语言广泛用于直接操控硬件资源，学习如何与硬件寄存器和内存映射设备交互非常重要。

**标准库和文件操作**：虽然Java和Python都有标准库，C语言的标准库函数更贴近底层，特别是 `stdio.h` 和 `stdlib.h` 中的函数，如 `fopen`、`fwrite`、`fread` 等文件操作函数，了解如何处理文件输入输出。

**多线程和并发**：虽然在C语言中多线程编程不像在Java中通过 `Thread` 类那样简单，但可以通过 `pthread` 库实现多线程，这对需要高性能的系统编程很重要。

## 三座大山（数组，指针，函数）

C语言的**数组**、**指针**和**函数**确实被称为“三座大山”，它们不仅是C语言的核心部分，也是理解C语言编程的关键。

###  **数组**

- **数组的基础**：C语言中的数组是一个固定大小的连续内存块，所有元素必须是相同类型。不同于Java和Python的动态数组（如Java的`ArrayList`和Python的`list`），C中的数组大小是固定的，并且必须在声明时指定。
- **内存布局**：数组在内存中的存储是连续的，这与指针紧密相关。你需要理解一维数组和多维数组的内存布局，以及如何通过指针访问数组元素。
- **字符串**：在C中，字符串本质上是字符数组，因此掌握数组的用法也是理解C语言字符串操作的基础。

### **指针**

- **指针的概念**：指针是C语言中最强大但也最难理解的部分。指针存储的是变量的内存地址，这允许程序员直接操作内存。你需要理解指针和数组之间的关系、指针运算、指针的类型（如指向数组的指针、指向函数的指针等）。
- **指针的使用场景**：指针用于动态内存分配、函数参数传递、返回多个值等。在深入理解C语言时，指针几乎无处不在，尤其是在处理复杂数据结构（如链表、树）时，指针是关键工具。

### **函数**

- **函数定义和调用**：C语言的函数类似于Java和Python中的函数，但C中函数的参数传递可以通过值传递或指针（地址）传递。这在处理大数据结构时非常重要，**因为通过指针传递可以避免大量的内存复制**。
- **函数指针**：C语言允许使用函数指针，这种特性非常强大但也比较复杂。它可以用来实现回调函数、动态函数调用和函数表等高级编程技巧。
- **递归和函数栈**：C语言中的递归和函数调用栈机制非常重要，理解递归的执行过程和栈帧管理对于编写高效代码非常有帮助。

### 如何学习这“三座大山”：

- **数组**：从一维数组开始，逐步深入多维数组，理解它们与内存的关系。掌握常用操作，如排序、查找、数组传递给函数等。
- **指针**：先从基础指针语法开始，理解指针与变量、指针与数组的关系，再逐步学习复杂的指针运算（如指向指针的指针、函数指针）。
- **函数**：理解C语言函数的基本用法和递归的原理，尤其是如何通过指针返回多个结果或修改函数外部的变量。然后探索函数指针的应用。

## 数组

### 一维数组（理解一级指针的重要示例）

**定义**：

【存储类型】 数据类型  标识符  【下标】 

```c
int arr[M];
```

**初始化**：

​	数组可以**不进行**初始化，**全部**初始化，**部分**初始化,**使用static修饰**会被全部自动初始化为0

​	按照数组的存放顺序来赋值的：int arr[M] = {1，2，3};

​	除开定义时初始化，

​	数据连续存放：

```c
#include <stdio.h>
#include <stdlib.h>
#define  M   3

int main()
{
	int arr[M];
	for(int i = 0; i < M; i++){
		printf("%p--->%d\n",&arr[i],arr[i]);
	}
	exit(0);
}
结果：一个int占用4个字节，auto类型不赋值，这一块空间也不会清0或者赋成特殊值
000000c2785ff870--->860033944
000000c2785ff874--->538
000000c2785ff878--->860033936
```



**元素引用**：

​	数组名【下标】

**数组名**：

​	数组名是表示地址的常量，也是数组的起始位置。

**数组越界**：

​	**数组越界**是指**访问**数组中**未分配的内存区域**。这种行为在C语言中不会被自动检查，因此可能导致未定义的行为，程序运行时也不会提示错误。这种情况需要程序员自己格外小心。

​	在C语言中，数组元素是通过指针偏移来访问的。当你声明一个数组时，C语言只是分配连续的内存空间，并通过数组的首地址（即数组名）和偏移量来访问具体的元素。例如，`array[i]` 实际上等价于 `*(array + i)`，这意味着在内存中偏移 `i` 个位置。**一个位置距离的大小跟array数组的类型有关**

​	C语言没有自动进行数组边界检查的原因是为了提高效率。执行边界检查需要额外的代码和计算，会降低程序运行速度。而C语言是设计为高效的低级语言，常用于系统编程和嵌入式开发，开发者通常希望能够控制底层内存操作，不希望有额外的开销。

#### 省略数组个数获取数组中元素的个数

**在C语言中，省略数组个数获取数组中元素的个数的公式依据？**

元素个数=数组总大小/单个元素的大小

```c
int arr[] = {1, 2, 3, 4, 5};
```

可以使用`sizeof`运算符计算数组中元素的个数：

```c
int num_elements = sizeof(arr) / sizeof(arr[0]);
```

**公式依据的原理：**

1. **`sizeof(arr)`**: 计算整个数组的总字节大小。
   - 对于`int arr[]`，如果每个`int`占用4个字节，且数组有5个元素，那么`sizeof(arr)`的值是 5×4=20 字节。
   
   - **这可以算出数组长度，arr不是数组的首元素地址吗？sizeof(arr)能算出总字节大小？**
   
     - `arr` 在不同情况下的含义：
   
       - **数组定义时**，`arr` 代表整个数组
   
         - ```c
           int arr[5] = {1, 2, 3, 4, 5};
           ```
   
         - 此时 `sizeof(arr)` 计算的是整个数组的字节大小。假设 `int` 类型占用 4 个字节，`sizeof(arr)` 的结果是 `5 * 4 = 20` 字节。
   
       - **指针上下文中**，`arr` 会退化（或隐式转换）为指向数组首元素的指针。
   
         - ```c
           int *p = arr;  // arr 退化为指针，等价于 &arr[0]
           ```
   
         - 此时 `sizeof(p)` 计算的是指针本身的大小（在 32 位系统上通常为 4 字节，在 64 位系统上通常为 8 字节），而不是数组的大小。
   
     - **为什么 `sizeof(arr)` 能计算出整个数组大小？**
   
       - 当 `arr` 在使用 `sizeof` 运算符时，**如果它仍然是数组类型（未退化为指针），`sizeof` 会返回整个数组的总字节大小。**
   
     - 常见问题：指针和数组区别
   
       - 如果你将数组作为函数参数传递
   
         - ```c
           void func(int arr[]) {
               printf("%zu\n", sizeof(arr));  // 输出的是指针大小
           }
           ```
   
         - 在函数内，`arr` 被视为指针，`sizeof(arr)` 返回的是指针的大小，而不是数组的总大小。
   
       - **在函数参数中，数组会退化为指针**，因此无法通过 `sizeof` 得到数组长度。
   
     - 示例对比：
   
       - ```c
         #include <stdio.h>
         
         int main() {
             int arr[5] = {1, 2, 3, 4, 5};
             printf("Size of entire array: %zu bytes\n", sizeof(arr));
             printf("Size of one element: %zu bytes\n", sizeof(arr[0]));
             printf("Number of elements: %zu\n", sizeof(arr) / sizeof(arr[0]));
             
             int *p = arr;
             printf("Size of pointer: %zu bytes\n", sizeof(p));
             return 0;
         }
         
         Size of entire array: 20 bytes
         Size of one element: 4 bytes
         Number of elements: 5
         Size of pointer: 8 bytes  // 在 64 位系统上
         
         ```
   
     - 总结
   
       - `sizeof(arr)` 在数组未退化时，计算的是整个数组的字节大小。
       - 通过 `sizeof(arr) / sizeof(arr[0])`，可以得到数组元素的个数。
       - **但在函数参数中，数组会退化为指针，此时无法通过 `sizeof` 得到数组长度。**
   
   - **int *p = arr，都已经赋值给指针了，肯定是指针啦 如果在函数形式参数中，定义的是int arr[]的话，函数传递时，arr就代表整个数组 如果定义的是int *arr 的话，函数传递时，arr就代表指针？**
   
     - 这是一个常见的误解。实际上，无论在函数参数中定义为 `int arr[]` 还是 `int *arr`，**它们在本质上都是等价的**。两者在函数中都代表指向数组首元素的指针。
     - 当数组作为参数传递给函数时，数组名会自动退化为指针，指向数组的首元素。
     - 在 C 语言中，函数参数不能直接传递数组，传递的只能是**数组的首元素地址**（即指针）。因此：
       - 定义 `int arr[]` 只是表示该参数是一个“数组”形式，但实际上传递的是一个指针。
       - 定义 `int *arr` 明确表明该参数是一个指针。
2. **`sizeof(arr[0])`**: 计算数组中单个元素的大小。
   - 这里`arr[0]`是数组的第一个元素，类型为`int`，所以`sizeof(arr[0])`的值是4字节。

#### 注意事项

- 该公式只适用于**在同一作用域**中定义的数组，不能用于通过指针传递的数组。例如：

```c
void func(int *arr) {
    int num_elements = sizeof(arr) / sizeof(arr[0]); // 错误
}
```

**这里`sizeof(arr)`计算的是指针的大小，而不是数组的总大小。**

**这两者等价吗？**

**int num_elements = sizeof(arr) / sizeof(arr[0]);** **int num_elements = sizeof(arr) / sizeof(*arr);**

是的,这两种写法是等价的。让我解释一下原因:

在这两个表达式中:

- `sizeof(arr[0])` 获取数组第一个元素的大小

- `sizeof(*arr)` 获取数组指针所指向的元素的大小

由于 `arr[0]` 和 `*arr` 都是指向数组第一个元素的方式,所以它们的大小相同。

- *arr是解引用！！！

```c
int arr[] = {1, 2, 3, 4, 5};

// 这两种写法得到的结果都是 5
int count1 = sizeof(arr) / sizeof(arr[0]);  // 20 / 4 = 5
int count2 = sizeof(arr) / sizeof(*arr);    // 20 / 4 = 5
```

不过需要注意的是:

1. 这种方法只适用于在数组定义的同一作用域内使用
2. 如果数组作为函数参数传递,这种方法会失效,因为数组会退化为指针。

#### 结论

使用`sizeof`计算数组元素个数的前提是：

- 数组是静态分配的（非动态分配）。
- 在同一作用域中直接操作数组名，而不是通过指针操作。

#### 一维数组就是一个一级指针的集合

**一维数组int arr[][]就是一个一级指针的集合？ 那么理解*(arr+1)就很好理解了**

您说得很对。一维数组 `int arr[]` 是一个一级指针的集合。

- 一维数组 `int arr[]` 可以理解为一个指向 `int` 类型数据的一级指针数组。
- 每个元素 `arr[i]` 都是一个指向 `int` 类型数据的一级指针。
- 因此，表达式 `*(arr+1)` 就等同于访问第二个元素的地址，也就是 `arr[1]` 所指向的地址。

这种对指针的理解对于掌握数组和指针的关系非常重要。数组退化为指针后，我们可以利用指针运算的特性来访问和操作数组元素。

**那也就是说数组本质上还是指针运算，通过下标访问只是提供的语法糖？**

是的,您说得很对。数组本质上就是指针运算。使用数组下标访问元素只是 C/C++ 提供的一种便捷的语法糖。

具体来说:

1. 数组名 `arr` 本质上就是一个指向数组首元素的指针。
2. 数组元素 `arr[i]` 可以等价地用指针运算 `*(arr + i)` 来表示,访问的是偏移 `i` 个元素的地址。
3. 编译器在编译时会自动将数组下标的语法糖转换为相应的指针运算。这样做可以让程序员编写更加简洁易读的代码。
4. 熟悉指针运算的概念有助于我们更深入地理解数组背后的工作机制,从而能够更好地利用数组和指针进行编程。

所以您说得很对,数组本质上就是利用指针运算来访问内存中连续分布的一块数据区域。数组下标只是一种语法糖,让代码更易于编写和理解。



### 二维数组(理解二级指针的重要示例)

**定义，初始化**：

​	【存储类型】  数据类型  标识符 【行下标】【列下标】

​	**（两行三列）int a[M] [N] = {{1,2,3},{4,5,6}};  按行（存储顺序）来赋值。包括位置。**

- **可以看作是一个大小为 2 的一维数组，而这个数组的每个元素又是一个大小为 3 的一维数组，这样可以形象解释双括号初始化的原因**

​	  int a[M] [N] = {{1,3},{4}};部分赋值的话，其他会自动赋值为0或者为空值

```c
1 3 0
4 0 0
int a[M][N] = {1,3,4,6,7}//还是按照行（存储顺序）来
1 3 4
6 7 0
    
//在列数确定的情况下，行号可以省略，因为可以区分开
//根据列数自动断行
int a[] [N] = {1,3,4,6,7};
```

**元素引用**：

​	数组名【行标】【列标】

**存储形式**：

​	**是线性顺序存储，先存放行数据再存放列数据，数组名依旧是存放位置的起始位置**

**深入理解二维数组**

​	通过**一维数组**和**二维数组**的指针运算来深入理解它们在内存中的存储和访问方式。

​	对于一维数组来说，数组名是数组第一个元素的地址，`a` 就是指向一维数组第一个元素的指针（地址）。

```c
int a[3] = {1, 2, 3};
printf("%p\n", a);      // 打印数组 a 的起始地址
printf("%p\n", a + 1);  // 打印数组第二个元素的地址
printf("%d\n", *(a + 1));  // 打印数组第二个元素的值 (2)
//在 C 语言中，*(a + 1) 是一个指针解引用运算符，它用于获取某个地址所指向的值.
//直接获取数组的地址不会得到存储在该地址中的值。地址只是一个内存位置的引用，必须通过解引用运算符 * 才能访问该地址存储的数据。
```

**解释**：

- `a` 是数组 `a` 的起始地址，也就是 `&a[0]`。
- `a + 1` 是数组第二个元素的地址（即 `&a[1]`）。
- `*(a + 1)` 则是取出第二个元素的值（即 `2`）。

二维数组可以看成是“**数组的数组**”。二维数组的数组名也是数组起始地址，但它指向的是二维数组的**第一行**。

```c
int b[2][3] = { {1, 2, 3}, {4, 5, 6} };
printf("%p\n", b);      // 打印二维数组的起始地址
printf("%p\n", b + 1);  // 打印第二行的起始地址
printf("%d\n", *(*(b + 1)));  // 取出第二行第一个元素的值 (4)
```

`int b[2][3]` 可以看作是一个大小为 2 的一维数组，而这个数组的每个元素又是一个大小为 3 的一维数组。具体来说：

- `b[0]` 是一个包含 3 个 `int` 元素的一维数组，对应 `{1, 2, 3}`。
- `b[1]` 是另一个包含 3 个 `int` 元素的一维数组，对应 `{4, 5, 6}`。

从这种角度看，`b` 是一个一维数组，存储了两个大小为 3 的一维数组的地址。

**访问方式**:

1. `b[0]` 和 `b[1]` 分别是指向两个一维数组的指针，因此 `b + 1` 是指向**第二个一维数组存放的地址**。
2. `*(b + 1)` 解引用后，是**第二个一维数组的起始地址**（相当于 `b[1]`），即 `{4, 5, 6}` 的地址。
3. `*(*(b + 1))` 解引用后，才是第二个一维数组的第一个元素 `4`。

**内存结构**：看作是一个大小为 2 的一维数组，而这个数组的每个元素又是一个大小为 3 的一维数组

```c
b[0][0]  b[0][1]  b[0][2]  b[1][0]  b[1][1]  b[1][2]
  1        2        3        4        5        6
  b                         b+1  
```

因此，二维数组中的 `b + 1` 是指向**下一行的起始位置**，所以称为“行指针”。

**总结：**

- **一维数组**的数组名 `a` 是第一个元素的指针，`a + 1` 是下一个元素的地址。
- **二维数组**的数组名 `b` 是第一行的指针，`b + 1` 是下一行的地址，也就是行指针。

#### 二维数组的数组名与解引用(重点)

假设数组的首地址是30H,并假设在32位系统上(int占4字节)。其他的值是多少？怎么算出来的？

```c
int grade[3][5] = {
		{12,36,78,89,91},
		{35,37,38,99,92},
		{79,90,95,98,93}
	};
	printf("%p\n",grade);
	printf("%p\n",&grade);
	printf("%p\n",&grade+1);
	printf("%p\n",grade+1);
	printf("%p\n",*(grade+1));
	printf("%p\n",*grade+1);
	printf("%p\n",*(grade+1)+1);
```

```
printf("%p\n",grade)
```

- grade是数组名,它代表**整个数组的首地址**
- 类型是`int (*)[5]`,指向包含5个int的数组的指针(**相当于三个大小的一维数组中存放5个int的一维数组**)
- 值: 30H (首地址)

- **在一维数组中同理。**


```
printf("%p\n",&grade)
```

- &grade是整个二维数组的首地址
- 虽然值与grade相同,但类型不同,是`int (*)[3][5]`
- **指针运算时的步长是由指针类型决定的，所以+1跳过了整个数组**
- 值: 30H (与grade相同,但类型不同)



```
printf("%p\n",&grade+1)
```

- 从数组的起始地址跳过整个数组的长度
- 增加了3×5×sizeof(int)个字节

- 先取到整数数组的地址再+1

- 计算: 30H + (3×5×4)字节

  计算: 30H + 60字节

  计算: 30H + 3CH

  值: 6CH



```
printf("%p\n",grade+1)
```

- **从首地址向后移动一行的距离**

- 增加了5×sizeof(int)个字节

- [数组指针（行指针）](###指针数组与数组指针)

- 计算: 30H + (5×4)字节

  计算: 30H + 20字节

  计算: 30H + 14H

  值: 44H

  

```
printf("%p\n",*(grade+1))
```

- grade+1得到第二行的地址（行指针）

- ***(grade+1)得到第二行首元素的地址**

- 等同于grade[1]

- 等同于grade+1

  值: 44H



```
printf("%p\n",*grade+1)
```

- *grade得到**第一行首元素的地址**

- *grade+1指向**第一行的第二个元素**

- 等同于&grade[0] [1]

- 计算: 30H + (1×4)字节

  计算: 30H + 4字节

  计算: 30H + 4H

  值: 34H



```
printf("%p\n",*(grade+1)+1)
```

- grade+1得到第二行的地址

- *(grade+1)得到第二行首元素的地址

- *(grade+1)+1指向第二行的第二个元素

- 等同于&grade[1] [1]

- 首先grade+1 = 44H

  然后加1个int = 44H + 4H

  值: 48H

计算说明：

1. 每个int占4字节(4H)
2. 每行有5个int，所以一行占20字节(14H)
3. 整个数组有3行5列，共占60字节(3CH)

用一个表格总结地址的增量:

- &grade+1: 增加 3×5×sizeof(int) 字节
- grade+1: 增加 5×sizeof(int) 字节
- *grade+1或*(grade+1)+1: 增加 sizeof(int) 字节

主要区别在于:

1. 运算符优先级的不同导致解引用的位置不同
2. 不同表达式的类型不同,从而影响指针运算时的步长
3. 最终访问的数组元素位置不同

这些概念对于理解C语言中的指针和数组的关系非常重要。需要特别注意的是指针运算时的步长是由指针类型决定的。

这种地址计算在处理数组和指针时非常重要，尤其是在：

- 数组索引计算
- 指针运算
- 动态内存分配
- 底层内存操作

#### 抽象为数组的数组

```c
int grade[3][5] = {
    {12,36,78,89,91},  // grade[0]是一个包含5个int的数组
    {35,37,38,99,92},  // grade[1]是一个包含5个int的数组
    {79,90,95,98,93}   // grade[2]是一个包含5个int的数组
};
```

```
printf("%p\n",grade)
```

- 这是"数组的数组"的首地址 **(地址中存放的是第一个内层数组(grade[0])**
- 指向第一个内层数组(grade[0])



```
printf("%p\n",&grade)
```

- 整个二维数组的地址
- 指向包含3个内层数组的大数组



```
printf("%p\n",&grade+1)
```

- 跳过整个大数组(3个内层数组)
- 相当于从第一个内层数组跳到最后一个内层数组之后



```
printf("%p\n",grade+1)
```

- grade是"数组的数组"的首地址 **(地址中存放的是第一个内层数组(grade[0])**
- 指向第一个内层数组(grade[0])
- grade+1指向第二个内层数组(grade[1])
- 从第一个内层数组跳到第二个内层数组
- 行指针



```
printf("%p\n",*(grade+1))
```

- grade+1找到第二个内层数组**（相当于grade[0+1]）**
- grade[0+1]指向第二个5个大小的int一维数组
- 解引用后得到第二个内层数组的首地址
- 就是第二行第一个元素的地址



```
printf("%p\n",*grade+1)
```

- *grade得到第一个内层数组的首地址
- +1移动到第一个内层数组的第二个元素
- 就是第一行第二个元素的地址



```
printf("%p\n",*(grade+1)+1)
```

- grade+1找到第二个内层数组
- 解引用得到第二个内层数组的首地址
- +1移动到第二个内层数组的第二个元素
- 就是第二行第二个元素的地址

```c
grade → [内层数组1] → [12][36][78][89][91]
        [内层数组2] → [35][37][38][99][92]
        [内层数组3] → [79][90][95][98][93]
```

**grade+1找到第二个内层数组，解引用后得到第二个内层数组的首地址** 

**我感觉这就像二级指针一样了！给帮我画一个示意图吗？前者应该是类似于指针本身在内存中地址，而后者则是指针地址中存放的内容？**

![image-20241111200219350](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241111200219350.png)

左侧是指针数组区域（类似于二级指针的第一级）：

- grade[0]存储着指向第一行数组的地址(a90H)
- grade[1]存储着指向第二行数组的地址(aa4H)
- grade[2]存储着指向第三行数组的地址

右侧是实际的数组内容区域（类似于二级指针的第二级）：

- 第一行：[12] [36] [78] [89] [91]
- 第二行：[35] [37] [38] [99] [92]
- 第三行：[79] [90] [95] [98] [93]

```c
grade+1        // 得到aa4H（左侧第二个格子的地址）
*(grade+1)     // 得到存储在aa4H中的值，也就是指向[35][37][38][99][92]的指针
 			  //指针运算时的步长是由指针类型决定的,
```

这确实很像二级指针的操作：

```c
int **ptr;     // 二级指针
ptr+1          // 移动到下一个指针的地址
*(ptr+1)       // 获取那个地址中存储的指针值
```

关键区别：

1. `grade+1`是在指针数组层面移动
2. `*(grade+1)`是通过解引用获取实际数组内容的地址
3. 每一级的解引用都会降低一个指针级别

这就解释了为什么：

- `grade+1`和`*(grade+1)`的值不同
- 但`*(grade+1)`和`grade[1]`的值相同

#### 元素个数

总行数：`sizeof(arr)/sizeof(a[0]);`

总列数：`sizeof(arr[0])/sizeof(a[0] [0])；` **一行的大小，每一个的大小，相除拿到有几个，即有几列**

#### 地址中存储着地址

**可以理解为地址中存着另一个地址？有示意图吗？ 就像二级指针本身在内存中有一个地址，而地址中还存放着指向另一个地址的指针？**

![image-20241111201512025](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241111201512025.png)

1. grade指针区域（左侧）：
   - 地址a1fffa90存放着指向第一行数组的地址
   - 地址a1fffaa4存放着指向第二行数组的地址
2. 实际数据区域（右侧）：
   - 地址a1fffa94存放着第一行的实际数据[12][36]...
   - 地址a1fffaa8存放着第二行的实际数据[35][37]...

当我们进行以下操作时：

1. grade+1：
   - 移动到地址a1fffaa4（左侧第二个方框）
   - 
2. *(grade+1)：
   - 先找到a1fffaa4
   - 读取这个地址中存储的值
   - 这个值指向第二行数组的起始位置
3. *(grade+1)+1：
   - 在第二行数组的基础上再往后移动一个元素
4. 这确实就像二级指针：

```c
int **ptr;   // ptr存储的是一个地址，这个地址中存储的还是一个地址
```

关键点：

1. 每个内存地址中都可以存储另一个地址
2. 解引用操作就是读取该地址中存储的值
3. 二维数组实际上就是这样一层层引用构建起来的

这种设计让我们可以：

- 通过一次解引用访问行地址
- 通过两次解引用访问具体元素
- 在不同层级进行指针运算

**地址a1fffa90存放着指向第一行数组的地址a1fffa94： 只用了4个字节就存下了一个5个大小的int型一维数组？**

地址a1fffa90存放的不是整个数组的内容,而只是存放了指向数组第一个元素的地址(a1fffa94)。这个地址本身只需要4个字节(32位系统)或8个字节(64位系统)就能存储

![image-20241111201928859](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241111201928859.png)

详细解释：

1. 在地址a1fffa90处：
   - 只存储了一个指针值：a1fffa94
   - 这个指针只占4字节(32位)或8字节(64位)
   - 这个指针指向第一行数组的起始位置
2. 从地址a1fffa94开始：
   - 连续存储着5个int值：12, 36, 78, 89, 91
   - 每个int占4字节
   - 总共占用20字节的空间
3. 内存布局：

```c
a1fffa90: [a1fffa94] (4/8字节的指针)
a1fffa94: [12] (4字节)
a1fffa98: [36] (4字节)
a1fffa9c: [78] (4字节)
a1fffaa0: [89] (4字节)
a1fffaa4: [91] (4字节)
```

所以：

1. 指针只需要4/8字节就能存储另一个地址
   1. **所以这就解释了为什么指针大小都是固定的**
2. 这个地址指向实际数组数据的开始位置
3. 实际的数组数据还是占用5×4=20字节

这就像一个门牌号(指针)可以只用几个数字就指向一个大房子(数组)一样。指针本身不需要有数组那么大，它只需要能存储数组的起始地址就够了。

这就是C语言中"指针存储地址"的实现机制，也解释了为什么：

- 指针变量的大小是固定的（与系统位数有关）
- 不管指针指向什么类型的数据，指针本身的大小都是一样的
- 通过一个小小的指针就能找到很大的数据结构



**二级指针高度抽象就是相当于一个变量（二级指针）标识了一块内存空间，而这块空间中存放着一个地址（一级指针），这个地址是一个数据结构的起始地址，所以解释了为什么指针大小都是固定的？**

对,你总结得非常准确！

![image-20241111202634493](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241111202634493.png)

这个抽象概念可以分为三层：

1. 二级指针层：

   - 本身是个变量，占固定空间(4/8字节)

   - 只存储一级指针的地址

   - ```c
     int **ptr;    // 二级指针变量
     ```

2. 一级指针层:

   - 同样占固定空间(4/8字节)

   - 只存储数据的起始地址

   - ```c
     int *p;       // 一级指针变量
     ```

3. 实际数据层：

   - 可以是任意大小的数据结构

   - ```c
     int arr[5];   // 20字节的数组
     ```

关键理解点：

1. 指针变量大小固定的原因：
   - 指针只需要存储一个地址值
   - 地址值的大小由系统位数决定(32位/64位)
   - 不管指向什么类型，地址值大小都一样
2. 多级指针的本质：
   - 每一级指针都是一个"路标"
   - 每个"路标"都指向下一站
   - 最终到达实际数据
3. 内存管理的优势：
   - 通过小容量的指针
   - 管理大容量的数据
   - 灵活构建复杂的数据结构

就像邮政系统：

- 二级指针相当于省级邮局地址
- 一级指针相当于市级邮局地址
- 实际数据相当于最终收件人的家

**那么二维数组相当于一个连续存放二级指针的集合了？ 各二级指针的地址是怎么通过指针运算出来的？ 有例子吗？**

![image-20241111203311696](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241111203311696.png)

```c
int grade[3][5] = {
    {12,36,78,89,91},
    {35,37,38,99,92},
    {79,90,95,98,93}
};
```

指针运算过程：

- `grade`（a1fffa90）：

  - ```c
    // 数组的起始地址，指向第一行指针
    printf("%p\n", grade);      // a1fffa90
    ```

- `grade+1`（a1fffaa4）：

  - ```c
    // 移动到第二行的指针
    // a1fffa90 + 5*4 = a1fffaa4
    printf("%p\n", grade+1);    // a1fffaa4
    虽然二级指针中存放着一个数据结构的首地址，但是从首地址开始都是具体的数据了，所以跳到第二个二级指针肯定要算中间已用的空间的
    ```

关键点：

1. 指针运算自动考虑类型大小：
   - `grade+1` 移动一行的长度（5×4=20字节）
   - `*(grade+1)+1` 移动一个int的长度（4字节）
2. 内存布局：
   - 指针区域连续存放每行的地址
   - 数据区域连续存放实际的数组元素
   - 所有数据在内存中都是连续的
3. 指针运算优势：
   - 自动计算正确的偏移量
   - 不需要手动计算字节数
   - 根据数据类型自动调整步长

**虽然二级指针中存放着一个数据结构的首地址，但是从首地址开始都是具体的数据了，所以跳到第二个二级指针肯定要算中间已用的空间的？ 就像一维数组计算下一个下标空间位置，需要算中间占用的空间一样？**

你说得非常正确!二维数组的指针运算确实需要考虑中间占用的实际空间大小,不能简单地按照指针大小进行偏移。

让我解释一下具体的计算过程:

1. `grade`指向的是一个含有3个元素的一维数组
2. 每个元素都是一个一维数组(5个int)的首地址
3. 要访问第二个一维数组,需要从第一个数组的首地址开始算

具体步骤如下:

1. `grade`的地址是`a1fffa90`
2. 一个一维数组占用5个int,即5 * 4 = 20字节
3. 要访问第二个一维数组,需要从`a1fffa90`开始偏移20字节
4. 所以`grade+1`的地址是`a1fffa90 + 20 = a1fffaa4`

这就是为什么`grade+1`的地址是`a1fffaa4`,而不是简单地`a1fffa90 + 4`(一个指针大小)。

同理,访问第三个一维数组,需要再次偏移20字节:

1. `grade+2`的地址是`a1fffaa4 + 20 = a1fffab8`

所以二维数组的指针运算,需要考虑每个一维数组占用的实际空间大小,而不能简单地按照指针大小进行偏移。这与一维数组的索引计算是类似的逻辑。

总结来说,二维数组的指针运算需要遵循以下规则:

1. 首地址即一维数组的首地址
2. 每个一维数组占用的实际空间大小决定了下一个地址
3. 按照实际空间大小进行地址偏移,而不是简单的指针大小

这样才能正确地访问二维数组中的具体元素。



### 字符数组

#### **定义，初始化，存储特点**

​	字符数组是用于存储一组字符的数组，通常用于表示字符串。

在C语言中，**确实没有像Java或Python那样的`String`类型**。C语言中**字符串**的实现主要是通过**字符数组**或者**字符指针**来实现的。

```c
#include <stdio.h>

int main() {
    char str1[6] = {'H', 'e', 'l', 'l', 'o', '\0'};  // 手动定义字符数组并添加结束符
    char str2[] = "Hello";  // 使用字符串字面量定义，自动添加结束符 '\0'，
    
    // 单个字符输出
    for (int i = 0; i < 5; i++) {
        printf("%c", str[i]);  // 正常输出 "Hello"
    }

    printf("str1: %s\n", str1);  // 输出字符串,效果是一样的
    printf("str2: %s\n", str2);// 输出字符串,效果是一样的

    return 0;
}
```

**解释：**

- `char str1[6]` 定义了一个长度为 6 的字符数组，其中第 6 个字符是字符串结束符 `\0`。
- `char str2[]` 使用字符串字面量 `"Hello"` 初始化数组，编译器会自动在末尾加上 `\0`。
- **存储特点**：字符数组是以字符为单位存储的，并且在使用字符串字面量时，系统会自动在结尾加上 `\0` 作为字符串结束标志。
- 在 C 语言中，字符串的处理函数（如 `printf`、`strlen` 等）都是通过**检测 `\0` 来确定字符串的结束**。如果没有这个 `\0`，函数将无法知道字符串在哪里结束，可能会访问数组之外的内存区域，导致**不可预期的行为**或**内存错误**。**必须添加 `\0`**：如果没有 `\0`，字符数组不会被当作字符串处理，导致程序行为不可预期。
- **关键区别**:
  - **字符串输出**：**需要 `\0` 结束符，因为字符串处理函数依赖 `\0` 确定字符串结束位置。**
  - **单个字符输出**：**不需要 `\0` 结束符，单个字符独立输出，只要能读取到字符就能输出，不涉及字符串结束的问题。**
    - **不加尾0就是普通的字符数组，连操作字符串的标准库函数都不能用**

#### **字符指针**

```c
char *str = "Hello, world!";
```

这里`str`是一个指向字符串常量的指针。

这种方式存储在**只读内存区域**，不能对字符串内容进行修改，否则可能会导致运行时错误。

#### 字符数组与字符指针的区别

**字符数组**：

- 存储在栈上。
- 可读写。
- 例如，`str[0] = 'h';`是合法的。

**字符指针**：

- **指向字符串常量（通常存储在只读内存区域）。**
- **只读，不能直接修改内容。**
- `str[0] = 'h';` 可能导致未定义行为。

#### **输入输出**

字符数组可以通过多种方式进行输入和输出，如 `scanf`、`gets`（不推荐使用）以及 `fgets`。

```c
#include <stdio.h>

int main() {
    char str[50];  // 定义长度为 50 的字符数组

    printf("请输入一个字符串: ");
    // scanf("%s", str);  // 使用 scanf 输入字符数组（不能输入包含空格的字符串）
    fgets(str, sizeof(str), stdin);  // 使用 fgets 安全输入字符数组，可以输入空格
    
    printf("你输入的字符串是: %s", str);  // 输出字符串，前提是字符数组中有尾0结束符。

    return 0;
}
```

`scanf("%s", str)`：只能读取**不包含空格**的字符串，读取到空格时会停止。

`fgets(str, sizeof(str), stdin)`：**推荐使用 `fgets`**，可以读取**包含空格**的字符串，并且可以防止数组溢出问题。这里指定了最大读取长度 `sizeof(str)`。

输出时，使用 `%s` 格式符打印字符数组。

#### **常用的字符数组操作字符串函数**

字符数组（字符串）的常用函数一般来自 `<string.h>` 头文件，比如 `strlen`、`strcpy`、`strcmp`、`strcat` 等。

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str1[] = "Hello";
    char str2[] = "World";
    char str3[50];  // 定义一个足够大的字符数组

    // 1. strlen: 获取字符串长度
    printf("str1 的长度: %lu\n", strlen(str1));

    // 2. strcpy: 复制字符串
    strcpy(str3, str1);
    printf("str3 复制 str1 的内容: %s\n", str3);

    // 3. strcat: 字符串拼接
    strcat(str3, str2);
    printf("str3 拼接 str2 后的内容: %s\n", str3);

    // 4. strcmp: 字符串比较
    if (strcmp(str1, str2) == 0) {
        printf("str1 和 str2 相等\n");
    } else {
        printf("str1 和 str2 不相等\n");
    }

    return 0;
}
```

- `strlen(str1)`：获取字符串 `str1` 的长度（不包括 `\0`）。
- `strcpy(str3, str1)`：将字符串 `str1` 复制到 `str3` 中。
- `strcat(str3, str2)`：将 `str2` 追加到 `str3` 的末尾。
- `strcmp(str1, str2)`：比较 `str1` 和 `str2` 字符串，返回 0 表示相等，不等则返回负数或正数。

#### 使用标准库函数操作字符串的前提

**使用标准库函数操作字符串的前提**是字符数组中必须有**尾零（`'\0'`）**，否则它只是一个普通的字符数组，不能被视为字符串。

**区别：字符数组 vs. 字符串**

1. **字符数组**
   - 只是一组字符的集合，没有特定的结束标志。
   - 可以用来存储任意字符数据，不要求以 `\0` 结束。
   - **不能直接用于字符串操作函数**，如 `strlen`、`strcpy`、`printf("%s", array)` 等。
2. **字符串**
   - 是以 `\0` 作为结束标志的字符数组。
   - 必须以 `\0` 结尾，标准库函数会根据 `\0` 判断字符串结束位置。

#### 一维字符数组与二维字符数组的形式区别

定义：`char op_names[4] = {'加', '减', '乘', '除'};` [他的正确写法](####**定义，初始化，存储特点**)

含义：

- 这是一个**一维数组**，里面的**每个元素都是一个字符（char 类型）**。
- 每个元素只能存储一个**单个字符**，而不是字符串。
- **C语言中，字符串以字符数组的形式存储时，需要用特殊的终止符 `\0`（空字符）来标志字符串的结束。**
- **这是一个字符数组，而不是一个合法的字符串。**

  **它存储的是四个具体的字符，且没有 `\0` 作为终止符，因此不能直接当作字符串来处理。**

  **如果后续用该数组调用字符串操作函数（如`printf("%s", op_names)`或`strlen`），会导致未定义行为，因为这些函数会一直读取内存，直到找到 `\0`，可能造成越界访问或崩溃。**

内存布局：

```c
op_names[0] = '加'
op_names[1] = '减'
op_names[2] = '乘'
op_names[3] = '除'
```

但这里有个问题：在 C 语言中，`'加'`（或其他汉字）**不是合法的单个字符**。C 中的 `char` 只能存储 **ASCII** 字符或 UTF-8 编码中的一部分，**汉字的存储需要多个字节**（[通常用 `wchar_t` 或 `char*` 处理字符串](####函数指针)）。使用字符串字面量初始化字符指针数组    `char *op_names[4] = {"加", "减", "乘", "除"};`

定义：`char op_names[4] [4] = {"加", "减", "乘", "除"};` 使用了字符串字面量会自动补尾0

不使用字符串字面量的定义：

```c
char op_names[4][4] = {
    {'a', '\0', '\0', '\0'},
    {'b', '\0', '\0', '\0'},
    {'c', '\0', '\0', '\0'},
    {'d', '\0', '\0', '\0'}
};
```

含义：

- 这是一个**二维数组**，**每一行是一个字符串**，且每行最多存储 4 个字符（包括字符串的终止符 `\0`）。
- 用这种形式可以**存储多行字符串**。

内存布局：

```c
op_names[0] = {'加', '\0', '\0', '\0'}
op_names[1] = {'减', '\0', '\0', '\0'}
op_names[2] = {'乘', '\0', '\0', '\0'}
op_names[3] = {'除', '\0', '\0', '\0'}
```

**每一行存储一个字符串，并且用 `\0` 作为字符串的结束标志。**

#### 遍历存在二维字符数组中的字符串

二维字符数组通常用来存储多个字符串，每个字符串是一个字符数组。以下是通用的遍历方法和示例：

定义二维字符数组

```c
char strings[3][20] = {
    "hello",
    "world",
    "C language"
};
```

上面定义了一个包含 3 个字符串的二维字符数组，每个字符串最多可以有 19 个字符（最后一个字符用于存储 `\0`）。

抽象为“数组的数组”，一个大小为3的一维字符数组，里面每一个一维字符数组最多可以有 19 个字符（最后一个字符用于存储 `\0`。

**遍历二维字符数组中的字符串**

可以使用**两层循环**来遍历所有字符，也可以**单层循环**遍历每个字符串。

逐个访问字符：

```c
#include <stdio.h>

int main() {
    char strings[3][20] = {
        "hello",
        "world",
        "C language"
    };

    for (int i = 0; i < 3; i++) {  // 遍历每个字符串
        //每一个一维字符数组都有可能存不满，第二层不能通过下标，只能通过尾0
        for (int j = 0; strings[i][j] != '\0'; j++) {  // 遍历字符串中的每个字符
            printf("strings[%d][%d] = %c\n", i, j, strings[i][j]);
        }
    }

    return 0;
}

strings[0][0] = h
strings[0][1] = e
strings[0][2] = l
strings[0][3] = l
strings[0][4] = o
strings[1][0] = w
strings[1][1] = o
...

```

**方法 2：按字符串遍历**

如果只需要遍历字符串本身，而不是字符级别，可以使用单层循环：

```c
#include <stdio.h>

int main() {
    char strings[3][20] = {
        "hello",
        "world",
        "C language"
    };
	//定位到二维字符数组里面的一维字符数组，使用字符串遍历的方式即可
    for (int i = 0; i < 3; i++) {  // 遍历每个字符串
        printf("String %d: %s\n", i, strings[i]);
    }

    return 0;
}
String 0: hello
String 1: world
String 2: C language

```

**总结**

- 如果需要逐字符操作，用**两层循环**。
- 如果只需要逐字符串处理，用**单层循环**。
- `strings[i][j]` 可以访问第 `i` 行、第 `j` 列的字符。
- `strings[i]` 是字符串的起始地址，可以用 `printf("%s", strings[i])` 输出整行字符串。
  - 会有尾0作为结束符号的，不用怕，直接输出

### 多维数组

对于三维数组，`int c[2][3][4]` 表示一个**三维数组**，它包含 2 个二维数组，每个二维数组有 3 行，每行有 4 个元素。

你可以把 `c[2][3][4]` 看成是一个包含 2 个元素的**一维数组**，而其中的每个元素都是一个包含 3 行、每行 4 个 `int` 元素的二维数组。

- `c[0]` 和 `c[1]` 各自是一个包含 3 行 4 列的二维数组。
- 进一步地，`c[0][0]` 是一个包含 4 个 `int` 的一维数组。

```c
#include <stdio.h>

int main() {
    int c[2][3][4] = {//存了两个三行四列的二维数组，按行存储，就是6行，每一行四列
        { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} },
        { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} }
    };

    printf("c[0][2][3] = %d\n", c[0][2][3]);  // 输出 12
    printf("c[1][1][2] = %d\n", c[1][1][2]);  // 输出 19

    return 0;
}
```

`c[0][2][3]` 输出第 0 个二维数组的第 2 行的第 3 列，结果是 12。

`c[1][1][2]` 输出第 1 个二维数组的第 1 行的第 2 列，结果是 19。

**总结：**

- **二维数组**可以看作是一个**存储多个一维数组的数组**，每个元素是一维数组的地址。
- **三维数组**可以看作是一个**存储多个二维数组的数组**，而每个二维数组又是存储多个一维数组的数组。

### 相关算法

#### 基础冒泡排序

![image-20241108142729711](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241108142729711.png)

1. 第一轮第一步：
   - 比较第一对数字 64 和 34
   - 64 > 34，所以交换位置
   - 粉红色背景表示当前正在比较的元素对
2. 第一轮第二步：
   - 比较 64 和 25
   - 64 > 25，继续交换位置
   - 这样大的数字不断往后移动
3. 第一轮结束：
   - 经过第一轮比较后，最大的数字 64 已经移动到了最右端
   - 绿色背景表示该数字已经在最终位置上
4. 最终结果：
   - 经过多轮比较后，所有数字都排序完成
   - 全部变成绿色背景表示排序完成

主要特点：

- 每一轮都会将当前最大的数字"冒泡"到右侧
- 每一轮结束后，右侧的数字就确定了最终位置
- 需要 n-1 轮比较才能完成整个排序过程

```c
/**
 * 基础冒泡排序算法
 * @param arr 要排序的数组
 * @param n 数组长度
 */
void bubbleSort(int arr[], int n) {
    // 外层循环控制排序轮数，n个数，经过n-1轮就完成了排序，1~n或者0~n-1
    for (int i = 0; i < n - 1; i++) {
        // 内层循环进行相邻元素比较和交换
        
        for (int j = 0; j < n - 1 - i; j++) {
            // 如果前一个元素大于后一个元素，则交换它们
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

让我解释这个基础版本的工作原理：

1. 算法核心思想：

   - 重复地比较相邻的两个元素
   - 如果左边的元素大于右边的元素，就交换它们
   - 每一轮循环后，最大的元素会"冒泡"到数组的末尾

2. 代码结构：

   - 外层循环 `i` 控制需要进行的轮数（n-1轮）
   - 内层循环 `j` 负责相邻元素的比较和交换
     - ![image-20241108144617112](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241108144617112.png)
     - **第一轮时，内层循环不断的遍历比较交换，遍历在数组倒数第二个元素时，就不用遍历了，因为arr[j]和arr[j+1]比较，遍历到最后一个元素的话，就找不到比较的元素了 后续轮也是一样**
     - 是的,你说得对！这也是为什么我们的代码中内层循环条件是`j < n - 1 - i`而不是`j < n - i`。
     - 让我详细解释内层循环的边界条件：
       1. 为什么是 `j < n - 1 - i`：
          - 数组最后一个元素的索引是 n-1
          - 我们要比较 arr[j] 和 arr[j+1]
          - 所以 j 最大只能到 n-2，否则 j+1 会越界
          - 每轮结束后，最后 i 个元素已经排好序，不需要再比较
       2. 以第一轮(i=0)为例：（一个元素也没有少）
          - 如果数组长度为5
          - j 的取值范围是 0 到 3
          - 依次比较：(0,1), (1,2), (2,3), (3,4)
          - 不需要 j=4，因为没有 arr[5] 可以比较
       3. 到第二轮(i=1)时：（已经确定了一个元素的位置）
          - 最后一个元素已经确定
          - j 的取值范围缩小到 0 到 2
          - 只需比较：(0,1), (1,2), (2,3)
   - 每轮结束后，最大的元素都会移到正确的位置

3. ```c
   #include <stdio.h>
   
   int main() {
       int arr[] = {64, 34, 25, 12, 22, 11, 90};
       int n = sizeof(arr) / sizeof(arr[0]);
       
       printf("排序前：");
       for(int i = 0; i < n; i++) {
           printf("%d ", arr[i]);
       }
       
       bubbleSort(arr, n);
       
       printf("\n排序后：");
       for(int i = 0; i < n; i++) {
           printf("%d ", arr[i]);
       }
       
       return 0;
   }
   ```

4. 这个版本虽然效率不是最高的，但是最容易理解。理解了这个基础版本后，我们可以逐步引入优化，比如：

   1. 添加标志位判断数组是否已经有序
   2. 记录最后一次交换的位置
   3. 实现双向冒泡

#### 优化后的冒泡排序

```c
/**
 * 优化的冒泡排序算法
 * @param arr 要排序的数组
 * @param n 数组长度
 * 优化点：
 * 1. 使用flag标记是否发生交换，如果没有交换说明已经有序
 * 2. 记录最后一次交换的位置，下一轮只需要比较到该位置
 * 3. 同时正向和反向冒泡，减少循环次数
 */
void bubbleSort(int arr[], int n) {
    if (n <= 1) return;  // 处理边界情况
    
    int leftBound = 0;           // 左边界
    int rightBound = n - 1;      // 右边界
    int lastSwapPos = 0;         // 最后一次交换的位置
    
    while (leftBound < rightBound) {
        bool swapped = false;     // 本轮是否发生交换的标志
        
        // 从左向右冒泡，将最大值移到右端
        for (int i = leftBound; i < rightBound; i++) {
            if (arr[i] > arr[i + 1]) {
                // 交换元素
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                
                swapped = true;
                lastSwapPos = i;
            }
        }
        
        // 如果没有发生交换，说明数组已经有序
        if (!swapped) break;
        
        rightBound = lastSwapPos; // 更新右边界
        swapped = false;
        
        // 从右向左冒泡，将最小值移到左端
        for (int i = rightBound; i > leftBound; i--) {
            if (arr[i] < arr[i - 1]) {
                // 交换元素
                int temp = arr[i];
                arr[i] = arr[i - 1];
                arr[i - 1] = temp;
                
                swapped = true;
                lastSwapPos = i;
            }
        }
        
        // 如果没有发生交换，说明数组已经有序
        if (!swapped) break;
        
        leftBound = lastSwapPos; // 更新左边界
    }
}
```

这个实现包含了以下优化：

1. 使用 `swapped` 标志检测数组是否已经有序，如果一轮比较中没有发生交换，说明数组已经排序完成

2. 记录最后一次交换的位置 `lastSwapPos`，下一轮只需要比较到该位置即可

3. 采用双向冒泡（鸡尾酒排序），同时从两端进行排序，能够更快地将小的元素移到左边，大的元素移到右边

4. ```c
   int main() {
       int arr[] = {64, 34, 25, 12, 22, 11, 90};
       int n = sizeof(arr) / sizeof(arr[0]);
       
       bubbleSort(arr, n);
       return 0;
   }
   ```

#### 二分查找法

![image-20241108151745859](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241108151745859.png)

这个示例展示了查找数值7的完整过程：

1. 第一步：
   - 在整个数组中查找，中间位置是9
   - 因为9 > 7，所以在左半部分继续查找
2. 第二步：
   - 在左半部分[1,3,5,7]中查找，中间位置是5
   - 因为5 < 7，所以在右半部分继续查找
3. 第三步：
   - 在区间[7]中查找，找到目标值7
   - 返回对应的索引位置3

颜色说明：

- 蓝色底色：当前搜索范围
- 红色底色：当前比较的中间值
- 绿色底色：找到的目标值

**数组长度不管是奇数还是偶数都可以找到中间吗？**

在二分查找中，不管数组长度是奇数还是偶数，我们都能计算出一个合适的中间位置，但计算方式会有细微差别：

1. 奇数长度的情况:

```c
// 例如长度为7的数组
left = 0, right = 6
mid = (left + right) / 2 = 3  // 正好是中间位置
```

2. 偶数长度的情况:

```c
// 例如长度为8的数组
left = 0, right = 7
mid = (left + right) / 2 = 3  // 会取靠左的位置
```

重要的是：二分查找**不需要严格找到正中间的位置**。关键是要**将搜索范围大致对半分**，以便快速缩小查找范围。

3.在实现时通常使用：

```c
mid = (left + right) / 2;  
// 或者防止溢出的写法
mid = left + (right - left) / 2;
```

这种计算方式在偶数长度时会自动向下取整，这完全没有问题，因为：

1. 能保证将数组分成两部分
2. 不会漏掉任何元素
3. 每次都能有效地缩小查找范围

**两个边界直接相加除以2不行吗？ 防止溢出的写法的依据来自什么？**

这两种写法在**数学上是等价的**。但在计算机中，第一种写法可能会出现问题，原因是：

**整数溢出风险：**

- 在C语言中，int类型的最大值是 2147483647 (2^31 - 1)
- 如果 left 和 right 都很大，它们的和可能超过int的最大值
- 例如：left = 2147483640，right = 2147483645
- left + right 会溢出，导致计算错误(**确实，如果左右边界都接近int的极限范围，如果相加必然超出表示范围**)

**第二种写法的好处：**

- right - left 得到的是区间长度，一定小于数组长度
  - **先计算差值，再除以二，把原来的参考位置加回来即可**
- 然后除以2得到半个区间长度
- 最后加上left得到中间位置
- 这样就避免了中间计算结果超出int范围的问题
- ![image-20241108153420457](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241108153420457.png)

**所以，防溢出写法的依据来自：**

1. 计算机整数类型的取值范围限制
2. 实际业务中可能遇到大数组的情况
3. 保证算法在各种情况下的健壮性

这就是为什么在实际工程中更推荐使用第二种写法的原因。



**二分查找，为什么继续的条件是left <= right？ 是因为left不断向右推进，right不断向左推进，当查找到只剩余最后一个元素了，left和right就重合了，如果最后一个元素也不是，那么两个指针就相互越过了，也没有元素可以查了就直接退出？**

是的，你的理解完全正确！下面详细解释一下为什么二分查找的循环条件是 `left <= right`：

**核心逻辑**

- `left` 和 `right` 分别代表当前查找范围的左右边界。
- 每次计算 `mid`（中间索引）来检查该位置的值是否等于目标值。
- 根据目标值 `target`与 `arr[mid]`的大小关系：
  - 如果 `arr[mid] < target`，则目标值一定在右半部分，更新 `left = mid + 1`。
  - 如果 `arr[mid] > target`，则目标值一定在左半部分，更新 `right = mid - 1`。

**循环条件解释**

- 当 `left <= right`时，查找范围中仍然有元素未被检查。
  - **例如，如果 `left == right`时，查找范围只有一个元素。**
  - 如果此时 `arr[mid]` 仍不等于 `target`，那么下一次迭代会使 `left` 或 `right` 进一步缩小查找范围。
- 当 `left > right`时，查找范围为空。
  - 这意味着所有可能的元素都已经检查过，且都不是目标值，此时循环结束。

**边界条件**

- 当目标值不在数组中时：
  - 在最后一次迭代后，如果 `arr[mid] != target`，更新 `left` 或 `right` 使得 `left > right`。
  - 例如，目标值比数组中所有元素都大，那么 `left` 会被不断推进，直到 `left == size`。
- 当目标值是数组中的某个元素时：
  - 一旦找到 `arr[mid] == target`，立即返回 `mid`，循环结束。

**循环终止后的状态**

- `left > right` 时，所有可能的位置都被排除。
- 如果目标值不在数组中，函数返回 `-1`，表示未找到。

举个例子：

假设数组 `arr = [1, 3, 5, 7, 9]`，目标值 `target = 4`。

1. 初始：left = 0, right = 4，mid = 2，arr[mid] = 5。
   - `arr[mid] > target`，更新 `right = mid - 1 = 1`。
2. 第二次：left = 0, right = 1，mid = 0，arr[mid] = 1。
   - `arr[mid] < target`，更新 `left = mid + 1 = 1`。
3. 第三次：left = 1, right = 1，mid = 1，arr[mid] = 3。
   - `arr[mid] < target`，更新 `left = mid + 1 = 2`。

此时 `left = 2, right = 1`，`left > right`，循环结束，未找到目标值，返回 `-1`。

总结

- **`left <= right` 确保每次迭代都有效**。
- 当查找范围为空 (`left > right`) 时，循环结束。



```c
#include <stdio.h>

// 二分查找函数
// 参数说明：
// arr: 已排序的数组
// size: 数组长度
// target: 要查找的目标值
// 返回值：找到则返回元素下标，未找到返回-1
int binarySearch(int arr[], int size, int target) {
    int left = 0;                // 左边界
    int right = size - 1;        // 右边界,最大可用下标
    
    while (left <= right) {      // 当左边界小于等于右边界时继续查找
        int mid = left + (right - left) / 2;  // 计算中间位置
        
        if (arr[mid] == target) {         // 找到目标值，先判断中间值是不是，不是再拿选择左边还是右边
            return mid;
        } else if (arr[mid] < target) {   // 目标值在右半部分，更新左指针
            left = mid + 1;
        } else {                          // 目标值在左半部分，更新右指针
            right = mid - 1;
        }
    }
    
    return -1;  // 未找到目标值
}

// 主函数，包含测试用例
int main() {
    int arr[] = {1, 3, 5, 7, 9, 11, 13, 15, 17};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    // 测试用例
    printf("数组元素：");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    // 测试几个不同的查找值
    int test_values[] = {7, 15, 10};
    for (int i = 0; i < 3; i++) {
        int target = test_values[i];
        int result = binarySearch(arr, size, target);
        
        if (result != -1) {
            printf("找到数值 %d，位置为：%d\n", target, result);
        } else {
            printf("未找到数值 %d\n", target);
        }
    }
    
    return 0;
}
```

这个二分查找的实现有以下特点：

1. 使用迭代而不是递归，更容易理解
2. 使用 left + (right - left) / 2 计算中点，**避免整数溢出**
3. 包含了详细的注释说明
4. 提供了测试用例展示如何使用

使用这个程序，你可以看到它会：

- 查找到数值7（在第3个位置，索引为3）
- 查找到数值15（在第7个位置，索引为7）
- 查找不到数值10（返回-1）

需要注意的是，二分查找要求数组必须是已排序的。如果你需要在未排序的数组中使用，需要先对数组进行排序。



## 指针

### 变量与地址

```c
int i = 1;//定义变量并初始化，存储占4个字节，以补码的形式存到分配的内存空间中，用i标识这块空间的值，使用i可以访问空间中的值，&i拿到的是这块空间的起始地址，结束地址应该在这个基础上加4个字节
printf("%d\n",i);//打印i的值：1
printf("%p\n",&i);//打印存放i的值的地址：0000001404dffb0c
```

`int i = 1;` 中的 i 是一个标识符（变量名），它**直接代表这块内存空间中存储的值**，而不是地址

- 当使用 i 时，编译器**直接访问**这个内存空间中存储的值（1）
- 不需要什么"起始地址+一个int大小"的操作

可以这样理解：

- **i 就是用来直接访问这块空间中的值的标识符**
- **&i 才是获取这块空间的起始地址的操作**
- 内存空间中直接存储的就是值 1（以补码形式）



**变量名就是程序员对某一块内存空间的抽象命名，地址是不会变的，关键看与什么变量名关联。**

比如公司名（腾讯）与这栋楼的关系，只要合同没到期，公司名就是就是这栋楼的抽象标识

合同到期也可能有其他的公司（华为）作为这栋楼的抽象标识

**变量与内存地址**：`int i = 1;` 定义了一个整型变量 `i`，并在内存中分配了 4 个字节用于存储它的值（在大多数系统上，`int` 通常占用 4 字节）。`&i` 获取的是 `i` 变量**在内存中的起始地址**，**通过类型可以知道具体分配的空间大小**。

**地址的稳定性**：变量的地址在程序运行期间是固定的，除非变量的作用域结束，或者是局部变量在函数调用中被重新分配。**变量名是对这个内存地址的一个抽象标识符**。但是对外的抽象标识可能会变。

### 指针

**C语言指针可以被视为一个变量，它存储了另一个变量的内存地址 就是说它本身标识了一块空间，这块空间中存储了另一个地址，所以为什么指针的大小都是固定的，因为只需要存一个地址而已？ 有示意图吗？**

![image-20241113103656066](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241113103656066.png)

1. 蓝色框表示指针变量`ptr`

   本身占用的内存空间

   - 这个空间有固定的大小（4或8字节）
   - 这个空间是由变量名`ptr`标识的

2. 蓝色框内的黄色虚线框表示存储在ptr空间内的内容

   - 这个内容就是一个内存地址值（例如0x200）
   - 这个地址指向实际数据所在的位置

3. 绿色框表示实际数据（value=42）所在的内存位置

   - 这个位置的地址就是存储在ptr中的值（0x200）

这就像是：

- 你有一个邮箱（ptr的空间）
- 邮箱里存着一张纸条（地址值0x200）
- 纸条上写着另一个地方的地址
- 真正的数据（42）存在那个地址指向的位置



指针变量的大小是固定的，原因是：

1. 指针只需要存储内存地址
2. 在特定的系统架构下，内存地址的长度是固定的：
   - 32位系统：地址长度为32位(4字节)
   - 64位系统：地址长度为64位(8字节)

所以不管指针指向的是什么类型的数据（可能是1字节的char，4字节的int，或更大的结构体），指针变量本身的大小都是固定的，因为它只存储一个地址值。这就像门牌号码的长度是固定的，不管房子大小如何。



**指针可以指向任何一个任意大的数据或者数据结构，因为它只需要保存一个起始地址而已？**

![image-20241113104112183](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241113104112183.png)

1. 左边：指向单个字符（1字节）的指针
   - **char_ptr只存储字符'A'所在位置的地址**
2. 中间：指向整型数组（20字节）的指针
   - **arr_ptr只存储数组第一个元素的地址**
   - **通过这个起始地址，程序知道后面还有4个int**
3. 右边：指向大型结构体（可能上百字节）的指针
   - **struct_ptr只存储结构体开始位置的地址**
   - **编译器知道结构体的完整布局，可以通过这个起始地址访问任何成员**

**关键点：**

1. 所有指针变量的大小都是相同的（32位系统4字节，64位系统8字节）
2. 指针只需要存储数据的起始地址
3. **编译器会根据指针类型知道：**
   - **从这个地址开始要读取多少字节**
   - **如何解释这些字节（如int、float、结构体等）**
   - **如何进行地址运算（如指针+1时要跳过多少字节）**

这就像一本书的目录页码一样 - 不管后面的章节有多长，目录里只需要记录章节的开始页码就够了。





**指针可以被视为一个变量，它存储了另一个变量的内存地址**。具体来说：

- **指针的定义**：指针是一个数据类型，用于**存储某个类型变量的地址**。例如，`int *p;` 定义了一个**指向整型的指针** `p`（指针这个变量标识的空间里存的地址是一个int地址，如果是起始地址的话，那么下一个元素的位置也可以知道）。

  - `int *p = &i;` 这行代码确实要这样理解：

    1. 声明部分 (`int *p`)：
       - 定义了一个指针变量p
       - 在大多数系统上，p会占用8字节（64位系统）或4字节（32位系统）的空间
       - p的类型是"指向int的指针"
    2. 初始化部分 (`= &i`)：
       - 把i的地址值存储在p所标识的空间中
       - 而不是把地址赋值给*p（解引用操作）

    3. 你的分析中的这几点都很正确：

       - 确实是 TYPE NAME = VALUE 的形式

       - 包含了定义和初始化两个步骤

       - p变量标识的空间存储的就是&i的值（即i的地址）

    4. 补充一点：

       - `*p`是解引用操作，用于访问p指向的内存空间中的值

       - 比如后续写`*p = 2;`才是通过指针修改i的值

       - i（直接标识这块空间的值）和指针p（间接标识：指针p标识的空间中存着这块空间的起始地址）

         - ```c
           i的内存空间：
           地址：      0000001404dffb0c       
           内容：      00000001               // i直接标识这里存的1
                      |--- 4字节 ---|
           
           p的内存空间：
           地址：      0000001404dffb20       
           内容：      0000001404dffb0c       // p标识的空间存的是i的起始地址
                      |--- 8字节 ---|         // 64位系统上指针占8字节
           ```

           

    5. i 是直接标识：

       - 直接代表内存空间中的值1
       - 使用i就是直接访问这个值

       p 是间接标识：

       - p标识的空间里存的是i的起始地址
       - 要通过 *p 解引用才能访问到i的值
       - 这就是所谓的"间接访问"

- **指针的大小**：指针的大小通常是固定的，通常为 4 字节（在 32 位系统上）或 8 字节（在 64 位系统上）。**无论指针指向的数据类型是什么，指针本身的大小是相同的。 **(因为标识的空间中只存地址而不是有具体大小的值)

- **指针的类型**：

  - 指针前面的类型（如 `int *`、`char *` 等）告诉编译器指针指向的数据类型。**这在取值时很重要，因为它影响到如何访问和解释指针所指向的内存内容。**

    - 例如，当你使用 `*p` 时，编译器知道 `p` 是指向整型的指针，因此它会根据整型的大小（通常是 4 字节）来读取内存中的数据。

  - **类型不匹配**：

    - ```c
      char *c = &i;
      ```

      这里 `c` 是一个指向 `char` 的指针，它实际上指向一个 `int` 类型的变量 `i`。因为 `int` 通常占用 4 个字节，而 `char` 只占用 1 个字节。

    - **取值时的问题**：当你使用 `*c` 时，**实际上你只获取了 `i` 地址处的第一个字节**，这可能不是 `i` 的完整值。例如，如果 `i` 的值是 1，它的 4 字节补码表示在内存中可能是 `0x01 0x00 0x00 0x00`（视系统的字节序而定），那么 `*c` 只会返回 `0x01`，而不是 `1`。

- **指向地址的作用**：指针本质上就是一个地址，它可以用来**间接访问**存储在该地址上的值。例如，通过 `*p` 可以访问指针 `p` **指向**的**地址**上**的值**。

  - **内存示意图**

    假设 `i` 的地址是 `0x1000`，`p` 的地址是 `0x2000`，它们在内存中的布局可能是这样的：

    | 地址   | 内容   | 变量名 |
    | ------ | ------ | ------ |
    | 0x1000 | 1      | i      |
    | 0x2000 | 0x1000 | p      |

    - `i` 直接在 `0x1000` 位置存放 `1`。
    - `p` 在 `0x2000` 位置存放的是 `i` 的地址 `0x1000`。

  - 指针本质上就是一个存放地址的变量。

    普通变量存放的是具体的值。

    它们的区别主要在于内存中的存储内容不同，一个存地址，一个存值。

- **动态内存管理**：指针在动态内存分配、数组操作和函数参数传递中非常有用，因为它们允许你直接操作内存地址，而不是仅仅通过值（**因为函数参数传递的是值的副本不影响原值**）。

指针本身也是一个变量（自己标识着一块空间），它**存储**着另一个变量的**地址**。**因此，指针也有自己的地址**。具体来说：

1. **指针的地址**：指针变量（如 `p`）在内存中有自己的地址，你可以使用 `&p` 来获取这个地址。
2. **指针内容**：指针中**保存的**是另一个变量的**地址**。例如，在 `int *p = &i;` 中，`p` 保存的是变量 `i` 的地址。
3. **总结**：**指针本身有地址（本身标识一块空间），指向的内容是另一个变量的地址（这块空间中存放的是一个地址）**。这种结构允许通过指针间接访问其他变量的值。

### 变量与指针

**变量**：直接保存数据的值。机器为每个变量分配一个内存地址，并在该地址上存储该值**形成一块空间，而变量直接标识这块空间中的这个值，通过变量名可以直接访问这个值。**

**指针**：保存另一个变量的内存地址。通过指针运算（如解引用运算符 `*`），你可以访问存储在该地址上的值。

```c
int i = 1;//定义变量并初始化，存储占4个字节，以补码的形式存到分配的地址中
printf("%d\n",i);//打印i的值：1
printf("%p\n",&i);//打印存放i的值的地址：0000001404dffb0c
int	*p = &i;//这个指针指向0000001404dffb0c，通过指针运算可以间接访问此地址中的值
printf("%p\n", &p); // 打印指针 p 本身的地址:000000a23d5ffa80
指向：*p存的是0000001404dffb0c，指针p本身也就是有也标识一块空间（64位8个字节），空间中存的是0000001404dffb0c
```

### 指针与指针变量

**指针的概念**

- **指针**是一个概念，指向某块内存的地址。
  - 函数传递参数时，传一个指针过来，表示传递一个地址过来
- 它表示一个内存地址，用来访问该地址存储的数据。

**指针变量**

- **指针变量**是一个实际的变量，它存储的是一个地址值。
- 它可以用来存放某个变量的地址，从而通过这个地址间接访问变量。

**总结：**

- 指针是一个概念，表示内存地址。
- 指针变量是一个实际的变量，用来存储指针（地址）。

## 二级指针

### 示意图

**二级指针跟一级指针理解类似：给我画一个内存示意图 如：二级指针 * sp标识的空间中存着一个一级指针*p,占用大小8个字节（64位系统） 而一级指针*p标识的空间中存着一个地址，这个地址可以是一个变量的地址，也可以是一个数据结构的起始地址？**

![image-20241113152903907](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241113152903907.png)

1. 二级指针 **sp：
   - 占用8字节内存空间（64位系统）
   - **存储的是一级指针的地址（图中指向0x2000）**
   - 本身指针在内存中标识着0x1000+8个字节的空间，但sp拿的是这个空间的起始地址，*sp拿的是空间中存放的地址
   - 这个8字节空间里面存着一个地址是另一个指针在内存中的起始地址
2. 一级指针 *p：
   - 同样占用8字节内存空间
   - **存储的是实际数据的地址（图中指向0x3000）**
   - 本身指针在内存中标识着0x2000+8个字节的空间，但p拿的是这个空间的起始地址，*p拿的是空间中存放的地址
3. 实际数据：
   - 可以是简单变量（如int、char等）
   - 也可以是复杂的数据结构（如数组、结构体等）的起始地址

这种层层指向的关系可以类比为：

- **sp 指向了 *p 的位置
- *p 再指向实际数据的位置
- 指向：存了对方的起始地址

这就是为什么我们说二级指针是"指向指针的指针"。

![image-20241113153512684](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录2之三座大山.assets\image-20241113153512684.png)

1. 最外层是整个内存空间
2. 二级指针 **sp 包含了一级指针的区域（蓝色区域）
3. 一级指针 *p 包含了实际数据的区域（绿色区域）
4. 最内层是实际数据（橙色区域）

每一层的关系都是：

- 外层指针指向内层指针的地址
- 最内层是实际存储的数据



**二级指针存的是一级指针的地址，那么占用的空间是多少？无论地址是多少都占用8个字节（64位系统）？**

在64位系统中：

1. 无论指针指向的地址是什么值（比如0x1000还是0xFFFFFFFF），指针变量本身占用的空间都是固定的8字节（64位）
2. 这适用于所有类型的指针：
   - 一级指针（*p）占8字节
   - 二级指针（**sp）占8字节
   - 三级指针（***tp）也是8字节 ...以此类推



1. **指针变量**：如果你有一个指针 `int *p;`，它存储了另一个变量（如 `int i;`）的地址。

2. **二级指针**：如果你定义一个指针 `int **n;`，那么 `n` 存储的是指针 `p` 的地址。

   1. **二级指针的定义**：

      - `int **q = &p;` 定义了一个二级指针 `q`，它存储了指针 `p` 的地址。

      **使用 `q`**：

      - 当你使用 `q` 时，它代表这个二级指针本身，即它存储的 `p` 的地址。

      **使用 `*q`**：

      - 使用 `*q` 时，实际上是解引用 `q`，这将得到指针 `p` **的值**（即 `p` 存储的地址）。
      - 如果你进一步使用 `**q`，那将会访问 `p` 指向的地址中的值（也就是变量 `i` 的值）。

3. **关系**：

   - `*p` 存储的地址指向的是变量 `i`。
   - `*n` 将指向 `p` 存储的地址，因此可以通过 `**n` 来访问变量 `i` 的值。

这个概念被称为指针的指针，它可以用于处理更复杂的数据结构。

```c
int i = 1;
int	*p = &i;
int **q = &p;


i---> 1   i的值
&i---> 0000001404dffb0c  存放i的值的地址
p---> 0000001404dffb0c   作为变量在内存分配的地址里存的值，&i
&p---> 000000a23d5ffa80   作为变量本身在内存中的地址
*p---> *（0000001404dffb0c）---> 1  取值：去地址中取值
q---> 000000a23d5ffa80   作为变量在内存分配的地址里存的值，&p
&q---> 000000a23d5ffb85  作为变量本身在内存中的地址
*q---> 0000001404dffb0c  取值：取q在内存分配的地址里存的地址的值 &i
**q---> 1 --->*(&i)      分开步骤来操作,有多层嵌套时可以分开操作。

```

### 直接访问与间接访问

#### 直接访问

- **定义**：直接访问是通过变量名直接获取变量的值。

```c
int i = 1; // 直接访问变量 i
printf("%d\n", i); // 输出 1
```

- **特点**：直接使用变量名，易于理解，效率较高，因为不需要额外的操作。

#### 间接访问

- **定义**：间接访问是通过指针来访问变量的值。你首先通过指针获取变量的地址，然后使用解引用操作符 `*` 获取该地址中的值。

```c
int i = 1;
int *p = &i; // p 存储 i 的地址
printf("%d\n", *p); // 输出 1，通过指针间接访问
```

**特点**：间接访问允许更灵活的内存管理，特别是在处理动态分配内存、传递大数据结构（如数组或结构体）时，避免了复制整个数据的开销。但它需要更多的操作，可能导致更复杂的代码。

#### 总结

- **直接访问**：简单、快速，适合基本操作。
- **间接访问**：灵活、强大，适合更复杂的场景，如动态内存管理和数据结构操作。

### 空指针与野指针

#### 空指针

**定义**：空指针是一个指针变量，它不指向任何有效的内存地址，通常被初始化为 `NULL`。

```c
int *p = NULL; // p 是一个空指针
```

**特点**：使用空指针可以安全地表示“无效”或“未指向任何对象”。在使用空指针之前，检查它是否为 `NULL` 可以防止访问无效内存。

#### 野指针

**定义**：野指针是指一个指针变量，它指向了一个不再有效的内存地址。这个地址可能是之前被释放的内存，或者是未初始化的指针。

```c
int *p; // p 是未初始化的指针，成为野指针
int *q = malloc(sizeof(int)); // 分配内存
free(q); // 释放内存
// 此时 q 变成野指针，因为它指向的内存已经被释放
```

**特点**：使用野指针会导致未定义行为，因为你可能试图访问一个无效的内存区域。野指针常常导致程序崩溃或数据损坏。

#### 总结

- **空指针**：安全、不指向有效地址，可以用来表示“无效”。
- **野指针**：不安全、指向无效地址，容易导致错误。

### 空类型

“空类型的指针”通常指的是 `void *` 指针，这种指针没有具体的数据类型，可以指向任何类型的数据。

`void *` 是一种通用指针类型，表示它可以指向任何类型的数据。它本身不具备特定的类型信息。

- **灵活性**：`void *` 指针常用于需要通用指针的场合，例如在动态内存分配函数（如 `malloc`）中。

- **类型转换**：在使用 `void *` 时，通常需要将其转换为具体的指针类型，以便访问或操作指向的数据。

```c
void *p;
int i = 10;
p = &i; // p 指向整型变量 i
printf("%d\n", *(int *)p); // 将 void * 转换为 int * 后解引用
```

由于 `void *` 指针没有类型信息，因此在使用之前必须进行类型转换，以确保正确访问内存。

### 指针运算

1. **运算符含义**：
   - `&`：取变量的地址。
   - `*`：取指针所指向的地址中的值（解引用）。
2. **指针定义**：
   - 在 `int *p = &i;` 中，`*` 用于定义 `p` 为一个指向整型的指针，这是语法上的约定。
3. **指针的使用**：
   - 当你使用 `p` 时，它表示指针本身，即它所存储的地址。
   - 当你使用 `*p` 时，这个 `*` 就是运算符，它表示取 `p` 指向的地址中的值。

因此，`*` 的含义在不同上下文中是不同的：在定义指针时，它是类型标识符，而在使用时，它是解引用运算符。

### 指针与数组的关系

#### 	指针与一维数组

```c
int arr[3] = {1,2,3};
arr[i]是如何取对应值的位置的：a (数组的起始位置) + i （i个数据类型，这里是int），直接访问
int *p = a; 用指针变量p来存这个数组的起始地址
arr[i]是如何取到值的：p (存的是数组的起始位置) + i （i个数据类型，这里是int）再用*运算符，间接访问
arr[i] = *(a+i) = *（p+i）= p[i]
&arr[i] = arr+i =  p+i = &p[i]  
```

**数组名作为指针**：

- 在表达式 `arr[i]` 中，`arr` 是数组的名字，它实际上代表数组的起始地址。也就是说，`arr` 是指向数组第一个元素的指针。

**数组下标的计算**：

- `arr[i]` 的计算可以展开为 `*(arr + i)`，其中 `arr` 是数组的起始地址，`i` 是偏移量（元素的个数），`*(arr + i)` 通过解引用操作符 `*` 访问数组中第 `i` 个元素的值。

**指针的使用**：

- 当你定义 `int *p = arr;` 时，`p` 也指向数组的起始位置。
- 因此，`*(p + i)` 与 `arr[i]` 是等价的，都是访问数组中第 `i` 个元素。

**表达式的等价性**：

- 你的表达式 

  ```
  arr[i] = *(a + i) = *(p + i) = p[i]
  ```

   可以逐一解释如下：

  - `arr[i]`：直接通过数组下标访问元素。
  - `*(arr + i)`：通过指针运算访问元素（这里 `arr` 是数组的起始地址）。
  - `*(a + i)`：假设 `a` 也是指向数组起始位置的指针，它与 `arr` 相同。
  - `*(p + i)`：通过指针 `p` 访问第 `i` 个元素。
  - `p[i]`：通过数组下标语法访问指针 `p` 指向的元素。
    - 指针可以像数组一样使用下标，这是一种非常有用的特性

##### 指针的下标操作

**等价性**：

- 当你有一个指向数组的指针时，比如 `int *p = arr;`，你可以使用下标语法 `p[i]` 来访问指针所指向的数组元素。实际上，`p[i]` 等价于 `*(p + i)`。

**访问元素**：

- 使用下标操作，可以方便地访问指针指向的内存区域，就像访问数组一样。例如：

- ```c
  int arr[3] = {1, 2, 3};
  int *p = arr; // p 指向 arr 的起始位置
  printf("%d\n", p[1]); // 输出 2
  ```

**灵活性**：

- 这种方式使得指针在操作数组时更加灵活和强大。你可以动态地改变指针的指向，而不需要改变数组的结构

**差异：** 

- 一维数组名是常量，一级指针是变量，**其他在使用上可以等价**
- arr++  —> a = a+1  会报错，因为常量不能出现在左边
- p++ —> 指针就指向数组的第二个元素的地址
- p+1 —> 这一句话p指向不变，只不过要获取p指向的下一个地址

**数组名只是对内存一块空间的抽象**：

- ```c
  int *p = (int [3]){1,2,3};
  int i;
  for(i = 0;i<3;i++)
  	printf("%p--->%d\n",&p[i],p[i]);
  ```

  - 这里使用了复合字面量定义了一个大小为 3 的整型数组，并直接初始化为 `{1, 2, 3}`。这个数组的地址被赋给指针 `p`。

    `p` 现在指向这个数组的起始位置。

  - 在循环中，`&p[i]` 获取的是 `p` 指向的数组第 `i` 个元素的地址。

    `p[i]` 访问的是数组第 `i` 个元素的值。

    每次迭代，程序会输出该元素的地址和对应的值。

- **总结**

  - **数组名的抽象**：你提到的“数组名只是对内存一块空间的抽象”在这里得到了体现，因为通过指针 `p`，你可以灵活地操作这块内存，而不需要明确的数组名。
  - **指针与数组的关系**：这种方式展示了指针与数组之间的紧密关系，允许通过指针来访问和操作数组元素。

#### 	指针与二维数组（重点）



##### 行指针的概念

**行指针和数组指针是同一个概念！**

**数组名的含义**：

- `arr` 是一个指向二维数组第一行的指针，类型为 `int (*)[3]`，表示它指向一个包含 3 个整型元素的一维数组。
- `arr[0]` 和 `*(arr + 0)` 实际上是同一个地址，指向数组的第一行。

**行指针的计算**：

- 当你写 `arr + 1` 时，这实际上是指向数组的第二行。**由于每一行的大小是 3 个整型（12 字节）**，`arr + 1` 将指向数组中第二行的起始地址（即 `arr[1]`）。
- **在这种情况下，`arr + 1` 的类型是 `int (*)[3]`，同样是指向大小为 3 的整型数组的指针**。

例如，对于数组：

```c
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
arr 指向 arr[0]（第一行）。
arr + 1 指向 arr[1]（第二行）。
```

如果你使用行指针，可以通过如下方式访问：

```c
int (*p)[3] = arr; // p 指向第一行
printf("%d\n", p[1][0]); // 访问第二行的第一个元素，输出 4

int *p;
p = arr;//为什么不能这么赋值？
int (*p)[4] = arr; 是正确的，因为：

p 被声明为一个指向"大小为4的整型数组"的指针
arr 作为二维数组名，实际上就是指向第一个内层数组（含3个整数）的指针
所以类型是匹配的
    
int *p; p = arr; 是错误的，因为：
p 是指向单个整数的指针
而 arr 是指向"大小为3的整型数组"的指针
这两个类型不匹配
    
这就像是：
int *p 是"能装单个苹果的篮子"
int (*p)[3] 是"能装3个苹果的篮子"
你不能把"3个苹果的篮子"直接赋值给"单个苹果的篮子"
```

这涉及到了行指针和列指针的区别：

**行指针**：`int (*p)[4]`

```c
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
int (*p)[4] = arr;  // p是行指针
```

特点：

- 每次 `p+1` 会跳过一整行（4个整数）

- 可以用 `p[i][j]` 这样的方式访问元素

- 类型匹配二维数组的本质（指向含4个整数的数组）

- ```c
  p[1][0];      // 访问第2行第1个元素(值为5)
  *(*(p+1)+0);  // 等价形式
  ```

**列指针**：`int *p`

```c
int *p = &arr[0][0];  // p是列指针,这是直接把第一行第一个元素的地址赋值过去了
// 或
int *p = (int *)arr;  // 强制类型转换
```

特点：

- 每次 `p+1` 只跳过一个整数

- 需要手动计算行列偏移

- 可以连续访问所有元素

- ```c
  *(p + 4);     // 访问第2行第1个元素(值为5),一行三个，跳到第四个为第二行第一个
  p[4];         // 等价形式
  ```

###### 行指针与列指针的使用区别

```c
// 使用行指针
int (*p)[4] = arr;
printf("%d\n", p[1][0]);      // 直观地访问第2行第1个元素

// 使用列指针
int *p = &arr[0][0];
printf("%d\n", p[1*4 + 0]);   // 需要手动计算偏移量：行数×列数+列号
```

**内存访问示意图**：

```
内存布局：
1  2  3  4    ← 行指针p指向这里
5  6  7  8    ← p+1指向这里
9  10 11 12   ← p+2指向这里

同样的内存布局，但用列指针看：
1  →  2  →  3  →  4  →  5  →  6 ...   
↑
列指针p指向这里，然后一个个遍历
```

所以：

- 行指针更适合按行操作二维数组
- 列指针更适合连续遍历所有元素
- 它们的本质区别在于指针运算时的步长不同

在定义行指针时，我们必须明确指定一行有多少个元素（也就是列数），这样指针才能正确地按行跳转。

```c
// 例子1：标准的二维数组和行指针
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
int (*p)[4] = arr;   // 必须指定4，表示一行有4个元素
```

这里的 `[4]` 告诉编译器：

1. 每行占用 `4 × sizeof(int)` 字节的空间
2. 当执行 `p+1` 时，需要跳过 `4 × sizeof(int)` 字节

我们可以用不同类型来看这个原理：

```c
// 例子2：不同数据类型的情况
char arr1[3][5];
char (*p1)[5] = arr1;    // p1+1 跳过 5×sizeof(char) = 5字节

double arr2[3][6];
double (*p2)[6] = arr2;  // p2+1 跳过 6×sizeof(double) = 48字节

struct Student {
    int id;
    char name[20];
} class[3][2];
struct Student (*p3)[2] = class;  // p3+1 跳过 2×sizeof(struct Student)
```

实际使用时的内存布局：

```
以 int arr[3][4] 为例：

内存中的排列：
1    2    3    4    │ 一行占用 4×sizeof(int) = 16字节
↑
p 指向这里

5    6    7    8    │
↑
p+1 指向这里 (跳过了16字节)

9    10   11   12   │
↑
p+2 指向这里 (再次跳过16字节)
```

这就是为什么声明行指针时必须正确指定列数的原因：

1. 编译器需要知道每行有多少个元素
2. 这样才能在指针运算时计算出正确的内存偏移量
3. 确保 `p[i][j]` 这样的访问方式能正确找到目标元素

##### 数组名的含义与行指针

```c
#include <stdio.h>


int main(){
	int arr[3][4] = {
		{1, 2, 3, 4},
		{5, 6, 7, 8},
		{9, 10, 11, 12}
	};
	//虽然是存放地址，地址之间没有区别，但是类型是由区别的，决定着如何取值
	//arr行指针类型的地址 类型为int (*p)[4]
	//int *p = arr; //[警告] initialization of 'int *' from incompatible pointer type 'int (*)[4]' [-Wincompatible-pointer-types]

	//&arr是整个二维数组的地址，类型为int (*p)[3][4]
	//int *p = &arr;//[警告] initialization of 'int *' from incompatible pointer type 'int (*)[3][4]' [-Wincompatible-pointer-types]
	
	//列指针才是int 类型的地址
//	int *p = &arr[0][1];
//	printf("%p\n",&arr[0][1]);//000000abf65ffdf4
//	printf("%p\n",p);//000000abf65ffdf4
	
	//arr行指针类型的地址 类型为int (*p)[4]
	//要是真想赋值进去只需要强转换类型
	int *p = (int *)arr;
	printf("%p\n",p);
	//赋值是否需要类型相同？
	//会自动转换的前提？
	//为什么地址的类型不会转换？
	
	return 0;
}
```

1.关于赋值和类型:

这里涉及两个概念:

- arr 的类型实际上是 `int (*)[4]`(指向包含4个int的数组的指针)
- 我们将它强制转换为 `int *`(指向单个int的指针)

**自动类型转换的前提:**

- 指针类型之间不会自动转换,除非:
  - 目标类型是 void*
  - 源类型是空指针常量(NULL) 这是为了保证类型安全。

**为什么地址类型需要手动转换:**

- 不同类型的指针虽然都是地址,但它们的:
  - 步长不同(比如 int* 步长是4字节,char* 步长是1字节)
  - 解引用行为不同
- 编译器需要明确知道如何操作这个地址



##### C语言的类型自动转换(隐式转换)的规则

**1.算术类型间的转换:**

```c
int a = 10;
double b = a;    // int -> double 自动转换
float f = 3.14;  // double -> float 自动转换
char c = 'a';
int i = c;       // char -> int 自动转换
```

主要遵循以下规则:

- 若两种类型的精度不同,转换为精度高的类型
- 转换方向: char → short → int → long → float → double

**2.赋值时的自动转换:**

```c
int a;
double b = 3.14;
a = b;    // double截断为int(可能丢失精度,但允许自动转换)
```

**3.函数参数的自动转换:**

```c
void func(double x) { /*...*/ }

int main() {
    int n = 10;
    func(n);    // 调用时int自动转换为double
}
```

**4.运算符操作时的自动转换:**

```c
int a = 10;
double b = 3.14;
double c = a + b;    // a被自动转换为double再进行运算
```

**5.不能自动转换的情况:**

```c
// 指针类型之间(除了void*和NULL)
int *p;
double *q = p;    // 错误!

// 结构体/联合体
struct A {int x;};
struct B {int x;};
struct A a;
struct B b = a;    // 错误!

// 浮点数到指针
float f = 100.0;
int *p = f;       // 错误!
```

需要注意:

1. 虽然支持自动转换,但如果可能丢失精度,编译器通常会给出警告
2. 向下转换(如double→int)可能导致数据丢失
3. 有些自动转换可能导致不易发现的bug

```c
unsigned int a = 10;
int b = -20;
if(a > b) {    // b被转换为unsigned int,变成很大的正数!
    printf("unexpected!\n");
}
```

建议:

- 当涉及重要数据时,最好使用显式转换
- 警惕可能导致精度丢失的转换
- 注意有符号和无符号数的转换陷阱



##### 二维数组的抽象

**定义**：

- 二维数组 `int arr[2][3]` 可以看作是一个包含 2 个元素的一维数组，每个元素又是一个大小为 3 的一维数组。

**内存布局**：

- 在内存中，arr是一个连续的内存块，所有元素都是顺序存储的。例如：
  - `arr[0][0]`, `arr[0][1]`, `arr[0][2]` 是第一个一维数组的元素。
  - `arr[1][0]`, `arr[1][1]`, `arr[1][2]` 是第二个一维数组的元素。

**访问方式**：

- 你可以通过数组下标**直接**访问二维数组元素：

  ```c
  arr[1][2] = 5; // 将第二个一维数组的第三个元素赋值为 5
  ```

- 也可以使用**行指针（数组指针）** **间接**来访问二维数组元素：

  ```c
  int (*p)[3] = arr; // p 是指向大小为 3 的整型数组的指针
  printf("%d\n", p[1][2]); // 访问第二个一维数组的第三个元素
  这里 p 是一个指向大小为 3 的整型数组的指针。
  (*p) 表示 p 是一个指针，而 [3] 指明 p 指向的内容是一个有 3 个整型元素的数组
      
  = arr 表示将二维数组 arr 的地址赋给指针 p。由于 arr 本身就是一个指向其第一行的指针，类型是 int (*)[3]（指向含有 3 个整数的一维数组的指针），这使得赋值是合法的。
      
  p[1] 获取的是指向第二个一维数组（arr[1]）的指针。
  p[1][2] 则访问这个数组的第三个元素（arr[1][2]），这将输出对应的值。
      
  为什么这种方式有效？
  因为二维数组在内存中是连续存储的，并且 arr 表示整个数组的地址，arr[i] 表示第 i 行的地址。因此，声明 int (*p)[3] 让 p 指向大小为 3 的数组（也就是二维数组中的每一行），这完全符合二维数组的内存结构。
  
  简化解释：
  
  p 指向一个数组，而这个数组的大小是 3 个 int，这与二维数组 arr[2][3] 中每行的大小一致。
  当你写 p[1][2]，实际上就是在访问 arr[1][2]，因为 p 已经指向了二维数组 arr。
  ```

- `arr[i][j]` 的值是怎么找到的？

`arr` 是一个二维数组，假设它被定义为 `int arr[3][4]`。在内存中，`arr` 的结构可以看作是一个包含 3 个元素的一维数组，每个元素都是一个包含 4 个整型的一维数组。

**arr[2] [3]是怎么找到的？**

**起点：arr**

- `arr` 是指向外层一维数组第一个元素的地址
- 这个外层一维数组有3个元素，每个元素都是一个包含4个整型的内层一维数组

**第一步：arr+2**

- `arr+2` 指向了外层一维数组的第三个元素的地址
- 这里的 `+2` 是按照内层数组的大小进行偏移的，这里类似行指针了，不过以抽象概念来看+2就像在一维数组中第三个元素的地址

**第二步：\*(arr+2)**

- `*(arr+2)` 解引用，拿到了外层数组第三个元素的值，里面存的是一维数组
- 这个值就是内层数组（大小为4的一维数组）的起始地址

**第三步：\*(arr+2)+3**

- `*(arr+2)+3` 在内层数组的起始地址上偏移3个位置
- 得到内层数组第四个元素（索引为3）的地址，索引从0开始的

**最后一步：**  * (*(arr+2)+3)

- `*(*(arr+2)+3)` 再次解引用
- 最终拿到了内层数组第四个元素的值

用图示表达就是：

```c
内存布局：

arr →  [内层数组1] → [0][1][2][3]
       [内层数组2] → [0][1][2][3]
       [内层数组3] → [0][1][2][3]
                           ↑
                     我们要找的元素
                     
索引值:   [0] [1] [2] [3]
arr[0]:   1   2   3   4    // 第1行
arr[1]:   5   6   7   8    // 第2行
arr[2]:   9   10  11  12   // 第3行
                    ↑
                arr[2][3]
arr[2][3]起始指的是第三行第四列元素，因为索引从0开始的
```

所以 `arr[2][3]` 等价于 `*(*(arr+2)+3)`，这两种写法本质上是一样的：

- `arr[2][3]` 是语法糖，更易读
- `*(*(arr+2)+3)` 展示了实际的指针运算过程

**抽象视角**

- **一维数组的数组**：从抽象的角度看，二维数组可以被视作一个包含多个一维数组的结构，这样的视角有助于理解数据的组织方式。
- **灵活性**：通过这种抽象，你可以在需要时轻松地将二维数组转换为一维数组进行处理，从而实现更灵活的内存操作。
- arr本质是一个地址常量以外，在使用上更贴近一个指向行的指针

##### 用二级指针来间接访问二维数组

使用二级指针 (`int **pp`) 来访问二维数组时，`pp` 是**指向指针的指针**，**每个指针再指向一个一维数组（行）**。这种方式与使用行指针的方式不同，因为**行指针直接指向二维数组的每一行，而二级指针涉及更多间接层次。**

总结：

- 你使用的方式是**数组指针**（行指针），它通过指向二维数组的行来间接访问元素。
- 二级指针 (`int **`) 则是通过指针指向指针来实现多维数组的访问。
- **数组指针和二级指针**都能实现对二维数组的间接访问，但它们的内存模型和使用方式不同。

使用二级指针来访问二维数组，涉及多个指针的嵌套。我们先动态分配内存来模拟二维数组。

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 动态创建 2 行 3 列的二维数组
    int **arr = (int **)malloc(2 * sizeof(int *));  // 二级指针，指向指针数组(指针类型的数组)
    for (int i = 0; i < 2; i++) {
        arr[i] = (int *)malloc(3 * sizeof(int));    // 每行分配 3 个 int 的空间
    }

    // 初始化二维数组
    arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3;
    arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6;

    // 用二级指针访问二维数组
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            printf("arr[%d][%d] = %d\n", i, j, arr[i][j]);
        }
    }

    // 释放动态分配的内存
    for (int i = 0; i < 2; i++) {
        free(arr[i]);
    }
    free(arr);

    return 0;
}
```

**解释：**

- `int **arr` 是一个二级指针，表示它指向一个指针数组。
- 通过 `malloc`，我们为 `arr` 分配了 2 个 `int*`，每个 `int*` 再指向一行（3 个 `int`）。
- 访问时，`arr[i][j]` 相当于 `*(arr[i] + j)`，表示对二维数组中第 `i` 行第 `j` 列的元素进行访问。

**内存布局**：

- `arr` 是一个指向指针的指针，每个指针指向一维数组（即每行）。

**二级指针 vs 数组指针**：

1. **内存模型**：
   - **二级指针**：`int **arr` 需要动态分配内存，并且每次访问时，先通过 `arr[i]` 找到指针，再通过 `arr[i][j]` 访问具体元素。每一行的内存位置可能是不连续的。
   - **数组指针**：`int (*p)[3]` 直接指向数组的每一行，数组在内存中是连续存储的，所以通过数组指针直接访问数组中的元素，性能会更高。
2. **访问方式**：
   - **二级指针**：`arr[i][j]` 实际上是先通过 `arr[i]` 找到第 `i` 行的指针，再通过 `arr[i][j]` 访问具体元素。
   - **数组指针**：`p[i][j]` 是直接访问二维数组中的元素。
3. **使用场景**：
   - **二级指针**：常用于动态分配多维数组的场景，可以灵活改变行和列的大小，适合在运行时决定数组大小的应用。
   - **数组指针**：适用于固定大小的二维数组，使用静态内存分配，适合性能要求较高的场景。

#### 	指针与字符数组

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    // 字符指针指向字符串常量区
    char *str = "hello";
    // 字符数组在栈上分配内存
    char stri[] = "hello";
    
    printf("str  的大小和长度: %lu %lu\n", sizeof(str), strlen(str));
    printf("stri 的大小和长度: %lu %lu\n", sizeof(stri), strlen(stri));
    
    // 这里会导致段错误
    // strcpy(str, "world");  // 错误：试图修改只读内存
    可以把指针直接指向“world”，但是hello依旧在字符串常量区，只是没引用
    所以要分清楚操作的是什么东西
    str = "world"; 
    
    // 这个是允许的
    strcpy(stri, "world");    // 正确：修改栈上的内存
    
    puts(stri);
    puts(str);
    
    return 0;
}
```

主要区别在于：

1. 内存位置不同：
   - `char *str = "hello"` 中的 "hello" 存储在常量区（只读内存）
   - `char stri[] = "hello"` 在栈上创建了一个数组，内容可以修改
2. sizeof 的结果不同：
   - `sizeof(str)` 返回指针的大小（通常是4或8字节）
   - `sizeof(stri)` 返回数组的实际大小（这里是6字节，包括结尾的'\0'）
3. 可修改性：
   - `str` 指向的是只读内存，不能修改其内容
   - `stri` 是在栈上的数组，可以自由修改

当你试图执行 `strcpy(str,"world")` 时会发生段错误，因为：

- 这相当于试图修改只读内存
- 字符串常量是不可修改的

### const与指针

#### 改变指针的值和指向的区别

```c
int a = 1;          // 假设a的地址是0x123123
int b = 5;          // 假设b的地址是0x7987866
int *p = &a;        // p存储的是0x123123

// 情况1：改变指针的指向
p = &b;             // p现在存储0x7987866
                    // p指向从a变成了b

// 情况2：修改指针指向的值
*p = 2;             // 因为p现在指向b，所以b的值被改成2
                    // p的值（存储的地址）没变，还是0x7987866
记住：

指针的指向 = 指针自己存储的地址值
指针指向的值 = 那个地址上存储的数据
```

 const关键字主要用于以下几个场景:

- 常量定义 - 最基础的用法:

```c
//用宏定义常量，不会检查语法，只是在预处理阶段进行与宏体的替换
用变量来保存一个常量值，会有被修改的风险
const int MAX_SIZE = 100; // 用const把变量常量化了，
int const a = 100;// 等价写法
```

- 和指针结合时有三种情况:

```c
// 1. 指向常量的指针 (两种等价写法)
const int* p 或 int const* p
// 不能通过指针修改值，但可以改变指针指向:
const int* p = &a;
*p = 2;             // 错误！
p = &b;             // 允许！

// 2. 常量指针
int* const p
// 可以修改指向的值，但不能改变指针指向:
int* const p = &a;
*p = 2;             // 允许！
p = &b;             // 错误！

// 3. 指向常量的常量指针,用法则的话，一左一右就是
const int* const p 或写作: int const* const p4 = &value;
// 既不能修改值，也不能改变指向:
const int* const p = &a;
*p = 2;             // 错误！
p = &b;             // 错误！

const的位置规则是：
const 关键字如果在 * 的左边，表示指针指向的值为常量
const 关键字如果在 * 的右边，表示指针本身为常量
为了帮助记忆，可以按照这个规则：
从右往左读
遇到 const 就加上"常量"这个词
遇到 * 就加上"指针"这个词
    
```

- 在库函数开发中，const和指针经常一起使用的原因:

  - 保护数据安全 比如字符串处理函数:

  - ```c
    size_t strlen(const char* str);
    ```

使用const确保**函数内部不会修改原字符串**。

1. 提高代码可读性 通过const清楚地表明函数的意图 - 这个参数是只读的。
2. 编译器优化 const让编译器能进行更多优化。
3. 接口设计
4. 限制对外的访问权限

```c
// 一个结构体例子
struct Student {
    char name[50];
    int age;
};

// 只读方式访问学生信息
void printStudent(const struct Student* stu) {
    printf("Name: %s\n", stu->name);
    printf("Age: %d\n", stu->age);
}
```

在这些场景中使用const + 指针的好处:

- 节省内存(**传递指针而不是整个对象的副本**)
- 保护数据(防止意外修改)
- 明确接口契约(告诉使用者这个数据是只读的)

这就是为什么在实际开发中，特别是封装库函数时，我们经常看到const和指针一起使用。它们的组合既保证了效率，又提供了安全保障。

#### 值传递和指针传递

```c
// 值传递的例子
void func1(int x) {
    x = 100;    // 修改的是副本，原值不变
}

// 指针传递的例子
void func2(int* x) {
    *x = 100;   // 修改的是原值
}

int main() {
    int a = 1;
    func1(a);   // a还是1
    func2(&a);  // a变成100
}
```

字符串处理函数的情况：

```c
// 这是在传递指针！不是值传递
size_t strlen(const char* str) {
    // str是指针，通过它可以访问原始字符串
    // const保护原字符串不被修改
}

int main() {
    char s[] = "hello";
    strlen(s);  // s传递的是地址，不是副本
}
```

让我们看一个对比示例：

```c
// 1. 真正的值传递 - 整个数组内容被复制
void func1(char str[5]) {
    // 这里的str实际上还是指针！
    // C语言中数组作为参数会退化为指针
}

// 2. 指针传递 - 只传递地址
void func2(const char* str) {
    // str指向原始字符串
    // const保护原始数据
}

int main() {
    char s[] = "hello";
    
    func1(s); // 看起来是值传递，实际上传递的是指针
    func2(s); // 明确的指针传递
}
```

关键点：

1. C语言中，当数组作为函数参数时，实际上会自动转换为指针

2. strlen(const char* str)中：

   - 传递的是字符串的地址（指针）
   - 不是字符串的副本
   - `const` 的作用是防止通过这个指针修改原始数据

3. ```c
   size_t strlen(const char* str) {
       int len = 0;
       while(str[len] != '\0') {
           // str[len] = 'x';  // 有const，这行会编译错误
           len++;
       }
       return len;
   }
   这样设计的原因：
   
   效率：避免复制整个字符串（特别是长字符串时）
   安全：通过const保护原始数据
   实用：大多数字符串处理函数只需要读取，不需要修改原字符串
   ```

   如果真要做值传递（完整复制），需要手动实现,实际上C语言的数组参数传递都会转换为指针传递，而不是真正的值传递。

   **总结：**

   1. C语言中所有参数传递**本质上都是值传递**
   2. 我们常说的"指针传递"实际上是**传递地址值**
   3. 指针传递之所以能修改原始数据，**是因为通过复制的地址值可以找到原始数据**
   4. 无论是值传递还是指针传递，**形参都是实参的副本**，区别在于：
      - **值传递复制的是数据值**
      - **指针传递复制的是地址值(这个能找到原始数据而已)**

### 指针数组与数组指针

数组指针：【存储类型】 数据类型 （*指针名） 【下标】 = 值

**数组指针（行指针）**: `int (*p)[4]`

数组指针是数组中的指针，抽象概念来看，**一跳就跳一个一维数组（一行）**

```c
#include <stdio.h>

int main(){
	int arr[3][4] = {
		{1, 2, 3, 4},
		{5, 6, 7, 8},
		{9, 10, 11, 12}
	};
	int (*p)[4] = arr;  // p是一个指针，指向大小为4的数组
	//行地址：
	//抽象为数组的数组的话，arr就是外层一维数组的首元素地址：arr[0]
	//printf("%p\n",arr);//00000017fd5ff8b0
	//printf("%p\n",arr[0]);//00000017fd5ff8b0
	//printf("%p",p);//00000017fd5ff8b0
	
	//arr+1:外层一维数组的第二个元素地址：arr[1]
	//p+1:行指针，偏移一行
	//printf("%p\n",arr+1);//00000082389ff680
	//printf("%p\n",arr[1]);//00000082389ff680
	//printf("%p",p+1);//00000082389ff680
	
	//列地址，拿到外层一维数组的首元素地址相当于拿到了内层一位数组的起始地址（首元素地址）
	//printf("%p\n",&arr[0][0]);//000000600bfff8b0
	//p为外层一维数组的首元素地址，解引用一次拿到内层一位数组的起始地址（首元素地址）
	//printf("%p\n",(*p));//000000600bfff8b0
	
	//拿到内层一维数组首元素的值
	//printf("%d\n",arr[0][0]);
	//解引用一次拿到内层一位数组的起始地址（首元素地址）
	//再解引用一次，拿到内层一位数组的起始地址（首元素地址）的值，编译器会+一个int空间取值
	//printf("%d\n",*(*p));
	
	//以此可以通过行指针可以访问行地址（外层一维数组的元素地址）和列地址（内存一维数组的元素地址）
	//外层一维数组的首元素地址，这个地址也是arr[0]中内层一维数组首元素地址
	printf("%p\n",p);//0000008713bffa90
	printf("%p\n",&arr[0][0]);//0000008713bffa90
	//在二维数组中也是同理，把它抽象为数组的数组，存的是指向指针的指针，地址中存着地址
	
	return 0;
}

// 特点：
- "是一个指针"
- 指向一个数组
- "内存中只占用一个指针的空间（通常8字节）"：存放大小为4的数组的起始地址
```

**指针数组**: `int *p[4]`

指针类型的**数组**，**数组里面存的都是指针**

**注意数组指针的定义区别**

```c
int a = 1, b = 2, c = 3, d = 4;
int *p[4] = {&a, &b, &c, &d};  // p是一个数组，每个元素都是指针

// 特点：
- "是一个数组"
- 数组的每个元素都是指针（地址）
- "内存中占用 4个指针的空间（通常32字节）"
```

**从声明上理解区别**：

```c
int (*p)[4];    // 括号先与*结合：p是一个指针，指向一个int[4]数组
int *p[4];      // 方括号先与p结合：p是一个数组，有4个int*类型的元素
```

**使用方式的区别**：

```c
// 数组指针的使用,行指针的使用
int arr[3][4];
int (*p)[4] = arr;
p[0][0];     // 访问第一行第一个元素
(p+1)[0];    // 访问第二行第一个元素

// 指针数组的使用，有一点像二维数组的高度抽象，指向指针的指针
int a=1, b=2, c=3, d=4;
int *p[4] = {&a, &b, &c, &d};
*p[0];       // 访问第一个指针指向的值
*p[1];       // 访问第二个指针指向的值
```

主要区别总结：

1. 本质不同：
   - 数组指针是一个指针
   - 指针数组是一个数组
2. 内存占用：
   - 数组指针占用一个指针的空间
   - 指针数组占用多个指针的空间
3. 用途不同：
   - 数组指针常用于处理二维数组（**行指针偏移**）
   - 指针数组常用于管理多个指针（如字符串数组）
4. 声明解析：
   - `int (*p)[n]`：p是指向n个整型的数组的指针
   - `int *p[n]`：p是有n个整型指针的数组

### 指针数组与二级指针的关系

指针数组并不等同于[二级指针](###二级指针)，虽然它们有一些相似之处。

- 指针数组`int *p[4]`：表示一个包含 4 个元素的数组，每个元素都是指向 `int`类型的指针。简单来说，这是一个“指针的数组”。
  - 例子：`p[0]`, `p[1]` 等元素分别指向不同的 `int` 变量。
- 二级指针：`int **p` 表示**一个**指向指针的指针。它可以用来**指向一个指针数组的首元素**，或者用来**处理指针指向的多维数组**。
  - 例子：`*p` 是一个指针，它指向另一个指针（另一个指针中又指向另一个变量（或者其他数据结构）的首地址。）。

**区别**：

- 指针数组是**多个指针的集合**，而二级指针是一个**指向指针的单一指针**。
- 指针数组可以用来存储多个指针，而二级指针常用于动态管理二维数组或间接访问多个指针。

### 多级指针(就是不存数值）

[二级指针传送门](###二级指针)多级指针确实在一些特定场景下很常用。

- 二级指针最常见的应用场景：

- ```c
  // 场景1: 在函数中修改指针的指向
  void allocateMemory(int** ptr) {
      *ptr = (int*)malloc(sizeof(int));  // 修改指针的指向
      **ptr = 100;                       // 修改指针指向的值
  }
  
  int main() {
      int* p = NULL;
      allocateMemory(&p);  // 传入指针的地址
      printf("%d\n", *p);  // 输出100
      free(p);
      return 0;
  }
  
  // 场景2: 字符串数组的处理
  void sortStrings(char** arr, int n) {
      // arr[i]是字符串的首地址(char*)
      // arr是指向字符串指针的指针(char**)
      for(int i = 0; i < n-1; i++) {
          for(int j = 0; j < n-i-1; j++) {
              if(strcmp(arr[j], arr[j+1]) > 0) {
                  // 交换字符串指针
                  char* temp = arr[j];
                  arr[j] = arr[j+1];
                  arr[j+1] = temp;
              }
          }
      }
  }
  
  int main() {
      char* names[] = {"Tom", "Jerry", "Spike"};
      sortStrings(names, 3);
      // names现在是按字母顺序排序的
  }
  ```

- 三级指针的应用场景：

- ```c
  // 场景: 动态二维数组的创建和管理
  void create2DArray(int*** arr, int rows, int cols) {
      // 分配行指针数组
      *arr = (int**)malloc(rows * sizeof(int*));
      
      // 分配每行的空间
      for(int i = 0; i < rows; i++) {
          (*arr)[i] = (int*)malloc(cols * sizeof(int));
      }
  }
  
  void free2DArray(int*** arr, int rows) {
      // 释放每行
      for(int i = 0; i < rows; i++) {
          free((*arr)[i]);
      }
      // 释放行指针数组
      free(*arr);
      *arr = NULL;  // 避免悬空指针
  }
  
  int main() {
      int** matrix = NULL;
      int rows = 3, cols = 4;
      
      // 创建二维数组
      create2DArray(&matrix, rows, cols);
      
      // 使用二维数组
      matrix[0][0] = 1;
      
      // 释放内存
      free2DArray(&matrix, rows);
      return 0;
  }
  ```

- 实际值的访问方式：

- ```c
  int value = 42;
  int* p = &value;     // 一级指针,
  int** pp = &p;       // 二级指针
  int*** ppp = &pp;    // 三级指针
  
  // 不同方式访问value
  printf("%d\n", value);    // 直接访问
  printf("%d\n", *p);       // 通过一级指针
  printf("%d\n", **pp);     // 通过二级指针
  printf("%d\n", ***ppp);   // 通过三级指针
  ```

  多级指针的使用建议：

  1. 除非必要，尽量不使用超过二级的指针
  2. 二级指针常用于：
     - 需要在函数中修改指针指向时
     - 处理字符串数组或类似的指针数组
  3. 三级指针主要用于：
     - 动态管理二维数组
     - 需要在函数中修改二级指针时

  使用多级指针时的注意事项：

  1. 每一级指针都要正确初始化
  2. 注意内存泄漏，特别是多维数组的释放
  3. 使用前进行NULL检查
  4. 命名要清晰，表明指针的用途

## 小总结(数组与指针)

```c
#include <stdio.h>

int main(){
	
	int arr[3] = {1,2,3};
	//内存中开辟了一个为3个int字节大小的数组，可以通过arr[i]直接访问对应int大小空间中的值
	//printf("%d\n",arr[1]);
	//这其实是语法糖，实际上是通过地址偏移来算的：arr可以表示这块连续int大小空间的首地址
	//有了首地址，根据int类型,可以拿到每一个空间的起始地址进而可以拿到他们的值
//	printf("%p\n",&arr[1]);
//	printf("%p",arr+1);
//	printf("%d",*(arr+1));
	
	
	
	//定义一个一级指针变量把数组的首地址存起来，就可以通过地址间接访问这一些数据了
	//因为定义了指向的数据类型，所以知道首地址是一定能拿到数据的
	int *p1 = arr;
//	int *p2 = &arr;
	//一级指针下两者没有区别
//	printf("%p\n",p1);
//	printf("%p\n",p2);
	//这两个指针变量中存放了这个数组的首地址，同时也是首元素的起始地址
	//通过P1就可以直接访问空间中的值了，这一点跟普通变量没区别，只是空间中存的是地址而已
//	printf("%p\n",p1);
//	printf("%p\n",arr);
	//通过一级指针名拿到空间存放的数组首地址后，也可以使用解引用拿到数组在内存空间中对应的值
//	printf("%d\n",*(p1+1));//两者本质上没有区别
//	printf("%d\n",*(arr+1));
//	//指针本身是在内存中开了一块8字节的空间的
//	printf("%d\n",sizeof(p1));
	
	
	
	//所谓二级指针和多级指针就是俄罗斯套娃了
	//二级指针的空间中存放着一级指针在内存空间中的起始地址
	int **sp = &p1;//跟普通变量一样，变量名p1访问空间中的值，&p1拿到的是空间在内存中的起始地址
	//跟一级指针名一样的机制，通过二级指针名可以访问空间中的值：存的是一级指针在内存空间中的起始地址
//	printf("%p\n",&p1);
//	printf("%p\n",sp);
	//如果知道一级指针的起始地址，那么拿到一级指针空间中的值就不难理解了
	//因为定义二级指针时，定义说明是存的是一个int*类型的指针
	//一级指针首地址+8个字节大小就可以获取一级空间中的值了,解引用就是这样的原理
//	printf("%p\n",*sp);
//	printf("%p\n",arr);
	//那么二级指针就可以“间接地间接”访问数组了，只要有起始地址和数据在内存所占用的大小（数据类型）就可以拿到值
//	printf("%d\n",*(*sp+1));
//	printf("%d\n",*(arr+1));
	
	
	
	int arrPlus[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
	//在内存中开辟了一块空间存放二维数组，占用空间大小为：三个大元素，每一个元素中包含三个小元素都是int类型
	//int字节大小的3X3那么多
	//从定义形式上看就像一个大的int类型的大小为3的一维数组，里面存着三个小的，大小为3的int类型的一维数组
	//此时“数组名”含义很多：二维数组的首元素地址（arrPlus[0]）相当于内层第一个数组的首元素地址
	//还是二维数组在内存空间中的起始地址，通过数组类型还是可以取出他们中的每一个值
	
	//那么通过一级指针把地址存下来，就又可以通过指针间接访问数组中的数据了
	//把arrPlus看成一个大的一维数组，那么arrPlus+1跳的是一个大元素的值（里面有三个小的int数据）
	//从矩阵来看就是跳过了一行，这种称为行指针（地址）
	//虽然说地址本质上没有什么差别，但是类型是决定取值的关键，所以存的是什么类型地地址要匹配和明确
	//int *p3 = arrPlus;
	//[警告] initialization of 'int *' from incompatible pointer type 'int (*)[3]' [-Wincompatible-pointer-types]
	//存的是一个大小为3类型为int的一维数组的地址
	int (*p3)[3] = arrPlus;
	//下次p3指针+1时就会跳过一个一个大小为3类型为int的一维数组的地址
//	printf("%p\n",p3+1);
//	printf("%p\n",arrPlus+1);
//	printf("%p\n",arrPlus[1]);
	//那么通过这个p3指针也可以访问这个二维数组了
	//可以看成大的一维数组中每一个元素存的都是大小为3的int类型的一维数组的起始地址
	//有地址和类型就可以拿到数据,光靠地址是无法拿到值的，需要解引用（通过类型）
//	printf("%d\n",*(*p3));
//	printf("%d\n",*(*(p3+1)));
	
	//如果想存二维数组的首地址，上一个是二位数组的行地址
}
```

### 二维数组的访问方式和作为函数参数的传递方法

[传送门](####传递二维数组（重点且比较复杂）)

通过数组名和下标直接访问:

```c
int arr[3][4];
// 直接访问
arr[i][j] = 5; // i是行号,j是列号
```

通过指针偏移访问:

```c
int arr[3][4];
// 通过指针访问
*(*(arr + i) + j) = 5;  // 等价于 arr[i][j] = 5
// 或者使用一维数组方式
*(arr[0] + i*4 + j) = 5;  // 4是列数
```

作为函数参数的定义和传递方式:

```c
// 方式1:指定列数
// 这些定义都是等价的
void func1(int arr[][4], int rows);     // 行数省略
void func1(int arr[3][4], int rows);    // 写明行数
void func1(int arr[50][4], int rows);   // 即使写错行数也没关系
void func1(int arr[][4], int rows) {
    // 使用arr[i][j]访问
}

// 方式2:指针数组
void func2(int (*arr)[4], int rows);    // 数组指针，指向含4个int的数组
// arr的类型是 int (*)[4]，是一个指向"包含4个整数的数组"的指针
// 每次+1，会跳过4个int的大小

// 举例说明：
int (*p)[4] = arr;  // p是行指针，指向第一行
p++;                // p指向第二行
(*p)[2] = 5;        // 修改第二行第三个元素


// 方式3:一维数组指针(需要手动计算偏移)
// 方法3确实存在类型不匹配问题
int main() {
	int arr[3][4];
	
	// 以下几种方式都可以，但都需要类型转换
	func3((int*)arr, 3, 4);          // 强制类型转换整个数组
	func3(&arr[0][0], 3, 4);         // 取第一个元素的地址
	func3(*arr, 3, 4);               // 数组名解引用，行地址变成列地址，就是匹配类型了
	
	// 直接传递是错误的
	//func3(arr, 3, 4);                // 错误！类型不兼容
}
void func3(int* arr, int rows, int cols) {
	// 访问 arr[i][j] 的等价写法
	*(arr + i*cols + j) = 5;
	
	// 如果想使用二维数组的形式访问，可以这样做
	int (*p)[4] = (int(*)[4])arr;
	p[i][j] = 5;
}
```

关键注意点：

1. 作为参数传递时，必须指定列数(第二维)

   1. **你说得对，行数可以省略或随意写，但列数必须明确指定。因为编译器需要知道一行有多少元素才能正确计算偏移量。** 有几列就知道了一行有多少元素，这样无论是列偏移还是行偏移都有依据。

2. 指针方式访问时要注意地址计算

   1. 这是一个行指针（数组指针）。它指向的是"包含4个int的数组"。

3. 一维数组方式需要手动计算正确的偏移量

   1. 存在类型不匹配的问题：
      - arr的类型是 `int (*)[4]`（数组指针）
      - 而func3期望的参数类型是 `int*`（整型指针）
      - 所以在传递时需要进行类型转换
   2. 这也是为什么方法3不太推荐使用的原因之一：
      1. 需要手动类型转换
      2. 需要手动计算偏移量
      3. 代码可读性差
      4. 容易出错
   3. 但知道一个地址，只知道一个基础元素的类型，所有的位置都要手动计算。

4. 实际使用时建议用第一种方式，代码更直观易读

   1. 推荐的两种方式：

   2. ```c
      // 方式1：直接用二维数组（最直观）
      void func1(int arr[][4], int rows) {
          arr[1][2] = 5;  // 直观易懂
      }
      
      // 方式2：数组指针（灵活，支持指针运算）
      void func2(int (*arr)[4], int rows) {
          arr[1][2] = 5;      // 可以像数组一样使用
          (*(arr+1))[2] = 5;  // 也可以用指针运算
      }
      ```

5. 关于二级指针接收二维数组:

   1. ```c
      int arr[3][4];
      int **p = arr;    // 错误！类型不匹配
      
      void func(int **p, int rows, int cols) {
          // 这样是不行的！
      }
      
      // 原因解释：
      // arr是数组指针 int (*)[4]
      // **p是指针的指针，需要这样的内存布局：
      int *p1, *p2, *p3;
      int **p = malloc(sizeof(int*) * 3);
      p[0] = p1;
      p[1] = p2;
      p[2] = p3;
      ```

   2. 二级指针和二维数组的内存布局是不同的：

      1. 二维数组是连续的内存块

      2. ```c
         // 二维数组的内存布局（连续的）
         int arr[3][4] = {
             {1, 2, 3, 4},    // arr[0]连续存储
             {5, 6, 7, 8},    // arr[1]紧随其后
             {9, 10, 11, 12}  // arr[2]紧随其后
         };
         ```

      3. 二级指针通常是不连续的内存块

      4. ```c
         // 二级指针的内存布局（可能分散的）
         int **p;
         p[0] -> {1, 2, 3, 4}    // 可能在任意位置
         p[1] -> {5, 6, 7, 8}    // 可能在任意位置
         p[2] -> {9, 10, 11, 12} // 可能在任意位置
         ```

   3. 如果确实需要使用二级指针管理二维数组，正确的方式是动态分配：

      1. ```c
         // 动态创建二维数组
         int **create_2d_array(int rows, int cols) {
             int **arr = (int**)malloc(rows * sizeof(int*));
             for(int i = 0; i < rows; i++) {
                 arr[i] = (int*)malloc(cols * sizeof(int));
             }
             return arr;
         }
         
         // 使用
         int **arr = create_2d_array(3, 4);
         arr[1][2] = 5;
         
         // 记得释放内存
         void free_2d_array(int **arr, int rows) {
             for(int i = 0; i < rows; i++) {
                 free(arr[i]);
             }
             free(arr);
         }
         ```

6. 所以总结一下：

   1. 对于普通的二维数组操作，用第一种方式最简单直观（**直接传递原始数组**）
   2. 如果需要指针运算，用第二种方式（数组指针）行指针
   3. 如果需要动态创建二维数组，则使用动态分配的二级指针方式
   4. 不要试图用二级指针直接接收二维数组，这是类型不匹配的

### 二维数组与解引用

**二维数组名的含义:**

1. 数组名 `arr`

   - 代表**二维数组首行**的地址

   - 类型是 `int (*)[3]` (指向含3个int元素的数组的指针)

   - 步长是一行的大小(3 * sizeof(int))

2. `&arr`

   - **代表整个二维数组的地址**

   - 类型是 `int (*)[3][3]` (指向3×3二维数组的指针)

   - 步长是整个数组的大小(9 * sizeof(int))

3. ```c
   int arr[3][3] = {
       {1, 2, 3},
       {4, 5, 6},
       {7, 8, 9}
   };
   
   printf("%p\n", arr);     // 假设输出 0x100
   printf("%p\n", &arr);    // 也是 0x100，地址值相同
   
   // 但是步长不同
   printf("%p\n", arr + 1);     // 0x100 + sizeof(int) * 3
   printf("%p\n", &arr + 1);    // 0x100 + sizeof(int) * 9
   
   // 在函数声明时的区别
   void func1(int (*arr)[3]) { ... }     // 接收 arr
   void func2(int (*arr)[3][3]) { ... }  // 接收 &arr
   ```

   这个区别在实际编程中很重要：

   1. 传参时需要注意函数参数的正确声明
   2. 指针运算时步长不同会影响结果
   3. 在多维数组的深层访问时需要正确理解类型转换

   所以虽然 `arr` 和 `&arr` 的值相同，但它们的类型和行为是不同的。这也是C语言中数组和指针关系的一个重要体现。

   

**那么基于此种语境下，理解arr行指针的解引用就容易了。 把二维数组看成大数组里面存着小数组的起始地址，那么arr+i可以拿到大数组每一个元素的起始地址，解引用一次,*(arr+i)就可以能得到对应位置里面小数组的起始地址， 那么再解引用一次：*(*(arr+i)+j),就可以拿到小数组中的元素值了，也就是i行j列元素了**。

`arr+i`

- 在外层大数组中移动i个位置
- 每次移动的步长是一行的大小(3*sizeof(int))
- 得到第i行的地址

`*(arr+i)` 或 `arr[i]`

- 解引用得到第i行这个小数组的首地址
- 相当于一个一维数组的首地址

`*(arr+i)+j` 或 `arr[i]+j`

- 在这个小数组(第i行)中向后移动j个位置
- 步长是sizeof(int)
- 得到第i行第j列元素的地址

`*(*(arr+i)+j)` 或 `arr[i][j]`

- 再次解引用得到实际的元素值

```c
int arr[3][3] = {
		{1, 2, 3},
		{4, 5, 6},
		{7, 8, 9}
	};
	
// 以下几种写法等价
	int elem1 = arr[1][2];           // 常用下标方式
	int elem2 = *(*(arr+1)+2);       // 完全解引用方式
	int elem3 = *(arr[1]+2);         // 混合方式
	
	printf("%d\n", elem1);           // 输出6 (第1行第2列的元素)
	printf("%d\n", elem2); 
	printf("%d\n", elem3); 
```

这种理解方式不仅帮助我们：

1. 更好地理解数组和指针的关系
2. 理解为什么arr[i][j]和*(*(arr+i)+j)是等价的
3. 在处理多维数组时能更灵活地使用指针运算
4. 编写处理二维数组的函数时能更好地设计参数类型

这也是为什么C语言中说"数组名退化为指针"的一个很好的例证。

**如果拿到的是行指针，移动的步长是一行。 解引用一次得到列地址，移动的步长是一个元素的距离。 再解引用一次拿到列地址中存储的值。**

### 改变一级指针中存的地址，函数形参的定义

因为C语言是本质上是值传递，所以函数中拿到的都是原值的副本，这就导致修改影响不了原值。 如：我在函数形参定义中使用一级指针接收一个一级指针地址，那么我**修改指针中存的地址中的值**是可以影响原值的，因为我是根据内存地址去修改的。但是我想要**修改指针中的值即修改指针指向**却是不行的？

```c
void test1(int* p) {    // 一级指针接收地址
    *p = 20;            // 可以改变地址中的值
    p = NULL;           // 改变的是形参p的指向，不影响实参
}

void test2(int** pp) {  // 二级指针接收一级指针的地址
    *pp = NULL;         // 可以改变原一级指针的指向
}

int main() {
    int a = 10;
    int* p = &a;
    
    // 情况1：修改指针指向的值(指针存的地址中对应的值)
    printf("修改前：%d\n", *p);  // 输出10
    test1(p);
    printf("修改后：%d\n", *p);  // 输出20
    printf("p指向：%p\n", p);    // p的指向未变
    
    // 情况2：修改指针的指向
    test2(&p);
    printf("p现在指向：%p\n", p); // p变为NULL
}
```

这里的关键点是：

1. 一级指针作为形参时：
   - 能修改指针指向的内容（通过解引用）
   - 不能修改指针的指向（因为形参是实参的拷贝）
2. 要修改一级指针的指向，需要：
   - 使用二级指针作为形参
   - 传入一级指针的地址
   - 通过解引用修改一级指针的值

## 函数

### 函数的定义

返回值数据类型 函数名  （【数据类型  形式参数名，数据类型  形式参数名，……】）

定义的形参在函数调用完后会释放。

在C语言中，主调函数与被调函数的位置关系以及声明确实有一些重要的注意事项。

```c
// 1. 被调函数在主调函数之前 - 直接可用
int add(int a, int b) {
    return a + b;
}

int main() {    // 主调函数
    int sum = add(1, 2);  // 正常调用
    return 0;
}

// 2. 被调函数在主调函数之后 - 需要前向声明
int main() {    // 主调函数
    int sum = add(1, 2);  // 错误！除非前面有声明
    return 0;
}

int add(int a, int b) {  // 被调函数
    return a + b;
}
```

正确的做法 - 使用函数原型声明：

```c
// 方式1：在文件开头声明
int add(int a, int b);    // 函数原型声明（注意分号）

int main() {
    int sum = add(1, 2);  // 现在可以使用了
    return 0;
}

int add(int a, int b) {   // 函数定义
    return a + b;
}

// 方式2：使用头文件（函数声明和定义都分开了，程序入口用include包含就可以）
// mymath.h
#ifndef MYMATH_H
#define MYMATH_H

int add(int a, int b);    // 函数声明
int subtract(int a, int b);

#endif

// mymath.c
#include "mymath.h"

int add(int a, int b) {   // 函数定义
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

// main.c
#include "mymath.h"

int main() {
    int sum = add(1, 2);
    return 0;
}
```

函数声明的注意事项：

```c
// 1. 参数名可以省略，但类型必须保留
int add(int, int);         // 合法
int add(int x, int y);     // 合法
int add();                 // 错误！与定义不符

// 2. 返回类型必须一致
int add(int a, int b);     // 声明
double add(int a, int b)   // 错误！返回类型不一致
{
    return a + b;
}

// 3. static函数只在当前文件可见
static int helper(int x);   // 其他文件不能调用

// 4. 同一个函数不能重复定义，但可以重复声明
int add(int a, int b);     // 第一次声明
int add(int x, int y);     // 重复声明，合法
```

多文件项目的组织：

```c
// 1. 头文件 operations.h
#ifndef OPERATIONS_H
#define OPERATIONS_H

// 函数声明
int add(int a, int b);
int subtract(int a, int b);
void printResult(int result);

#endif

// 2. 实现文件 operations.c
#include "operations.h"
#include <stdio.h>

// 函数定义
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

void printResult(int result) {
    printf("Result: %d\n", result);
}

// 3. 主程序文件 main.c
#include "operations.h"

int main() {
    int result = add(10, 5);
    printResult(result);
    return 0;
}
```

常见错误及解决：

```c
// 错误1：没有声明就使用
int main() {
    foo();      // 错误！未声明就使用
}
void foo() { }

// 解决：添加声明
void foo();    // 声明
int main() {
    foo();     // 现在正确了
}
void foo() { }

// 错误2：声明和定义不匹配
int calc(int);     // 声明一个参数
int calc(int, int) // 错误！定义与声明不匹配
{
    return 0;
}

// 错误3：头文件没有防止重复包含
// 解决：使用include guard
#ifndef HEADER_H
#define HEADER_H
// 头文件内容
#endif
```

最佳实践建议：

1. 把函数声明放在头文件中
2. 把函数定义放在源文件中
3. 使用include guard防止头文件重复包含
4. 保持声明和定义的一致性
5. 在头文件中仅包含必要的声明
6. 函数声明时注意参数类型的完整性

这样组织代码的好处：

- 提高代码可维护性
- 便于团队协作
- 减少编译错误
- 提高代码重用性

### 函数的传参方式

[值传递和指针传递传送门](####值传递和指针传递)

值传递和地址传递的区别：

```c
// 1. 值传递版本的swap - 无法完成交换
void swap_value(int x, int y) {
    int temp = x;     // temp = 1
    x = y;           // x = 2
    y = temp;        // y = 1
    // 交换的是副本，原始值不受影响
}

// 2. 指针传递版本的swap - 可以完成交换
void swap_pointer(int* px, int* py) {
    int temp = *px;    // temp = 1
    *px = *py;        // *px = 2
    *py = temp;       // *py = 1
    // 通过地址修改原始值
    //地址是副本但是地址是真的啊！
}

int main() {
    int a = 1, b = 2;
    printf("交换前：a = %d, b = %d\n", a, b);

    // 值传递尝试交换
    swap_value(a, b);
    printf("值传递后：a = %d, b = %d\n", a, b);  // a=1, b=2 没变

    // 指针传递尝试交换
    swap_pointer(&a, &b);
    printf("指针传递后：a = %d, b = %d\n", a, b);  // a=2, b=1 成功交换
    
    return 0;
}
```

区别说明：

1. 值传递版本失败原因：

- swap_value函数得到的x和y是a和b的副本
- 在函数内部交换x和y不影响原始的a和b
- 函数结束后，修改的副本被销毁

1. 指针传递版本成功原因：

- swap_pointer函数得到的是a和b的地址
- **通过地址可以访问并修改原始变量**
- 函数结束后，原始值已经被交换

这个swap函数的例子很好地说明了：

- 值传递只能操作副本，无法修改原值
- **指针传递虽然指针本身是副本**(复制了一份地址)，但可以通过地址修改原值

### 函数的调用

#### 嵌套调用

为了程序的高复用性，一般一个功能都用一个函数实现，那么大函数可能由多个小功能汇合而成，所以很容易形成嵌套调用的情况

#### 递归调用

一个函数直接或者间接的嵌套自身，相当于嵌套的特例。面试常考，生产环境用的很谨慎。

```c
#include <stdio.h>

// 递归函数：计算斐波那契数列的第n个数
int fibonacci(int n) {
    // 1. 基本情况（递归终止条件）递归出口
    if (n <= 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // 2. 递归情况：F(n) = F(n-1) + F(n-2)
    return fibonacci(n-1) + fibonacci(n-2);
}

int main() {
    int n = 7;
    printf("计算斐波那契数列的前 %d 个数：\n", n);
    
    for (int i = 0; i < n; i++) {
        printf("F(%d) = %d\n", i, fibonacci(i));
    }
    
    return 0;
}
```

递归函数的几个重要注意点：

**递归终止条件**：

- 这是最重要的部分，每个递归函数必须有明确的终止条件
- 在这个例子中，当 n <= 0 或 n == 1 时会返回具体值

**递归步骤**：

- 每次递归调用都会把问题变得更小
- fibonacci(n) 被分解为 fibonacci(n-1) 和 fibonacci(n-2)

**调用栈**：

- **每次递归调用都会占用新的栈空间**
- **如果递归层次太深，可能会导致栈溢出**
- 比如计算 fibonacci(50) 就会非常慢，因为会有大量重复计算
- 递归本身并不一定导致重复计算，问题的特性才是决定是否有重复计算的关键。
- **是否出现大量重复计算** 取决于递归的结构。如果递归的每一步都调用了相同的子问题，并且这些子问题没有缓存，那么重复计算就会发生。



### 函数与数组（指针形式和原始数组形式）

在C语言中，数组作为函数参数时有一些特殊的注意事项。数组与普通变量传参方式不同，以下是总结与用例说明：

**数组传参时的注意事项**

1. **数组名作为指针传递**： 当数组作为参数传递给函数时，实际上传递的是指向数组首元素的指针（地址），而不是整个数组的副本。也就是说，函数对数组元素的修改会影响到原数组（相当于地址传递了）。
   1. **会自动退化为指针，那么直接传递原数组修改能影响也就不奇怪了。**
   2. 所以直接传递原始数组什么不好，直观又简单

2. **数组大小信息不会自动传递**： 由于数组名仅仅是指针，**函数无法通过数组参数本身知道数组的大小**。因此，如果函数需要知道数组的大小，通常需要显式地传递数组的长度。（仅仅把数组名传过去，用sizeof也只是指针的大小8个字节）
3. **数组作为函数参数的声明**： 虽然函数的参数列表中可以**写作 `int arr[]`，但它本质上与 `int *arr` 是等价的**。它们都表示传递的是指针。（数组名本身就是首元素起始地址）
   1. 二维数组必须要写明列数，行数可以省略。因为不知道一行有几个元素的话，偏移会有问题。

4. **数组传递的是地址**： 由于传递的是指针，因此对数组元素的修改会直接反映到调用函数的实际数组上。这与传递普通变量不同，普通变量在函数中传递的是值的副本，不会影响原变量。

#### 传递一维数组

```c
#include <stdio.h>

// 方式1：传统数组形式（其实会自动转为指针），因为数组名就是首元素起始地址嘛
void method1(int arr[], int size) {
    printf("方式1中数组大小: %lu\n", sizeof(arr));  // 将输出指针的大小，按照前面的结论是没办法看到数组的大小的
    for(int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// 方式2：指针形式
void method2(int* arr, int size) {
    for(int i = 0; i < size; i++) {
        printf("%d ", *(arr + i));  // 使用指针算术
    }
    printf("\n");
}

// 展示数组作为参数时的特性，这里有函数调用的嵌套
void demonstrateArrayProperties(void) {
    int original[5] = {1, 2, 3, 4, 5};
    
    printf("在main函数中数组大小: %lu\n", sizeof(original));  // 将输出数组实际大小
    
    method1(original, 5);
    method2(original, 5);
}

// 常见实际应用：数组元素求和
int arraySum(int* arr, int size) {
    int sum = 0;
    for(int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}

// 常见实际应用：原地修改数组元素，想要修改数组元素的话，必须是指针传递
void doubleElements(int* arr, int size) {
    for(int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    
    printf("原始数组: ");
    for(int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n\n");
    
    printf("=== 数组属性演示 ===\n");
    demonstrateArrayProperties();
    printf("\n");
    
    printf("=== 实际应用示例 ===\n");
    printf("数组元素和: %d\n", arraySum(arr, 5));
    
    doubleElements(arr, 5);
    printf("将所有元素翻倍后: ");
    for(int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```

- 数组形式传参

- ```c
  void function(int arr[], int size)
  ```

- 特点：

  - 看起来是数组，但实际上编译器会自动转换为指针
  - 无法通过 sizeof(arr) 获取数组实际大小
  - 更直观，容易理解

  使用场景：

  - 当你想明确表示这是一个数组时
  - 代码可读性要求高的场合

- 指针形式传参

- ```c
  void function(int* arr, int size)
  ```

- 特点：

  - 直接表明这是一个指针
  - 功能上与数组形式完全相同
  - 可以使用指针算术运算（可以修改原始值）

  - 使用场景：
    - 需要强调指针操作的场合
    - 需要进行指针运算的场合

- 重要注意点：

  1. 数组退化

     - 无论使用哪种方式，一维数组作为参数传递时都会退化为指针
     - 在函数内部无法获知原数组的实际大小
     - **传递整个数组会导致大量数据复制，而传递指针只需要复制一个地址。**
     - **必须额外传递数组大小参数**。如果要使用的话

  2. **最佳实践**

     - 总是传递数组大小作为参数

     - 在函数内进行边界检查

     - 如果数组不会被修改，考虑添加 const 限定符

     - ```c
       void readOnlyFunction(const int* arr, int size);
       ```

  3. **选择建议**

     - 如果主要进行数组索引操作，使用数组形式（`int arr[]`）
     - 如果需要指针运算，使用指针形式（`int* arr`）
     - 如果数据不应被修改，使用 const 指针形式（`const int* arr`）

#### 传递二维数组（重点且比较复杂）

```c
#include <stdio.h>
#include <stdlib.h>

// 方式1：指定数组大小（列数必须明确指定）
void method1(int arr[3][4], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

// 方式2：行可变，列固定的数组指针(这不就是行指针嘛？)
void method2(int (*arr)[4], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

// 方式3：使用双指针（完全动态的二维数组）行和列都是动态的没有固定，自由度高
//二维数组不能使用二级指针接收，类型不匹配
void method3(int **arr, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

// 方式4：将二维数组当作一维数组处理，不过自己手动计算偏移值
void method4(int *arr, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i * cols + j]);
        }
        printf("\n");
    }
}

int main() {
    // 1. 静态声明的二维数组
    int array1[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    // 2. 动态分配的二维数组（使用双指针）比较麻烦
    int **array2 = (int **)malloc(3 * sizeof(int *));
    for (int i = 0; i < 3; i++) {
        array2[i] = (int *)malloc(4 * sizeof(int));
        for (int j = 0; j < 4; j++) {
            array2[i][j] = i * 4 + j + 1;
        }
    }

    printf("方式1 - 指定大小的数组：\n");
    method1(array1, 3, 4);
    
    printf("\n方式2 - 数组指针：\n");
    method2(array1, 3, 4);
    
    printf("\n方式3 - 双指针：\n");
    method3(array2, 3, 4);
    
    printf("\n方式4 - 一维数组形式：\n");
    method4((int *)array1, 3, 4);

    // 释放动态分配的内存
    for (int i = 0; i < 3; i++) {
        free(array2[i]);
    }
    free(array2);

    return 0;
}
```

让我们详细分析每种传参方式的特点和使用场景：

**方式1：指定数组大小**

- 语法：`void function(int arr[3][4], int rows, int cols)`
- 特点：
  - 需要明确指定列数
  - 最接近原始二维数组的使用方式
  - 代码直观，易于理解
- 适用场景：
  - 处理固定大小的二维数组
  - 列数确定的情况

**方式2：数组指针**

- 语法：`void function(int (*arr)[4], int rows, int cols)`
- 特点：
  - 行数可以变化，列数必须固定
  - 内存连续，访问效率高
- 适用场景：
  - 需要处理不同行数但列数固定的数组
  - 对内存性能要求较高的场景

**方式3：双指针(重点)**

- 语法：`void function(int **arr, int rows, int cols)`
- 特点：
  - 完全灵活的行数和列数
  - 可以处理动态分配的二维数组
  - 内存不一定连续
- 适用场景：
  - 处理动态分配的二维数组
  - 需要在运行时确定数组大小
  - 需要不规则的二维数组（每行列数可能不同）

**方式4：一维数组** 

- 语法：`void function(int *arr, int rows, int cols)`
- 特点：
  - 将二维数组当作一维数组处理
  - 内存连续，访问效率最高
  - 需要手动计算下标
- 适用场景：
  - 追求最高的性能
  - 进行矩阵运算等需要频繁访问数组元素的场景
- 公式的推导过程：

**内存布局原理**：

- C语言中，二维数组在内存中实际上是按行主序连续存储的
- 例如一个3×4的数组实际是连续的12个元素

**下标转换推导**： 假设有一个数组 `arr[3][4]`：

```c
第0行: arr[0][0] arr[0][1] arr[0][2] arr[0][3]  // 内存位置：0,1,2,3
第1行: arr[1][0] arr[1][1] arr[1][2] arr[1][3]  // 内存位置：4,5,6,7
第2行: arr[2][0] arr[2][1] arr[2][2] arr[2][3]  // 内存位置：8,9,10,11
```

**公式解析**：`index = i * cols + j`

`i`：当前行号

`cols`：总列数

`j`：当前列号

**计算示例**：

- 访问 arr[1] [2]时：因为是按行线性存储的，按存储位置抽象成一维数组的话， `arr[1][2]`相当于是第二行第三个元素，它前面一共有多少个元素呢？（下标从0开始）：前面有一行（4个元素），自己这一行是第三个元素，相当于一维数组的第七个元素也就是下标6
  - i = 1, cols = 4, j = 2
  - index = 1 * 4 + 2 = 6
  - 所以 `arr[1][2]` 等价于一维数组的 `arr[6]`

**一些重要注意点：**

1. 在选择传参方式时，需要考虑：
   - 数组大小是否固定
   - 是否需要动态分配
   - 性能要求
   - 代码可读性要求
2. 内存管理：
   - 使用动态分配（方式3）时，记得及时释放内存
   - 注意避免内存泄漏和数组越界
3. 性能考虑：
   - 方式4（一维数组）通常性能最好
   - 方式3（双指针）由于内存不连续，可能性能较差

#### 传递字符数组

```c
#include <stdio.h>
#include <stdlib.h>

char *mystrcpy(char *dest,const char *src){
	//从右向左看*在const的右边：不能通过指针修改值，但可以改变指针指向
	//这个做法就是要保证不改变原字符串
	char *ret = dest;//指针传递起始地址在下面会变所以那个临时变量存一下
	if(dest != NULL && src != NULL);//对传进来的参数进行校验,定义时指针是带*的，使用时直接用变量名
		while((*dest++ = *src++)!='\0');//依次把地址中的值取出来赋值给对应的地址中的位置，地址向后移动
	return ret;
	
}

char *mystrncpy(char *dest,const char *src,size_t n){
	int i;
	//数组名和一级指针是等价的
	for(i=0;i<n && (dest[i] = src[i]);i++);
	//自己补充结束符
	dest[i] = '\0';
	return dest;
}

int main(){
	char str1[] = "helloworld";
	char str2[128];
	//mystrcpy(str2,str1);
	//puts(str2);
	mystrncpy(str2,str1,5);
	puts(str2);
	exit(0);
}
```

#### 函数形参传递数组的值可以修改吗？

**数组元素之间交换需求：**

```c
swap(arr[1],arr[2]);
void swap(int a,int b){
	int temp = 0;
	temp = a;
	a = b;
	b = temp;
}
```

**这可以实现数据的交换吗？函数是值传递的，传递的是副本啊？我不应该传递他们的地址吗？**

你的理解是正确的。C 语言中的函数参数是**值传递**的，这意味着函数 `swap` 中的 `a` 和 `b` 是 `arr[1]` 和 `arr[2]` 的**副本**，在函数内部交换值并不会影响到原数组。

**问题解释：**

1. **值传递：** 当你调用 `swap(arr[1], arr[2])` 时，`arr[1]` 和 `arr[2]` 的值被复制到 `swap` 函数的参数 `a` 和 `b`。
2. **在函数内部：** `swap` 函数交换了 `a` 和 `b` 的值，但这些操作只在函数的局部作用域生效，**不会改变数组 `arr` 中的值**。

为了在函数中交换数组元素的值，你需要传递它们的**地址**。可以通过指针来实现。

```c
void swap(int *a, int *b) {
    int temp = 0;
    temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int arr[] = {1, 2, 3, 4};
    swap(&arr[1], &arr[2]);  // 传递地址
    printf("%d %d\n", arr[1], arr[2]);  // 输出：3 2
    return 0;
}
```

关键点：

- `&arr[1]` 和 `&arr[2]` 是 `arr[1]` 和 `arr[2]` 的地址。
- `swap` 函数中的 `*a` 和 `*b` 解引用了指针，从而修改了数组中的值。

**如果我还是坚持用arr[1] 和 arr[2] 的值传递的话，不能改变原数组，但是我可以存档到新数组中吗？**

是的，虽然值传递无法直接改变原数组，但你可以在函数内部将交换后的值存储到一个新数组中，并通过返回值将其带回。以下是实现的方法：

**方法：将结果存储到新数组中**

1. 函数交换后，将结果存入新数组。
2. 返回新数组或将其内容复制到主函数中。

```c
#include <stdio.h>

void swapAndStore(int a, int b, int newArr[]) {
	newArr[0] = b;  // 交换后的值存入新数组
	newArr[1] = a;
}

int main() {
	int arr[] = {1, 2, 3, 4};
	int result[2];  // 用于存储交换后的值
	
	swapAndStore(arr[0], arr[3], result);  // 传递值，将结果存入新数组
	
	printf("Original: %d %d\n", arr[0], arr[3]);  // 输出：1 4
	printf("Swapped: %d %d\n", result[0], result[1]);  // 输出：4 1
	
	return 0;
}
```

**实际应用：**为了实现翻转，你可以创建一个新数组来存储翻转后的结果,**一定要用数组值来传递的话**

```c
#include <stdio.h>

void reverseArray(int original[], int newArr[], int size);

int main() {
    int arr[] = {10, 40, 67, 4, 8, 29, 3};
    int size = sizeof(arr) / sizeof(arr[0]);
    int reversed[size];  // 用于存储翻转后的数组

    reverseArray(arr, reversed, size);  // 翻转数组

    // 遍历并输出翻转后的数组
    for (int i = 0; i < size; i++) {
        printf("倒叙遍历：%d\n", reversed[i]);
    }

    return 0;
}

void reverseArray(int original[], int newArr[], int size) {
    for (int i = 0; i < size; i++) {
        newArr[i] = original[size - 1 - i];  // 将原数组的元素倒序存入新数组
    }
}
```

### 函数与指针

#### 指针函数(函数的返回值是指针)

返回值  *  函数名  （形参）；

```c
#include <stdio.h>
#include <stdlib.h>

// 定义一个指针函数
int* createNumber(int value) {
    int* ptr = (int*)malloc(sizeof(int));  // 分配一个int大小的内存起始地址
    *ptr = value;  // 将值存储在分配的内存中，把值存放到地址中
    return ptr;  // 返回指向这个值的指针，返回值在内存中的存放地址即指针指向的地址（指针里的值）
}

int main() {
    int* result = createNumber(42);
    printf("在内存中的地址是: %p\n", result);
    printf("创建的数字是: %d\n", *result);
    free(result);  // 释放内存
    return 0;
}
```



#### 函数指针（重点）

- 函数指针是一种**指向函数的指针**。它**存储函数的地址**，允许我们**间接地调用函数**。

- 在**C语言**中，**函数名本质上就是指向该函数的地址**。因此，你可以将函数名赋值给**函数指针**，并通过该指针来调用函数。这是一种非常强大的功能，广泛用于**回调函数和动态函数调用。**

函数指针的定义：**返回类型 (*指针名)(参数列表);** `int (*pFunc)(int, int);`

这定义了一个名为 pFunc 的函数指针，它指向一个接受两个 int 参数并返回 int 的函数。

```c
#include <stdio.h>

// 两个简单的函数
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }

int main() {
	// 声明一个函数指针，这个变量是指针，存放返回值类型为int,形参类型为两个int的函数的地址
	int (*operation)(int, int);
	
	// 使用函数指针调用函数(间接调用)，
	operation = add;//把函数的地址赋给指针
	//使用指针间接调用函数
	printf("10 + 5 = %d\n", operation(10, 5));
	
	operation = subtract;
	printf("10 - 5 = %d\n", operation(10, 5));
	
	return 0;
}
```

函数名确实可以看作是函数起始地址的别名。这种特性在涉及函数指针时尤其重要。

**函数名作为地址**：

- 在表达式中，函数名（如`func`）会被解释为指向函数的指针，等价于`&func`。

- ```c
  void func() {
      printf("Hello, world!\n");
  }
  
  void (*fp)() = func;  // 等价于 void (*fp)() = &func;
  fp();  // 调用函数
  
  ```

**使用函数指针**:

- 函数指针用于存储函数的地址，可以通过它调用对应的函数。
- 函数名本身不带括号时，即表示函数的地址。

**[区别于数组的情况](####函数名与数组名的区别)**:

- 类似于数组名是数组起始地址，函数名是函数起始地址。
- **但与数组不同的是，函数名不能用来进行指针算术（例如`func + 1`是非法的），因为函数地址没有定义的“元素大小”。**

**函数指针的作用**

- **动态回调**：在运行时根据需求选择调用不同的函数。
- **高阶函数**：将函数作为参数传递，例如`qsort`使用函数指针作为比较器。
- **事件驱动模型**：回调函数用于处理特定事件。

##### 接口函数实例

```c
#include <stdio.h>

// 两个简单的函数
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }

void test(int (*p)(int,int)){
	//通过指针调用函数
	//通过指针（地址）传递进来那个函数就调用那个函数
	int res = p(3,4);
	printf("%d\n",res);
}

int main() {
	//函数指针，使用的是地址
	test(add);
	test(subtract);
	return 0;
}
```



#### 函数名与数组名的区别

**函数名和数组名在 C 语言中的行为非常相似**，它们本质上都代表**内存地址**，不过也有一些细微的区别。

**函数名和数组名的相似性**

1. **都代表地址：**

   - **数组名**表示数组的首地址，即第一个元素的地址。

   - **函数名**表示该函数的入口地址。

   - ```c
     int arr[3] = {1, 2, 3};
     int *p = arr;  // 数组名是首地址
     
     void say_hello();
     void (*func_ptr)() = say_hello;  // 函数名是地址
     ```

2. **都可以用作指针赋值：**

   - 数组名可以赋值给**指向数组元素的指针**。
   - 函数名可以赋值给**函数指针**。

   **访问方式：**

   - 对于数组，你可以使用指针访问元素，如 `*(arr + 1)`。
   - 对于函数，你可以使用函数指针来j间接调用，如 `func_ptr()`。

**函数名和数组名的区别**

1. **数组名是一个常量指针，但函数名不是**：

   - 虽然数组名是**首地址**，但它**不可更改**，无法赋值给其他指针。

   - 函数名虽然表示地址，但你可以自由将其赋值给不同的**函数指针**。

   - ```c
     int arr[3] = {1, 2, 3};
     arr = arr + 1;  // 错误，数组名是常量，常量不能出现在赋值的左边
     
     void say_hello();
     void (*func_ptr)() = say_hello;  // 合法，函数名可以赋值给指针
     ```

2. **数组可以按索引访问，但函数不行：**

   - 数组可以通过 `arr[i]` 的方式访问元素。
   - 函数只能通过函数指针调用，如 `func_ptr()`，不支持按索引访问。

   **存储位置不同**：

   - **数组**的数据存储在内存的**数据段**或**堆栈**中。
   - **函数**的代码存储在**代码段**中。

#### 函数指针数组

- 函数指针数组的定义格式如下:

```c
返回类型 (*数组名[数组大小])(参数列表);
int (*func_ptr_arr[5])(int, int);
```

这定义了一个包含5个函数指针的数组,每个函数指针指向一个接受两个int参数并返回int的函数。

- 函数指针数组在以下场景中特别有用:

a) 实现函数分发表或命令模式: 当您有**多个相似的函数**,并且**需要根据某些条件选择其中一个执行时**。(不用写那么多，if,else语句，不用写switch,case语句)

b) 回调函数数组: 在事件驱动编程中,可以存储多个回调函数。

c) 有限状态机: 每个函数代表一个状态,通过数组可以方便地切换状态。

d) 菜单驱动的程序: 每个函数对应一个菜单项的操作。

- 注意事项:

a) 类型匹配: 确保数组中的所有函数指针具有相同的签名(返回类型和参数列表)。

b) 数组大小: 在定义时明确指定数组大小,或者让编译器根据初始化推断大小。

c) 初始化: 可以在定义时初始化,也可以稍后赋值。

d) 空指针检查: 在调用函数之前,检查指针是否为NULL以避免运行时错误。

e) 可读性: 使用typedef可以提高代码的可读性。

##### 实例

使用**函数指针数组**实现简单的计算器：

```c
#include <stdio.h>

double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) { return b != 0 ? a / b : 0; }

int main() {
    "函数指针数组：指向返回值为double,形参为两个double类型的函数地址数组，可以指向一类函数地址"
    double (*operations[])(double, double) = {add, subtract, multiply, divide};//这写法第一次见
    //字符指针数组
    char *op_names[] = {"加", "减", "乘", "除"};
    //char op_names1[] = {'加', '减', '乘', '除'};用一维字符数组也行，但是有一些很细节的差别
    //char op_names[4] [4] = {"加", "减", "乘", "除"};这种更好，因为汉字不等于单个字符
    int choice;
    double a, b;

    printf("请选择操作：0-加，1-减，2-乘，3-除\n");
    scanf("%d", &choice);//输入的值会赋值给choice
    printf("请输入两个数：\n");
    scanf("%lf %lf", &a, &b);

    if (choice >= 0 && choice < 4) {
        //直接根据下标调用对应函数
        //之后维护也简单
        printf("结果：%.2f\n", operations[choice](a, b));
        printf("您进行了%s法运算\n", op_names[choice]);
    } else {
        printf("无效的选择\n");
    }

    return 0;
}
```

- 函数指针数组：`double (*operations[])(double, double) = {add, subtract, multiply, divide};`

优势： 

​	a) 灵活性：可以存储不同的函数，只要它们具有相同的签名（参数类型和返回类型）。 **很重要的条件**

​	b) 运行时多态：可以在运行时动态选择要执行的函数。 

​	c) 代码复用：避免了使用大量 if-else 或 switch 语句。 

​	d) 可扩展性：轻松添加新的操作，只需定义新函数并将其加入数组。

如果使用普通数组，你可能需要这样做：

```c
double results[4];
results[0] = add(a, b);
results[1] = subtract(a, b);
results[2] = multiply(a, b);
results[3] = divide(a, b);

// 使用时
double result = results[choice];
这种方法需要预先计算所有结果，即使只需要其中一个。而函数指针数组允许你只在需要时调用特定函数。
```

- 字符串数组：`char *op_names[] = {"加", "减", "乘", "除"};`

优势： a) 数据和逻辑分离：操作名称与实际操作逻辑分开存储。 b) 易于国际化：可以轻松切换到其他语言版本的操作名称。 c) 集中管理：所有操作名称在一处定义，便于修改和维护。

如果不使用字符串数组，你可能会这样做：

```c
switch(choice) {
    case 0: printf("您进行了加法运算\n"); break;
    case 1: printf("您进行了减法运算\n"); break;
    case 2: printf("您进行了乘法运算\n"); break;
    case 3: printf("您进行了除法运算\n"); break;
}
```

这种方法使得修改或添加新操作名称变得繁琐，也增加了代码重复。

结合使用这两种数组的优势：

1. 代码简洁性：可以用很少的代码处理多种操作。
2. 可维护性：添加新操作只需在两个数组中各添加一个元素。
3. 灵活性：可以轻松重排操作顺序或添加/删除操作。
4. 性能：避免了复杂的条件判断，直接通过索引访问函数和名称。

添加新操作变得非常简单：

```c
double power(double a, double b) { return pow(a, b); }

// 只需要修改这两行
double (*operations[])(double, double) = {add, subtract, multiply, divide, power};
char *op_names[] = {"加", "减", "乘", "除", "幂"};

// 主循环逻辑不需要改变,可维护性强
```

这种方法特别适合于需要频繁修改或扩展功能的场景，如插件系统、命令处理器等。它提供了一种优雅且可扩展的方式来组织和管理相关的函数和它们的描述。

#### 指向（指针函数）的（函数指针）数组

数组里面存的是全是函数的地址，而且他们的函数返回值都是指针类型的

定义格式：

```c
返回值类型* (*数组名[数组大小])(参数列表);
假设我们有一个返回 int 指针的函数指针数组：
int* (*func_ptr_arr[5])(int, int);
这定义了一个包含 5 个函数指针的数组，每个函数指针指向一个接受两个 int 参数并"返回 int 指针"的函数。
```

让我们看一个具体的例子来说明这个概念：

```c
#include <stdio.h>
#include <stdlib.h>

// 函数返回一个指向两个整数和的指针
int* add(int a, int b) {
    int* result = (int*)malloc(sizeof(int));
    *result = a + b;
    return result;
}

// 函数返回一个指向两个整数差的指针
int* subtract(int a, int b) {
    int* result = (int*)malloc(sizeof(int));
    *result = a - b;
    return result;
}

int main() {
    // 定义一个指向指针函数的函数指针数组
    int* (*operations[2])(int, int) = {add, subtract};
    
    int a = 10, b = 5;
    
    for (int i = 0; i < 2; i++) {
        int* result = operations[i](a, b);//返回的值指针（地址），需要一个指针变量接收
        printf("Operation %d result: %d\n", i, *result);
        free(result);  // 不要忘记释放内存，当我们使用 malloc 分配内存后，这块内存就会一直存在，直到我们显式地释放它
    }
    
    return 0;
}
```

