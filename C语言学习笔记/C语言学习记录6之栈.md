# C语言学习记录6之栈

## 指针在生产环境中顺序存储栈和链式存储栈的作用

**在c语言中的生产环境中，栈的类别可以分为顺序存储栈和链式存储栈。 实现方式上，顺序存储栈常用指针实现（动态数组实现）。而链式存储栈则使用链表来实现。 指针在两种实现方式上都扮演着非常重要的角色？**

***\*在C语言的生产环境中，栈的实现方式通常分为\**顺序存储栈**和**链式存储栈**。无论是哪种实现方式，**指针**在两者中都扮演着非常关键的角色。下面详细分析这两类栈的实现及指针的作用。

**顺序存储栈**（基于动态数组的实现）

- **定义**：栈的元素存储在一个**连续的内存块（数组）**中。

- **实现方式**：动态数组使用**指针**来管理内存，可以通过`malloc`/`realloc`动态扩展容量。

- 特点：

  - 访问速度快，支持**O(1)** 时间复杂度的随机访问（因为内存地址连续）。
  - 适合**元素数量相对稳定**的场景，但需要提前考虑扩容问题。

- **指针在顺序存储栈中的作用**

  - 使用指针管理动态内存分配和扩容，例如：

  - ```c
    stack->data = (int*)realloc(stack->data, new_capacity * sizeof(int));
    ```

  - 栈顶指针通过索引移动来表示栈的增长或收缩。

**链式存储栈**（基于链表的实现）

- **定义**：栈的元素作为链表节点存储，每个节点存储一个数据元素，并指向下一个节点。

- **实现方式**：使用**链表结构**来实现，节点之间通过指针链接。

- 特点：

  - 插入和删除操作非常灵活，时间复杂度为**O(1)**。
  - 适合**元素数量频繁变化**的场景，但每个节点需要额外存储一个指针（内存开销较大）。

- **指针在链式存储栈中的作用**

  - 每个节点使用**指针**链接到下一个节点：

  - ```c
    newNode->next = *top;  // 将新节点指向当前的栈顶
    ```

  - 栈顶指针指向链表的头节点，并在`push`和`pop`操作中动态更新。

### **对比：顺序存储栈 vs 链式存储栈**

| **特性**       | **顺序存储栈（动态数组实现）**     | **链式存储栈（链表实现）**     |
| -------------- | ---------------------------------- | ------------------------------ |
| **内存布局**   | 连续内存块                         | 分散内存块（节点通过指针链接） |
| **时间复杂度** | `O(1)` 访问和插入（扩容时为`O(n)`) | `O(1)` 插入和删除              |
| **内存效率**   | 无额外指针存储开销                 | 每个节点需要额外指针空间       |
| **适用场景**   | 适用于读多于写，数据量相对稳定     | 适用于频繁插入和删除的场景     |
| **扩展性**     | 需要扩容时移动整个数组             | 插入删除灵活，无需预分配       |
| **指针的角色** | 管理动态数组和内存扩展             | 维护节点之间的链接关系         |

------

### **总结：指针在两种实现中的关键作用**

1. **顺序存储栈**：
   - 使用指针管理**动态数组的内存**（如`malloc`、`realloc`）。
   - 通过栈顶指针控制栈的增长和收缩。
2. **链式存储栈**：
   - 使用指针**链接节点**，实现栈的插入和删除操作。
   - 栈顶指针维护链表头部，动态更新。

无论是顺序存储栈还是链式存储栈，**指针都在内存管理、节点连接、动态扩容等方面扮演着至关重要的角色**。可以说，**指针是栈实现的核心**工具，它在这两种实现方式上只是体现形式不同。

**在实际开发中，纯数组实现顺序存储栈的场景非常有限，更常见的是通过动态数组**来实现顺序存储栈。这主要是因为纯数组的固定大小限制在很多情况下不够灵活，而动态数组能更好地应对不确定的数据量。

## 一些疑问

**在c语言中，链表的顺序存储实现和链式存储实现就是指数组实现和指针实现对吗？**

不完全准确。让我来解释一下这两个概念的具体区别：

顺序存储实现：

- **确实通常用数组来实现**
- 数据元素在内存中是连续存储的
- **但不一定非要用数组，任何能保证内存连续性的存储方式都可以**
- 主要特点是逻辑相邻的元素在物理位置上也相邻

链式存储实现：

- **通常使用指针来实现**
- 数据元素在内存中可以是非连续的
- 每个节点除了数据域，还需要有指针域来指向下一个节点
- 主要特点是逻辑相邻的元素在物理位置上不一定相邻

**要说明的是，实现方式的本质区别在于存储空间的分配方式（连续vs非连续），而不是简单地等同于数组vs指针。**



**在c语言中，实现栈需要保证分配的内存空间连续吗？是为了方便压栈和弹栈操作吗？**

在C语言中实现栈时，内存空间是否必须连续主要取决于你选择的实现方式：

1. 数组实现：

- 使用数组实现栈时，内存空间必须是连续的
- 这是由数组的特性决定的，而不是栈本身的要求
- **确实方便了压栈(push)和弹栈(pop)操作，只需要移动栈顶指针即可**

2. 链表实现：

- 使用链表实现栈时，内存空间不需要连续
- 每个节点可以分散在内存的不同位置
- **压栈和弹栈通过修改指针完成，不要求内存连续性**

```c
// 数组实现 - 连续内存
struct ArrayStack {
    int data[MAX_SIZE];  // 连续的内存空间
    int top;
};

// 链表实现 - 不连续内存
struct Node {
    int data;
    struct Node* next;
};

struct LinkedStack {
    struct Node* top;    // 内存可以不连续
};
```

- 栈不必须要求连续内存空间

- 连续内存是数组实现方式的特点，确实能简化操作，**但不是栈的本质要求**

选择哪种实现方式要根据具体需求：

- 数组实现：适合大小固定、频繁压栈弹栈的场景
- 链表实现：适合大小动态变化的场景



**链式存储栈的实现：指的是指针实现还是链表实现？ 生产环境中数组实现多一点还是指针实现？还是链表实现？**

1. 在C语言中，**链式存储栈**是基于**链表**来实现的，因此也可以说是“链表实现”。指针在这个实现中扮演重要角色，因为链表的核心就是**通过指针将各个节点链接在一起**。因此，“指针实现”并不是一种独立的方法，而是链表实现的具体体现。

这是因为：

- 链式存储的核心特征是数据元素通过链接方式存储
- 每个节点包含数据域和指针域
- 内存空间可以不连续

2. 关于生产环境中的选择：

数组实现（静态数组）和指针实现（动态数组）都属于**顺序存储结构**，在实际生产中：

**最常用的是指针实现（动态数组）**，原因是：

- 内存空间可以动态分配，更灵活

- 保持了连续内存访问的性能优势

- 可以根据需求调整大小

- ```c
  // 生产环境中常见的实现
  struct Stack {
      int* data;          // 动态分配内存
      int top;
      int capacity;
  };
  ```

**纯数组实现较少用**，因为：

- 大小固定，不够灵活
- 可能造成内存浪费或空间不足

**链表实现使用相对较少**，原因是：

- 内存开销较大（需要额外存储指针）
- 数据访问性能较差（不连续内存）
- 缓存利用率低

选择建议：

1. 一般情况：优先使用指针实现（动态数组）
2. 特殊场景才考虑链表实现：
   - 频繁插入删除中间元素
   - 内存特别紧张需要精确控制
   - 栈大小变化非常频繁

实际案例：

- STL中的stack默认使用deque（双端队列）作为底层容器，本质上是分块的连续内存
- Java的Stack类继承自Vector，使用的是动态数组实现
- 大多数编程语言的标准库中，栈的默认实现都是基于动态数组

在**生产环境**中，当提到**指针实现栈**时，通常是指通过**动态数组**来实现**顺序存储栈**。这种实现方式主要用于追求**高效的内存访问**，并减少链表实现中的指针维护开销。



**链表的顺序存储和链式储存的实现可以有数组和指针分别实现。 但是栈的顺序存储和链式储存的实现，就不只有数组和指针可以实现了，链表也可以实现**？

栈的主要特点是后进先出(LIFO)的数据结构，它有两个基本操作：入栈(push)和出栈(pop)。我们可以用多种方式实现它：

1. 顺序存储实现：

- 使用数组

2. 链式存储实现：

- 使用指针
- 使用链表

关键区别：

1. 数组实现：

- 优点：实现简单，访问速度快
- 缺点：需要预先分配空间，可能会有空间浪费或溢出问题

1. 指针实现：

- 优点：动态分配空间，不会浪费
- 缺点：需要额外的空间存储指针

1. 链表实现：

- 优点：结合了链表的特性，便于管理多个栈
- 缺点：相比直接使用指针实现，结构稍显复杂

实际上，**链表实现可以看作是指针实现的一个特例，它们的核心思想是相似的，只是组织结构略有不同**。链表实现为栈操作提供了更多的灵活性，特别是在需要管理多个栈或需要栈之间进行操作的场景下。



## 顺序存储栈的实现

### 纯数组（静态数组）实现，很少使用

使用纯数组（比较少用）来模拟栈的话，那就是小的下标为栈底，大的下标为栈顶了。用top来确定栈顶元素的位置（在数组中的位置）

```c
#ifndef STATIC_ARRAY_STACK_H
#define STATIC_ARRAY_STACK_H

#include <stdio.h>
#include <stdbool.h>

#define MAX_SIZE 100    // 栈的最大容量

// 栈结构体
typedef struct {
    int array[MAX_SIZE];    // 固定大小的数组
    int top;                // 栈顶指针
} Stack;

// 错误码枚举,默认递增
typedef enum {
    STACK_OK = 0,
    STACK_EMPTY,
    STACK_FULL,
    STACK_NULL_ERROR
} StackError;

// 初始化栈，需要先在mian中实例化一个栈出来
void stack_init(Stack* stack) {
    if (stack) {//如果栈实例化成功，就初始化栈顶指针的值
        stack->top = -1;
    }
}

// 检查栈是否为空
// 两种情况返回 true：
// 1. 栈指针为 NULL（无效栈）
// 2. 栈已初始化但 top 为 -1（有效的空栈）
bool stack_is_empty(const Stack* stack) {
    if (!stack) return true;// 栈指针为 NULL，这是一个无效栈
    return stack->top == -1;// top 为 -1 表示栈中没有元素
}

// 检查栈是否已满，最多存放数组的可用最大下标啊，栈顶指针指到这里就说明满了
bool stack_is_full(const Stack* stack) {
    if (!stack) return true;
    return stack->top == MAX_SIZE - 1;
}

// 获取栈大小，栈顶指针从-1开始的，也就是从数组的0号下标开始存到，由于是先自增的，所以实际元素个数为栈顶指针下标+1
int stack_size(const Stack* stack) {
    if (!stack) return 0;
    return stack->top + 1;
}

// 入栈操作，
StackError stack_push(Stack* stack, int value) {
    if (!stack) return STACK_NULL_ERROR;
    if (stack_is_full(stack)) return STACK_FULL;
    
    //下标（栈顶指针先自增）再通过下标访问数组赋值到指定位置
    stack->array[++stack->top] = value;
    return STACK_OK;
}

// 出栈操作，传进来一个地址用于赋值的，用于保存出栈的元素的，因为函数返回类型已经给操作状态StackError了，所以在外面实例化一个变量，在函数里面赋值
StackError stack_pop(Stack* stack, int* value) {
    if (!stack || !value) return STACK_NULL_ERROR;
    if (stack_is_empty(stack)) return STACK_EMPTY;
    
    //先把弹出的元素赋值给*value，栈顶指针再自减
    *value = stack->array[stack->top--];
    return STACK_OK;
}

// 查看栈顶元素
StackError stack_peek(const Stack* stack, int* value) {
    if (!stack || !value) return STACK_NULL_ERROR;
    if (stack_is_empty(stack)) return STACK_EMPTY;
    
    *value = stack->array[stack->top];
    return STACK_OK;
}

// 清空栈（并不是物理上清空啊？只是把栈顶指针重新指向-1，再赋值时就覆盖达到重新压栈的效果？？？）
void stack_clear(Stack* stack) {
    if (!stack) return;
    stack->top = -1;
}

// 打印栈内容（用于调试）
void stack_print(const Stack* stack) {
    if (!stack) {
        printf("Stack is NULL\n");
        return;
    }
    
    if (stack_is_empty(stack)) {
        printf("Stack is empty\n");
        return;
    }
    
    printf("Stack contents (top to bottom): ");
    for (int i = stack->top; i >= 0; i--) {
        printf("%d ", stack->array[i]);
    }
    printf("\n");
}

#endif // STATIC_ARRAY_STACK_H
```

使用示例：

```c
int main() {
    Stack stack;
    stack_init(&stack);

    // 入栈
    stack_push(&stack, 10);
    stack_push(&stack, 20);
    
    // 打印栈内容
    stack_print(&stack);
    
    // 出栈
    int value;
    if (stack_pop(&stack, &value) == STACK_OK) {
        printf("Popped value: %d\n", value);
    }
    
    return 0;
}
```

#### 防重复包含机制

`#endif // STATIC_ARRAY_STACK_H` 是C语言头文件的防重复包含保护机制，它与文件开头的 `#ifndef STATIC_ARRAY_STACK_H` 配对使用。

文件开头：

```c
#ifndef STATIC_ARRAY_STACK_H    // 如果没有定义这个宏
#define STATIC_ARRAY_STACK_H    // 定义这个宏
```

文件结尾：

```c
#endif // STATIC_ARRAY_STACK_H  // 结束这个条件编译块
```

这样做的目的是：

1. 防止头文件被重复包含
2. 避免代码重复定义导致的编译错误

举个例子，假设你有以下文件结构：

```c
// main.c
#include "stack.h"
#include "other.h"

// other.h
#include "stack.h"
```

如果不加这个保护机制，stack.h 的内容会被包含两次，可能导致：

- 结构体重复定义
- 函数重复声明
- 编译错误

有了这个保护机制后：

1. 第一次包含 stack.h：宏未定义，定义宏并包含内容
2. 第二次包含 stack.h：发现宏已定义，直接跳过内容

这是C语言头文件的标准写法，几乎所有头文件都会使用这种机制。如果你不需要写成头文件，可以直接把这三行去掉，代码依然能正常工作。

**这个的应用场景就是：假如有一个源文件a.c他需要调用其他源文件如b.c和d.c的函数， 如果b.c和d.c都包含了stack.h，而a.c又包含b.c和d.c，就导致stack.h 的内容会被包含两次对吗？ 这跟Java中的maven管理依赖是同一个道理？**

对,你理解得很准确！让我详细解释一下这两种情况的对比：

- C语言的情况：

```
a.c
├── 包含 b.c
│   └── 包含 stack.h
└── 包含 d.c
    └── 包含 stack.h
```

没有防重复包含保护时会出现：

1. 编译器处理 b.c 时读入一次 stack.h
2. 编译器处理 d.c 时又读入一次 stack.h
3. 导致重复定义错误

- Java/Maven的依赖管理：

```
ProjectA
├── 依赖 LibraryB
│   └── 依赖 CommonLib
└── 依赖 LibraryD
    └── 依赖 CommonLib
```

Maven的依赖管理机制：

1. Maven 发现 CommonLib 被多个路径引入
2. Maven 会自动解决依赖冲突，只保留一个版本的 CommonLib
3. 可以通过 `<dependencyManagement>` 明确指定使用哪个版本

两者的共同点：

- 都是为了解决重复引入的问题
- 都需要一个机制来防止重复
- 都是为了保证代码的正确性和可维护性

主要区别：

1. 实现层面：
   - C语言是通过预处理器（#ifndef）在编译时解决
   - Maven是在项目构建阶段解决
2. 灵活性：
   - C语言的方式是二进制的（要么包含要么不包含）
   - Maven可以进行版本管理和冲突解决
3. 作用时机：
   - C语言在编译时处理
   - Maven在构建项目时处理

你还记得Maven处理依赖冲突的规则吗？比如：

1. 最短路径优先
2. 第一声明优先
3. 可以通过 `<exclusions>` 排除不需要的依赖

#### 栈的“清空”

这里的"清空"确实只是逻辑上的清空,而不是物理上的清空。让我详细解释一下：

```
逻辑清空（当前实现）:
void stack_clear(Stack* stack) {
    if (!stack) return;
    stack->top = -1;  // 仅移动栈顶指针
}
```

优点：

- 操作速度快（O(1)复杂度）
- 内存使用效率高

特点：

- 原数据仍然存在于内存中
- 通过移动指针来"遗忘"这些数据
- 新数据入栈时会直接覆盖旧数据

```
物理清空（如果要实现）:
void stack_clear_physical(Stack* stack) {
    if (!stack) return;
    memset(stack->array, 0, sizeof(stack->array));  // 将所有元素设为0
    stack->top = -1;
}
```

缺点：

- 操作速度慢（O(n)复杂度）
- 额外的内存操作

特点：

- 实际清除内存中的数据
- 适用于处理敏感数据的场景

举个实际的例子：

```c
Stack stack;
stack_init(&stack);

// 压入数据
stack_push(&stack, 1);
stack_push(&stack, 2);
stack_push(&stack, 3);
// 此时数组内容: [1,2,3], top=2

// 逻辑清空
stack_clear(&stack);
// 数组实际内容仍然是: [1,2,3], 但top=-1
// 此时这些数据已经"不可见"了

// 压入新数据
stack_push(&stack, 10);
// 数组内容变成: [10,2,3], top=0
// 注意2,3仍然在内存中，但已经"不可访问"
```

这就像:

1. 图书馆的书架：
   - 逻辑清空 = 销毁索引卡片（快）
   - 物理清空 = 把每本书都搬走（慢）
2. 或者像删除文件：
   - 逻辑清空 = 删除文件索引（快速删除）
   - 物理清空 = 文件粉碎器（完全删除）

在大多数普通应用中，逻辑清空就足够了。但如果你在处理敏感数据（如密码、密钥等），可能需要考虑物理清空。

#### 栈的几种状态

通过一个完整的例子来说明各种状态：

```c
// 1. 未初始化状态（无效状态）
Stack stack1;
// 此时 stack1.top 的值是未定义的，栈处于无效状态

// 2. 初始化后的空栈（有效的空栈）
Stack stack2;
stack_init(&stack2);        // top 被设置为 -1
if (stack_is_empty(&stack2)) {
    printf("stack2 是空栈\n");  // 会输出
}

// 3. 压入元素后的非空栈
stack_push(&stack2, 100);   // top 变成 0
if (!stack_is_empty(&stack2)) {
    printf("stack2 不是空栈\n");  // 会输出
}

// 4. 清空后又回到空栈状态
stack_clear(&stack2);       // top 重新变成 -1
if (stack_is_empty(&stack2)) {
    printf("stack2 又成为空栈\n");  // 会输出
}
```

栈的状态可以分为：

- 无效状态（未初始化或指针为NULL）
- 有效的空栈（已初始化，top = -1）
- 有效的非空栈（已初始化，top ≥ 0）

`stack_is_empty()` 函数实际上在检查：

- 栈是否是有效的（stack != NULL）
- 栈是否有元素（top != -1）

top = -1 的含义：

- 这是栈的一个特殊约定
- 表示栈已经初始化但还没有元素
- 这是一个有效的空栈状态
- 下一个元素将被放在索引 0 的位置

#### 数组实现栈的优势

**1.性能优势：**

- 内存连续性：数组在**内存中是连续存储的，具有更好的缓存命中率**

- 随机访问快：O(1)时间复杂度直接访问任何元素

- 入栈/出栈操作简单：仅需移动栈顶指针，复杂度O(1)

  - ```c
    // 入栈操作简单高效
    stack->array[++stack->top] = value;
    
    // 出栈操作也很简单
    *value = stack->array[stack->top--];
    ```

**2.内存管理优势：**

- 静态数组实现时内存空间固定，无内存碎片

- 内存使用更可预测，适合嵌入式系统

- 无需频繁的内存分配/释放操作

  - ```c
    // 静态数组实现
    typedef struct {
        int array[MAX_SIZE];  // 固定大小，编译时就确定了内存布局
        int top;
    } Stack;
    ```

**3.实现简单：**

- 代码结构清晰，易于维护

- 不需要处理复杂的指针操作

- 边界检查简单直观

  - ```c
    // 边界检查非常简单
    bool stack_is_full(const Stack* stack) {
        return stack->top == MAX_SIZE - 1;
    }
    ```

    

**4.缺点与局限：**

- ```c
  // 1. 固定大小的限制
  #define MAX_SIZE 100  // 需要预先定义大小
  
  // 2. 空间浪费
  Stack stack;  // 即使只用到几个元素，也会分配MAX_SIZE大小的空间
  
  // 3. 处理栈满的情况比较麻烦
  if (stack_is_full(&stack)) {
      // 处理栈满情况...
      return STACK_FULL;
  }
  ```

**5.使用场景建议：**

1. 当数据规模已知且较为固定时，用数组实现
2. 对性能要求高，特别是要求快速访问时
3. 在嵌入式系统等资源受限环境中
4. 需要频繁进行入栈出栈操作时

不建议使用的场景：

1. 数据规模不确定且变化很大
2. 内存空间非常受限而数据量可能很大
3. 需要频繁调整栈大小的场景

### 指针实现动态数组

#### 如何保证动态数组的内存连续性？

在 C 语言中，使用 `malloc` 或 `calloc` 分配的内存空间是**连续的**。这也是为什么这些函数能很好地支持像数组这样的**顺序存储结构**。

##### **`malloc` 和 `calloc` 的内存连续性**

- **`malloc(size)`**：
  为你申请一块大小为 `size` 字节的连续内存，并返回这块内存的首地址。
- **`calloc(count, size)`**：
  申请 `count * size` 字节的连续内存，同时将这些内存初始化为 0。

无论使用 `malloc` 还是 `calloc`，分配的内存块在物理上是**连续的**，适合用来存储顺序访问的数据，如数组。

##### **内存分配的实现原理**

- **堆内存管理**：
  C 语言中的 `malloc` 和 `calloc` 从**堆（heap）**中分配内存。
  堆内存是一个大块的连续区域，管理器会从中找到足够大的连续空间来满足分配请求。
- 如果系统无法找到足够的连续内存，则 `malloc` 会返回 `NULL`，表示分配失败。

##### **总结**

- 使用 `malloc` 或 `calloc` 分配的内存是**连续**的，适合顺序存储结构（如数组）。
- 如果无法找到足够大的连续内存，分配会失败，因此需要检查返回值。
- 这种内存模型让我们可以用指针轻松实现数组的功能，同时保持高效的 O(1) 访问性能。

内存连续性是顺序存储结构的核心，因此你可以放心使用 `malloc` 和 `calloc` 来实现动态数组。



在C语言中，**静态数组**的大小在编译时确定，而**动态数组**的大小可以在运行时根据需要动态分配。这主要通过**指针**和**动态内存管理函数**来实现。

1. **动态分配内存**
   使用 `malloc` 或 `calloc` 函数为数组分配足够的内存空间。
2. **通过指针访问元素**
   使用指针语法访问和操作动态数组中的元素。
3. **释放内存**
   当不再需要数组时，使用 `free` 函数释放内存，避免内存泄漏。

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;  // 数组的大小
    printf("请输入数组的大小: ");
    scanf("%d", &n);

    // 1. 使用 malloc 为数组动态分配内存
    int *arr = (int *)malloc(n * sizeof(int));//传入需要的总字节大小，拿到分配到的内存的首地址
    if (arr == NULL) {  // 检查内存分配是否成功
        printf("内存分配失败\n");
        return 1;
    }

    // 2. 初始化数组元素，arr[i] 实际上是 *(arr + i),运行时才确定的数组叫动态数组，这叫初始化动态数组了
    for (int i = 0; i < n; i++) {
        arr[i] = i + 1;  // 赋值为 1, 2, 3, ...
    }

    // 3. 打印数组元素
    printf("数组元素: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 4. 释放内存
    free(arr);

    return 0;
}
```

#### 思考逻辑流程

1. **确定数组的大小**：

   - 在运行时获取用户输入或根据程序逻辑计算数组的大小。

2. **分配内存**：

   - 使用 `malloc` 或 `calloc` 为数组分配所需大小的内存，并将返回的地址存储在一个指针变量中。

   **示例逻辑**：`arr = (int *)malloc(n * sizeof(int));`

   - 这里 `malloc` 分配了 `n` 个 `int` 大小的连续内存块，并返回首地址（通过int类型的偏移量可以找到 `n` 个 `int` 大小的连续内存块）。

3. **检查内存分配**：

   - 如果分配失败，`malloc` 会返回 `NULL`，需要进行判断并处理。

4. **使用指针访问数组**：

   - 通过 `arr[i]` 或者指针运算 `*(arr + i)` 访问数组元素。

5. **释放内存**：

   - 动态分配的内存不会自动释放，需要手动调用 `free` 函数。

#### 常见问题和注意事项

1. **内存泄漏**：如果忘记调用 `free` 释放内存，程序会造成内存泄漏。
2. **野指针**：使用 `free` 后，应将指针置为 `NULL`，避免再次访问已释放的内存。
3. **访问越界**：访问数组时要确保下标不超过分配的大小，否则会造成未定义行为。

#### 总结

通过指针实现动态数组的关键在于：

1. **分配内存**：使用 `malloc` 或 `calloc`。
2. **访问元素**：使用指针或下标操作。
3. **释放内存**：及时 `free` 以防止内存泄漏。

动态数组的思考逻辑与静态数组类似，但需要特别关注**内存管理**，这是C语言中的重要技能。

### 动态数组与静态数组的实现区别

**那这么说c语言中的数组，就是使用上面这两个函数实现的？ 只不过封装好了，我们可以直接使用？**

**不是完全这样**，C语言中的静态数组并不是通过 `malloc` 或 `calloc` 实现的。虽然动态数组依赖这些函数，但静态数组和动态数组的**内存分配机制**是不同的。下面详细解释它们的区别和各自的工作原理。

**静态数组**：

- 编译时就确定大小，并在 **栈** 或 **静态存储区** 分配。
- 语法简单，例如 `int arr[10];`。
- 使用时不需要考虑内存管理，不用 `free`。

**动态数组**：

- 在 **运行时** 由程序员控制大小，通过 `malloc`、`calloc` 在 **堆** 上分配。
- 需要手动释放内存，否则会造成 **内存泄漏**。
- 更灵活，可以根据需要调整大小。

##### **静态数组的内存分配原理**

C语言中的**静态数组**并不是用 `malloc` 或 `calloc` 实现的，而是直接分配在**栈**或**静态区**。这是它们的主要区别：

1.**局部数组**（如在函数内声明的数组）：

- 在**栈内存**中分配，函数返回时自动释放。

- ```c
  void func() {
      int arr[10];  // 栈上分配
  }
  ```

2.**全局或静态数组**：

- 分配在**静态存储区**，在程序结束时释放。

- ```
  int arr[10];  // 静态存储区分配
  ```

##### **动态数组的内存分配原理**

**动态数组**是用 `malloc`、`calloc` 或 `realloc` 在 **堆内存** 上分配的：

```c
int *arr = (int *)malloc(10 * sizeof(int));
```

这种方式在运行时灵活分配内存，但必须手动释放：

```c
free(arr);
```

##### **为什么静态数组没有用 `malloc` 实现？**

- **性能差异**：
  - 静态数组分配在**栈或静态区**，速度更快。栈内存的分配/释放开销非常小，只需调整栈指针。
  - `malloc` 在 **堆上**分配内存，需要系统管理内存块，会有一定的开销。
- **简单性**：
  - 静态数组不需要程序员管理内存，适合存活时间短或大小固定的数据。

##### **封装层面的理解**

你可以理解 **动态数组** 是通过 `malloc` 或 `calloc` 实现的数组，但 **静态数组** 是更接近于**语言层面直接支持**的数据结构，不是简单的封装。

##### **总结**

1. **静态数组**：
   - 在编译时确定大小，分配在栈或静态存储区。
   - 不依赖 `malloc` 或 `calloc`，也不需要手动释放内存。
2. **动态数组**：
   - 使用 `malloc` 或 `calloc` 在堆上分配内存。
   - 灵活但需要手动释放内存。

所以，**静态数组并不是通过 `malloc` 或 `calloc` 实现的**，而动态数组才是真正依赖这些函数的实现。两者各有优缺点，根据场景选择使用哪种数组。

### 生产环境常用指针实现顺序存储栈（动态数组实现）重点

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <errno.h>

#define INITIAL_CAPACITY 8
#define MAX_CAPACITY (SIZE_MAX / sizeof(int))

typedef struct {
    int *data;          // 分配到的数组空间的首地址
    int top;            // top指向栈顶元素，-1表示空栈
    size_t capacity;    // 数组容量
} Stack;

// 错误处理
static void handle_error(const char* message) {
    fprintf(stderr, "Error: %s (%s)\n", message, strerror(errno));
    exit(EXIT_FAILURE);
}

// 初始化栈
Stack* initStack(void) {
    //初始化一个栈结构体
    Stack *stack = malloc(sizeof(Stack));
    if (!stack) {
        handle_error("Failed to allocate stack");
    }
    
    //相当于初始化一个数组了，data指向数组的首地址
    stack->data = malloc(INITIAL_CAPACITY * sizeof(int));
    if (!stack->data) {
        //如果数组空间没有分配完成就把已经申请的其他空间都释放掉
        free(stack);
        handle_error("Failed to allocate data array");
    }
    
    stack->top = -1;  // 初始化为-1，表示空栈
    stack->capacity = INITIAL_CAPACITY;//初始化栈的初始容量
    return stack;
}

// 扩容
static bool expand(Stack *stack) {
    //预处理MAX_CAPACITY会被替换为(SIZE_MAX / sizeof(int))
    if (stack->capacity >= MAX_CAPACITY / 2) {
        return false;
    }
    
    size_t new_capacity = stack->capacity * 2;
    //使用新指针接收是为了检验是否扩容成功，校验过后再覆盖老指针
    int *new_data = realloc(stack->data, new_capacity * sizeof(int));
    if (!new_data) {
        return false;
    }
    
    stack->data = new_data;
    stack->capacity = new_capacity;
    return true;
}

// 缩容
static void shrink(Stack *stack) {
    // 当栈的大小小于容量的1/4时进行缩容
    //获取当前栈的的元素大小top+1,小于等于整体分配的容量的四分之一时就缩容
    //但是容量要大于初始时的定义容量，不然会频繁的缩容
    if (stack->capacity > INITIAL_CAPACITY && 
        (stack->top + 1) <= (int)(stack->capacity / 4)) {
        
        size_t new_capacity = stack->capacity / 2;
        //如果缩容一半小于初始时定义容量时，就缩容到初始容量即可
        if (new_capacity < INITIAL_CAPACITY) {
            new_capacity = INITIAL_CAPACITY;
        }
        
        //会连续，会分配new_capacity * sizeof(int)这么大的空间，无论原来空间是大还是小
        //缩小内存块：
	    //调用 realloc 时，如果新容量（new_capacity）比原来小，并且系统能够直接在原地调整大小，则不会移动内存，
        //数据位置保持不变，只调整内部的容量标记。
	   //内存移动的可能性：
       //如果原内存后面的空间已经被其他内存块占用，缩容时也有可能会分配新的更小块内存并复制数据。

        int *new_data = realloc(stack->data, new_capacity * sizeof(int));
        if (new_data) {
            stack->data = new_data;
            stack->capacity = new_capacity;
        }
    }
}

// 压栈操作
bool push(Stack *stack, int value) {
    if (!stack) return false;
    
    // 检查是否需要扩容
    if (stack->top + 1 >= (int)stack->capacity) {
        if (!expand(stack)) {
            return false;
        }
    }
    
    // 先移动top指针，再存储数据
    //stack->top++;
    //stack->data[stack->top] = value;
    //减少了中间状态，操作更原子化
    stack->data[++stack->top] = value;
    return true;
}

// 出栈操作
bool pop(Stack *stack, int *value) {
    if (!stack || isEmpty(stack) || !value) {
        return false;
    }
    
    // 先取出数据，再移动top指针
    //*value = stack->data[stack->top];
    //stack->top--;
    //减少了中间状态，操作更原子化
    stack->data[stack->top--] = value;
    
    // 检查是否需要缩容
    shrink(stack);
    return true;
}

// 查看栈顶元素
bool peek(const Stack *stack, int *value) {
    if (!stack || isEmpty(stack) || !value) {
        return false;
    }
    
    // 直接返回top指向的元素
    *value = stack->data[stack->top];
    return true;
}

// 判断栈是否为空
bool isEmpty(const Stack *stack) {
    return !stack || stack->top == -1;
}

// 获取栈中元素个数
int size(const Stack *stack) {
    return stack ? (stack->top + 1) : 0;
}

// 获取栈的容量
size_t capacity(const Stack *stack) {
    return stack ? stack->capacity : 0;
}

// 清空栈(逻辑上的清空)
void clear(Stack *stack) {
    if (stack) {
        stack->top = -1;
        shrink(stack);
    }
}

// 销毁栈（物理上的）
void destroyStack(Stack *stack) {
    if (stack) {
        free(stack->data);
        free(stack);
    }
}

// 测试代码
#ifdef DEBUG
int main(void) {
    Stack *stack = initStack();
    if (!stack) {
        return EXIT_FAILURE;
    }

    // 测试压栈
    printf("Pushing elements:\n");
    for (int i = 1; i <= 5; i++) {
        int value = i * 10;
        if (push(stack, value)) {
            printf("Pushed: %d, Stack size: %d\n", value, size(stack));
        } else {
            printf("Push failed for value: %d\n", value);
        }
    }

    // 测试栈顶元素
    int top_value;
    if (peek(stack, &top_value)) {
        printf("\nTop element: %d\n", top_value);
    }

    // 测试出栈
    printf("\nPopping elements:\n");
    int popped_value;
    while (!isEmpty(stack)) {
        if (pop(stack, &popped_value)) {
            printf("Popped: %d, Stack size: %d\n", popped_value, size(stack));
        }
    }

    destroyStack(stack);
    return EXIT_SUCCESS;
}
#endif
```

#### 程序解析

SIZE_MAX 是在 C 语言的 `<stdint.h>` 头文件中定义的宏，代表 size_t 类型（无符号整型，只不过可以达到系统支持的最大值，就不用区分int,short,long了）能表示的最大值。在这段代码中虽然没有显式包含 `<stdint.h>`，但它通常通过其他标准头文件间接包含了。

最大容量的计算：

```c
#define MAX_CAPACITY (SIZE_MAX / sizeof(int))
```

- SIZE_MAX 是 size_t 类型能表示的最大值（比如在32位系统上通常是 4294967295）

- sizeof(int) 是整型的字节大小（通常是4字节）

- 所以 MAX_CAPACITY 就是**系统能分配的最大 int 数组长度**

扩容检查：

```c
if (stack->capacity >= MAX_CAPACITY / 2) {
    return false;
}
```

这个检查很巧妙：

- 因为扩容是翻倍的(capacity * 2)

- 所以要检查当前容量的两倍是否会超过 MAX_CAPACITY

- 如果当前容量 >= MAX_CAPACITY/2，那么扩容后就会 >= MAX_CAPACITY

- 这样可以防止扩容时发生溢出

- 所以这个条件：`stack->capacity >= MAX_CAPACITY / 2` 的意思是：

  1. 如果当前容量已经达到或超过了系统最大限制的一半
  2. 那么再扩容2倍就一定会超出系统限制
  3. 因此必须提前拒绝这次扩容请求

  这是一个很巧妙的预防性检查：

  - 不是等到真的溢出才处理
  - 而是提前在可能导致溢出的条件下就返回false
  - 保证了系统的安全性

  这就是为什么用 `>= MAX_CAPACITY / 2` 而不是直接和 `MAX_CAPACITY` 比较的原因！

一个具体的例子：

```c
// 假设在32位系统上：
SIZE_MAX = 4294967295    // 2^32 - 1
sizeof(int) = 4
MAX_CAPACITY = 1073741823  // 4294967295 / 4

// 扩容检查
if (capacity >= 1073741823/2) {  // 约536870911
    return false;  // 防止下一次扩容超出系统限制
}
```

为了更规范，代码应该显式包含需要的头文件：

```c
#include <stdint.h>  // 为了使用 SIZE_MAX
#include <limits.h>  // 如果需要使用其他限制常量
```

这个设计考虑到了：

1. 内存安全 - 防止分配超过系统能处理的大小
2. 整数溢出保护 - 防止capacity * 2时的溢出
3. 提前预防 - 在实际发生问题前就返回false



**c语言中的realloc函数，是在原来的空间上开辟连续空间吗？如果没有足够的空间，就会开辟一块大的空间并把旧空间赋值过来，以保证整块空间的连续性？**

是的，`realloc` 在 C 语言中的确会尽量在**原来的内存块基础上**进行扩展，但它的行为取决于内存的实际分配情况。

**`realloc` 的工作原理：**

1. **扩展原内存块：**
   如果原有的内存块后面有足够的连续空间，那么 `realloc` 会直接在原地扩展内存，返回原内存的指针。这种情况下，不需要移动数据。
2. **分配新的内存块：**
   如果原内存块后面没有足够的连续空间，`realloc` 会在**堆区**寻找新的内存块，分配一块足够大的连续空间。然后，它会把**旧内存块的内容复制**到新内存块中，最后释放旧的内存块。
3. **返回值：**
   - 成功：返回新分配的内存块的指针（可能与原指针相同或不同）。
   - 失败：返回 `NULL`，原内存块保持不变。

**注意事项：**

1. **避免内存泄漏：** 如果 `realloc` 失败，返回 `NULL`，需要手动释放原来的内存以避免泄漏。
2. **潜在的性能开销：** 如果需要移动内存，数据的复制会引入性能开销，因此频繁使用 `realloc` 应谨慎。
3. **避免悬空指针：** `realloc` 成功后要使用新指针，否则旧指针可能会变为悬空指针。



```
#ifdef DEBUG
......
#endif
```

这段代码是一个**测试代码块**，用于在编译时验证栈的基本功能。它使用了**`#ifdef DEBUG`** 预处理指令,[上面还有其他指令](####防重复包含机制)，表示该部分代码仅在定义了 **`DEBUG`** 宏时才会编译和运行。

**`#ifdef DEBUG` 预处理指令**

- **作用**：
  只有在编译时指定了 **`DEBUG`** 宏时，这部分代码才会被编译。这样做的好处是可以在调试阶段测试程序功能，而在正式发布时自动忽略这些测试代码，减少无关代码的影响。

- 启用方法：

- ```
  gcc -DDEBUG stack.c -o stack
  ```

- 这样会定义 `DEBUG` 宏，并启用测试代码。

**`#ifdef DEBUG` 预处理指令相当于Java中的maven打包程序时也会对程序进行单元测试，但是发布时并没有测试代码?**

​	完全正确！**`#ifdef DEBUG`** 在 C 语言中的作用类似于 Java 中使用 **Maven** 进行构建时，**区分开发环境与生产环境**，例如：

- 在 **开发环境**中运行单元测试或调试代码。
- 在 **生产环境**中排除测试代码，只保留核心功能。

**C语言中的 `#ifdef DEBUG`：**

- 使用 **条件编译**，根据是否定义了 `DEBUG` 宏，决定是否包含某些代码片段。

- ```c
  #ifdef DEBUG
  printf("Debug mode: This is a test message.\n");
  #endif
  ```

- **编译阶段控制：**可以通过 **`gcc`** 编译时添加 `-DDEBUG` 参数，启用调试代码：

- ```c
  gcc -DDEBUG myprogram.c -o myprogram
  ```

- 如果不指定 `-DDEBUG`，则所有在 `#ifdef DEBUG` 块中的代码会被忽略，不会进入最终的可执行文件。

**Maven中的测试和发布流程：**

- **测试代码 vs. 生产代码：**在 Maven 项目中，测试代码通常位于 **`src/test/java`** 目录。构建时，Maven 会自动运行这些测试代码以验证功能是否正常。

- **跳过测试发布：** 发布生产版本时，可以通过 `mvn` 命令跳过测试代码：

- ```bash
  mvn clean install -DskipTests
  ```

- 这样，测试代码不会运行或打包进入生产版本的 JAR 文件。

- **环境区分：**Maven 还支持通过 **profiles**（如 `dev` 和 `prod`）来区分开发与生产环境，选择不同的配置来控制是否包含测试代码和日志等调试信息。



#### 核心思想和设计逻辑

1.**基本概念与设计思想**

顺序存储的本质：

- 在内存中分配**连续**的空间来存储数据

- 使用**指针**指向这块连续空间的起始位置

- 通过**索引实现快速访问**任意位置的元素

- ```c
  typedef struct {
      int *data;          // 数组空间的首地址
      int top;            // top指向栈顶元素，-1表示空栈
      size_t capacity;    // 数组容量
  } Stack;
  ```

- 这个设计反映了三个核心考虑：
  - 使用动态数组实现可伸缩存储
  - 通过top指针标识栈顶位置
  - 维护容量信息以便动态调整

主要设计思想：

- 内存管理策略：

  - 初始容量设置为8（INITIAL_CAPACITY）
  - 采用动态扩容和缩容机制
  - 扩容时容量翻倍（capacity * 2）
  - 当使用量低于1/4时进行缩容（capacity / 2）
  - 设置最大容量限制（MAX_CAPACITY）防止内存溢出

- 安全性考虑：

  - 所有操作都进行空指针检查
  - 每个内存分配操作都有错误检查
  - 使用handle_error统一处理错误情况
  - 函数返回bool类型表示操作成功与否

- 压栈操作(push)：

  - ```c
    bool push(Stack *stack, int value) {
        if (!stack) return false;
        
        // 检查是否需要扩容
        //检查当前栈的容量（看分配到的数组是否够用了）
        if (stack->top + 1 >= (int)stack->capacity) {
            if (!expand(stack)) return false;
        }
        
        //减少了中间状态，操作更原子化
        stack->data[++stack->top] = value;
        return true;
    }
    ```

  - 先检查容量是否足够

    - top指针的设计逻辑：

    - ```c
      // 初始化时
      stack->top = -1;  // 空栈状态
      
      // 压栈操作
      //stack->top++;           // 先移动指针到要存放的位置
      //stack->data[stack->top] = value;  // 再存数据
      stack->data[++stack->top] = value;  // 先自增top，再使用新的top值作为下标存值
      减少了中间状态，操作更原子化
      ```

    - 元素个数与下标的关系：

      - top = -1 时：空栈，元素个数 = 0

      - top = 0 时：1个元素，使用了data[0]

      - top = 1 时：2个元素，使用了data[0]和data[1]

      - 以此类推...

      - 所以任意时刻，栈中的元素个数 = top + 1

    - 扩容判断条件分析：

      - ```c
        if (stack->top + 1 >= (int)stack->capacity)
        ```

      - 比如capacity = 8时：

        - 当top = 7时，已有8个元素(0~7)，此时top+1 = 8，等于capacity
        - 这时正好用完了所有空间，需要扩容
        - 所以使用 >= 是合理的

      - 用一个具体例子说明：

        - ```c
          // 假设INITIAL_CAPACITY = 8
          Stack *stack = initStack();  // top = -1, capacity = 8
          
          // 压入8个元素后
          // top = 7, 元素占用下标0~7
          // 此时栈满，top + 1 = 8 == capacity
          
          // 再压入一个元素前
          if (8 >= 8) {  // 成立，触发扩容
              expand(stack);  // capacity变为16
          }
          ```

      - 所以这个扩容条件的设计是很精确的：

        - 用">="而不是">"可以确保在空间刚好用完时就触发扩容
        - 避免了先存数据再发现空间不够的问题
        - 保证了数据操作的安全性

  - 必要时进行扩容

  - 更新栈顶指针并存入数据

- 出栈操作(pop)：

  - ```c
    bool pop(Stack *stack, int *value) {
        //栈是实例化的，栈不是空的，外面定义了变量接收弹栈的元素
        if (!stack || isEmpty(stack) || !value) {
            return false;
        }
        
        //*value = stack->data[stack->top];
        //stack->top--;
        //减少了中间状态，操作更原子化
        *value = stack->data[stack->top--];
        
        shrink(stack);
        return true;
    }
    ```

  - 检查栈是否为空

  - 取出数据并更新栈顶指针

  - 检查是否需要缩容

    - 特色优化设计：

      - 内存优化：

        - 动态扩缩容机制避免内存浪费
        - 保留最小容量（INITIAL_CAPACITY）避免频繁调整
        - 使用realloc而不是malloc+free，提高效率

      - 性能优化：

        - 扩容采用2倍增长策略，减少扩容频率
        - 缩容阈值设为1/4，避免频繁震荡
        - 关键操作都是O(1)复杂度

      - 调试支持：

        - 通过DEBUG宏控制测试代码

        - 提供完整的测试用例

        - 包含容量查询等辅助函数便于调试

#### **为什么使用动态数组实现栈？**

- **高效访问**：数组具有**连续内存块**，可以直接通过索引访问元素，速度比链表快。
- **减少开销**：链表中的每个节点需要存储一个指针，而动态数组不需要。
- **动态扩容**：在C语言中，虽然数组大小是固定的，但可以通过指针和`realloc`实现**动态扩展**。

#### **动态数组 vs 链表实现栈的对比**

| 特性         | 动态数组实现栈            | 链表实现栈                |
| ------------ | ------------------------- | ------------------------- |
| **内存布局** | 连续内存块                | 分散内存块 (通过指针链接) |
| **存取速度** | 快，支持O(1)索引访问      | 较慢，需要O(n)查找        |
| **内存占用** | 无额外指针存储开销        | 每个节点需要存储指针      |
| **扩展性**   | 需要扩容时`realloc`开销大 | 插入/删除灵活             |
| **适用场景** | 适用于存储稳定且读多于写  | 插入/删除频繁的场景       |

#### **总结**

在生产环境中，**动态数组实现的栈**是一种非常常见的做法，尤其在需要**快速访问和较少插入/删除**的场景下。相比链表，动态数组实现的栈能更好地利用**CPU缓存**，减少指针维护的开销。这种方式中的“指针实现”指的是通过指针来管理动态内存，而非使用链表。

## **链式存储栈（基于链表实现）**

- **链式栈**是一种栈的实现方式，其中每个元素作为一个节点存储在链表中。
- 栈的操作（如`push`、`pop`）直接作用于链表的头部，保证时间复杂度为`O(1)`。**相当于只能在头部操作的单链表（不带头节点）**
- 使用指针来维护节点之间的连接。**不用考虑扩容和缩容，只受内存大小限制**

**链式存储栈中的关键点**

1. **指针的作用**：每个节点中的`next`指针用于指向下一个节点，栈顶指针`top`用于指向当前栈顶节点。
2. **push操作**：插入时在链表的头部添加节点，更新`top`指针。
3. **pop操作**：删除头部节点，并更新`top`指针指向下一个节点。

**指针 vs. 链表实现的区别**

- **指针**只是用来操作内存地址的工具，而**链表实现**是一种具体的数据结构和实现方式。
- **链表实现的栈**一定会用到指针，但指针本身并不是一种完整的实现方式。

总结：链式存储栈实际上就是**基于链表实现的栈**。指针在这里是用来维护链表节点之间的关系。

### 设计思想和实现过程

核心设计理念：

```c
typedef struct {
    StackNode* top;     // 栈顶指针，指向最后进入的元素
    size_t size;        // 当前大小
    size_t maxSize;     // 最大容量
    size_t elementSize; // 元素大小
} LinkedStack;

typedef struct StackNode {
    void* data;              // 数据域
    struct StackNode* next;  // 指针域
} StackNode;
```

入栈(PUSH)操作的实现思路：

```c
StackStatus push(LinkedStack* stack, const void* data) {
    // 1. 创建新节点
    StackNode* newNode = (StackNode*)malloc(sizeof(StackNode));
    
    // 2. 将新节点插入到栈顶
    newNode->next = stack->top;  // 新节点指向原栈顶
    stack->top = newNode;        // 栈顶指针指向新节点
    
    stack->size++;  // 更新栈大小
}
```

出栈(POP)操作的实现思路：

```c
StackStatus pop(LinkedStack* stack, void* data) {
    // 1. 保存栈顶数据
    StackNode* topNode = stack->top;
    memcpy(data, topNode->data, stack->elementSize);
    
    // 2. 移动栈顶指针
    stack->top = topNode->next;  // 栈顶指针指向下一个节点
    
    // 3. 释放原栈顶节点
    free(topNode->data);
    free(topNode);
    
    stack->size--;  // 更新栈大小
}
```

实现栈结构的关键思想：

1. 使用**单链表的"头插法"**

   - 永远在链表头部（栈顶）进行操作
   - 新元素总是插入到链表的头部
   - 删除也总是删除链表的头部元素

2. 为什么这样设计能实现先进后出？

   - 想象一叠盘子：新盘子总是放在最上面（链表头部）
   - 取盘子时也总是从最上面取（链表头部）
   - 这样自然形成了后进先出(LIFO)的特性

3. 实现的优点：

   - 空间利用灵活，**不需要预先分配固定空间**
   - **插入和删除操作时间复杂度都是O(1)**
   - **可以动态扩展，只受内存限制**

4. ```c
   入栈过程：
   插入A：  A -> NULL
   插入B：  B -> A -> NULL
   插入C：  C -> B -> A -> NULL
        top
         ↓
         C -> B -> A -> NULL
   
   出栈过程：
   弹出C：  B -> A -> NULL
   弹出B：  A -> NULL
   弹出A：  NULL
   ```

这种设计的巧妙之处在于：

1. 通过维护单个栈顶指针就能实现所有操作
2. 所有操作都集中在链表头部，实现简单且高效
3. 自然符合栈的LIFO特性，无需额外的逻辑控制

总的来说，链表实现栈的核心就是：永远只对链表的头部进行操作，这样天然就形成了栈的特性。这是一个将数据结构的物理实现（链表）与逻辑特性（栈的LIFO）完美结合的例子。

#### 高度抽象

**这就相当于限制只能在链表头部操作的单链表吧？那是带头节点的还是不带头节点的？**

这个实现是不带头节点的单链表。让我解释一下原因和区别：

**1.这个实现是不带头节点的:**(不带头节点，head就是一个标识，直接指向第一个有效节点)

```c
typedef struct {
    StackNode* top;     // 栈顶指针直接指向第一个数据节点
    size_t size;        
    size_t maxSize;     
    size_t elementSize; 
} LinkedStack;
```

**2.如果是带头节点的设计会是这样:**(head虽然不存数据，但却是一个实实在在的节点，充当栈顶指针不太合适)

```c
typedef struct {
    StackNode* head;    // 头节点(不存数据)
    size_t size;        
    size_t maxSize;     
    size_t elementSize; 
} LinkedStack;
```

比较两种设计：

1. 不带头节点(当前实现)：

   1. ```c
      // 入栈
      newNode->next = stack->top;  // 新节点直接指向原第一个节点
      stack->top = newNode;        // top直接指向新节点
      
      // 判空
      return (stack->top == NULL); // 直接判断top是否为NULL
      
      // 出栈
      StackNode* topNode = stack->top;      // 直接获取第一个节点
      stack->top = topNode->next;           // top直接指向下一个节点
      ```

2. 带头节点的设计：

   1. ```c
      // 入栈
      newNode->next = stack->head->next;  // 新节点指向头节点的下一个
      stack->head->next = newNode;        // 头节点指向新节点
      
      // 判空
      return (stack->head->next == NULL); // 判断头节点的next是否为NULL
      
      // 出栈
      StackNode* topNode = stack->head->next;      // 获取头节点的下一个
      stack->head->next = topNode->next;           // 头节点指向下下个节点
      ```

为什么这里选择不带头节点？

1. 操作更直接：
   - **栈顶指针直接对应栈顶元素**
   - **不需要额外的间接寻址**
   - 代码更简洁直观
2. 内存效率：
   - **不需要额外的头节点空间**
   - **对于栈这种单端操作的结构，头节点意义不大**

概念映射更自然：

```c
不带头节点：
top -> A -> B -> C -> NULL
(直接对应栈的视觉模型)

带头节点：(head是一个实体节点，就不太直观了)
head -> A -> B -> C -> NULL
(多了一层间接关系)
```

虽然没有使用头节点，但代码通过以下方式保证了安全性：

1. size字段记录元素个数
2. 完善的空判断
3. 严格的错误处理机制
4. 指针操作的安全检查

**总结：对于栈这种只在一端操作的简单数据结构，不带头节点的设计更加简洁高效，符合"如无必要，勿增实体"的设计原则。头节点主要用于简化双端操作或环形结构的处理，在这里并不需要。**

#### 泛型编程思想

这种不明确类型的设计体现了泛型编程的思想。

void* data 的设计优势：

```c
typedef struct StackNode {
    void* data;              // 使用void指针
    struct StackNode* next;
} StackNode;
```

通用性：可以存储任何类型的数据

```c
// 可以存储不同类型
int num = 10;
push(stack, &num);          // 存储整数

char ch = 'A';
push(stack, &ch);          // 存储字符

struct Student stu = {...};
push(stack, &stu);         // 存储结构体
```

类型安全：通过elementSize保证内存操作安全

```c
// 创建栈时指定元素大小
LinkedStack* intStack = createStack(100, sizeof(int));
LinkedStack* charStack = createStack(100, sizeof(char));
LinkedStack* studentStack = createStack(100, sizeof(struct Student));

// 内存操作时使用elementSize确保正确的内存大小
memcpy(newNode->data, data, stack->elementSize);
```

LinkedStack 结构的设计优势：

```c
typedef struct {
    StackNode* top;         
    size_t size;            
    size_t maxSize;         
    size_t elementSize;     
} LinkedStack;
```

完整的状态管理：

```c
// 容量检查
bool isStackFull(const LinkedStack* stack) {
    return (stack->size >= stack->maxSize);
}

// 实际使用大小跟踪
bool isStackEmpty(const LinkedStack* stack) {
    return (stack->size == 0);
}
```

内存管理的便利性：

```c
// 创建新节点时知道要分配多少内存
newNode->data = malloc(stack->elementSize);

// 复制数据时知道要复制多少字节
memcpy(newNode->data, data, stack->elementSize);
```

#### 对比如果使用具体类型的设计

```c
// 如果指定为int类型
typedef struct IntStackNode {
    int data;                
    struct IntStackNode* next;
} IntStackNode;

// 需要为每种类型创建不同的栈结构
typedef struct CharStackNode {
    char data;               
    struct CharStackNode* next;
} CharStackNode;
```

这样做的缺点：

- 代码重复：需要为每种类型写一套完整的操作函数
- 维护困难：修改一个功能需要修改多处代码
- 扩展性差：添加新类型支持需要添加大量重复代码

使用泛型设计的实际应用示例：

```c
// 创建不同类型的栈
LinkedStack* intStack = createStack(100, sizeof(int));
LinkedStack* doubleStack = createStack(100, sizeof(double));

// 存储数据
int num = 42;
push(intStack, &num);

double pi = 3.14159;
push(doubleStack, &pi);

// 获取数据
int popNum;
pop(intStack, &popNum);

double popDouble;
pop(doubleStack, &popDouble);
```

总结设计优点：

1. 复用性：一套代码处理所有数据类型
2. 类型安全：通过elementSize确保内存操作安全
3. 维护性：修改一处即可影响所有类型
4. 扩展性：支持新类型无需修改代码
5. 灵活性：可以在运行时决定存储的数据类型

这种设计体现了"通用性"和"可复用性"的编程思想，是C语言实现泛型编程的经典方案。

#### 可移植性类型定义

`size_t` 实际上不是泛型编程的思想，而是C语言中的一个可移植性类型定义。[上面出现过](####程序解析)

**size_t的本质：**

```c
// size_t 通常在 stddef.h 中定义
typedef unsigned long size_t;  // 32位系统上通常是 unsigned int
                             // 64位系统上通常是 unsigned long
```

**size_t的设计目的：**

- 保证可以**存储系统中任何对象的大小**
- 确保在不同平台上都能正确表示内存大小和数组索引
- **始终是无符号整数类型**

**常见使用场景：**

```c
// 内存操作函数
void* malloc(size_t size);
void* memcpy(void* dest, const void* src, size_t n);

// 字符串操作
size_t strlen(const char* str);

// 数组索引
size_t i;
for(i = 0; i < array_length; i++) { ... }
```

**在这个栈结构中使用size_t的原因：**

```c
typedef struct {
    StackNode* top;          
    size_t size;            // 用于计数，永远是非负数
    size_t maxSize;         // 表示最大内存限制
    size_t elementSize;     // 存储sizeof运算符的结果
} LinkedStack;
```

比较使用size_t和其他类型：

```c
// 不好的设计
typedef struct {
    StackNode* top;          
    int size;              // 可能为负，且在大内存系统上可能不够用
    long maxSize;          // 在不同系统上长度不确定
    int elementSize;       // 可能为负，不合逻辑
} LinkedStack;

// 好的设计（当前代码）
typedef struct {
    StackNode* top;          
    size_t size;           // 保证非负，且足够存储系统支持的最大值
    size_t maxSize;        // 在任何系统上都能正确表示最大内存大小
    size_t elementSize;    // 完美匹配sizeof运算符返回类型
} LinkedStack;
```

**size_t的具体优势：**

- 可移植性：

- ```c
  // 在不同系统上自动调整大小
  32位系统: typedef unsigned int size_t;    // 通常是4字节
  64位系统: typedef unsigned long size_t;   // 通常是8字节
  ```

- 安全性：

- ```c
  size_t count = 0;
  count--;    // 会产生编译警告，因为size_t是无符号类型
  ```

- 一致性：

- ```c
  // 与系统函数返回值类型匹配
  size_t len = strlen(str);
  void* memory = malloc(len * sizeof(char));
  ```

- 实际应用示例：

- ```c
  LinkedStack* createStack(size_t maxSize, size_t elementSize) {
      // maxSize 和 elementSize 相乘不会出现负数
      // 结果也能容纳系统支持的最大值
      size_t totalSize = maxSize * elementSize;//(规定的栈的能使用的最大空间)
      
      // 检查乘法溢出
      if (maxSize != 0 && totalSize / maxSize != elementSize) {
          return NULL;  // 溢出错误处理
      }
      
      // ... 其他代码
  }
  ```

总结：

1. size_t 不是泛型编程，而是为了解决：
   - 可移植性问题
   - 内存大小表示问题
   - 数组索引范围问题
2. 使用size_t的好处：
   - 保证非负值
   - 保证足够大的取值范围
   - 与系统API保持一致
   - 提高代码可移植性
   - 防止整数溢出
3. 在栈结构中使用size_t：
   - 符合计数和大小度量的逻辑
   - 与内存操作函数参数类型匹配
   - 提供更好的类型安全性
4. 在C语言中，`size_t` 类型需要包含相关头文件才能使用。通常情况下，`size_t` 是在 `<stddef.h>` 或 `<stdio.h>` 中定义的，所以在使用它之前，需要在代码中包含这两个头文件之一。
   1. `size_t` 是一种无符号整数类型，通常用于表示对象的大小或计数，适合数组索引和内存大小等场景。

#### 调试的宏

`assert` 是一个用于调试的宏，定义在 `<assert.h>` 头文件中。它并不是 GCC 特有的，而是标准 C 语言库的一部分。`assert` 的作用是检查某个条件是否为真，如果条件为假（即为 0），程序会打印一条错误信息并终止运行。

```c
assert(stack != NULL);
```

表示在程序运行过程中，`stack` 不应该为 `NULL`，也就是指针必须有效。如果 `stack` 为 `NULL`，程序会立即终止，并输出一条错误信息，帮助你定位问题。

这是调试时常用的手段，可以在开发阶段帮助检测潜在的错误，避免程序继续运行产生更复杂的问题。不过在发布阶段，通常会定义 `NDEBUG` 来禁用所有 `assert` 检查。

**stack如果为空，就是null.**

对的！如果 `stack` 没有实例化（即为 `NULL`），则表达式 `stack != NULL` 的值为 `0`，这会导致 `assert(stack != NULL);` 触发。当 `assert` 的条件为假时（即值为 `0`），程序会输出一条错误信息并终止运行。例如，它会输出类似于以下的信息：

```c
Assertion failed: (stack != NULL), function <函数名>, file <文件名>, line <行号>.
```

这个错误信息指出断言失败的位置和原因，帮助你定位问题。

#### 整体实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>

// 错误码定义
//枚举类型，但是不是默认赋值，而是显示赋值，用户通过变量名来访问整数，机器会直接用整数来处理
typedef enum {
    STACK_OK = 0,
    STACK_EMPTY = -1,
    STACK_OVERFLOW = -2,
    STACK_NULL = -3,
    STACK_NO_MEMORY = -4
} StackStatus;

// 栈节点结构
typedef struct StackNode {
    void* data;              // 使用void指针支持任意数据类型
    struct StackNode* next;	//用来连接其他节点
} StackNode;

// 栈结构
typedef struct {
    StackNode* top;          // 栈顶指针，直接指向栈顶节点
    size_t size;            // 当前栈大小，不带头节点，必须维护这一个字段
    size_t maxSize;         // 最大容量限制，防止栈无限增长，现在只受机器内存影响，规定一个栈的最大容量
    size_t elementSize;     // 每个元素的大小，申请空间用的，作为函数参数传递
} LinkedStack;

// 创建栈（实例化并初始化）
LinkedStack* createStack(size_t maxSize, size_t elementSize) {
    //实例化一个栈
    LinkedStack* stack = (LinkedStack*)malloc(sizeof(LinkedStack));
    //无效空栈（没有实例化的栈）
    if (!stack) {
        return NULL;
    }
    
    //初始化栈中成员变量
    stack->top = NULL;//在数组实现不带头节点的单链表中，head(top)空链表（空栈）时指向-1（null）
    stack->size = 0;//因为没有头节点，size字段单独维护
    stack->maxSize = maxSize;
    stack->elementSize = elementSize;
    
    return stack;
}

// 检查栈是否为空
//就跟数组实现但单链表一样，只需要判断head是否指向-1
//size是否为0
bool isStackEmpty(const LinkedStack* stack) {
    assert(stack != NULL);//无效空栈会触发。打印错误信息
    return (stack->size == 0);
}

// 检查栈是否已满
bool isStackFull(const LinkedStack* stack) {
    assert(stack != NULL);//无效空栈会触发。打印错误信息
    return (stack->size >= stack->maxSize);//通过维护的size字段
}

// 获取栈大小
size_t getStackSize(const LinkedStack* stack) {
    assert(stack != NULL);
    return stack->size;
}

// 入栈操作
StackStatus push(LinkedStack* stack, const void* data) {
    if (!stack) {
        return STACK_NULL;
    }
    
    if (isStackFull(stack)) {
        return STACK_OVERFLOW;
    }
    
    //申请一个新栈中节点
    StackNode* newNode = (StackNode*)malloc(sizeof(StackNode));
    if (!newNode) {
        return STACK_NO_MEMORY;
    }
    
    // 为数据分配内存并复制数据
    newNode->data = malloc(stack->elementSize);
    if (!newNode->data) {
        free(newNode);
        return STACK_NO_MEMORY;
    }
    
    memcpy(newNode->data, data, stack->elementSize);
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
    
    return STACK_OK;
}

// 出栈操作
StackStatus pop(LinkedStack* stack, void* data) {
    if (!stack) {
        return STACK_NULL;
    }
    
    if (isStackEmpty(stack)) {
        return STACK_EMPTY;
    }
    
    StackNode* topNode = stack->top;
    memcpy(data, topNode->data, stack->elementSize);
    
    stack->top = topNode->next;
    free(topNode->data);
    free(topNode);
    stack->size--;
    
    return STACK_OK;
}

// 查看栈顶元素
StackStatus peek(const LinkedStack* stack, void* data) {
    if (!stack) {
        return STACK_NULL;
    }
    
    if (isStackEmpty(stack)) {
        return STACK_EMPTY;
    }
    
    //解引用复制值的方法行不通
    memcpy(data, stack->top->data, stack->elementSize);
    return STACK_OK;
}

// 清空栈
StackStatus clearStack(LinkedStack* stack) {
    if (!stack) {
        return STACK_NULL;
    }
    
    //按照无头结点单链表的结构来看，删除和插入操作都是在头部，就是先进后出的栈结构。
    //那么逐个释放栈中节点时，只需要不断把top往后移动释放即可，知道top指向null就把所有栈中节点全部释放了
    while (stack->top) {
        StackNode* temp = stack->top;
        stack->top = temp->next;
        free(temp->data);
        free(temp);
    }
    
    stack->size = 0;
    return STACK_OK;
}

// 销毁栈
void destroyStack(LinkedStack** stack) {
    if (stack && *stack) {
        clearStack(*stack);
        free(*stack);
        *stack = NULL;
    }
}

// 遍历栈（用于调试）
void traverseStack(const LinkedStack* stack, void (*printFunc)(const void*)) {
    if (!stack || !printFunc) {
        return;
    }
    
    printf("Stack content (top to bottom):\n");
    StackNode* current = stack->top;
    while (current) {
        printFunc(current->data);
        current = current->next;
    }
    printf("Stack size: %zu\n", stack->size);
}
```

#### 使用示例

```c
// 打印整数的函数
void printInt(const void* data) {
    printf("%d\n", *(const int*)data);
}

int main() {
    // 创建一个最大容量为100的整数栈
    LinkedStack* stack = createStack(100, sizeof(int));
    
    // 入栈示例
    int value = 42;
    if (push(stack, &value) == STACK_OK) {
        printf("Push successful\n");
    }
    
    // 出栈示例
    int poppedValue;
    if (pop(stack, &poppedValue) == STACK_OK) {
        printf("Popped value: %d\n", poppedValue);
    }
    
    // 清理资源
    //本来stack就已经是一个指针了，保存的是栈的首地址
    //&stack就是拿stack指针本身在内存中的地址了
    destroyStack(&stack);
    return 0;
}
```



#### 疑问

##### 压栈操作详解

```c
// 入栈操作
StackStatus push(LinkedStack* stack, const void* data) {
    if (!stack) {
        return STACK_NULL;
    }
    
    if (isStackFull(stack)) {
        return STACK_OVERFLOW;
    }
    
    //为新节点 `newNode` 申请内存,只包含void* data;struct StackNode* next;	两个指针的大小，相当于实例化两个指针而已
    StackNode* newNode = (StackNode*)malloc(sizeof(StackNode));
    if (!newNode) {
        return STACK_NO_MEMORY;
    }
    
    // 为数据分配内存并复制数据，（为实际具体数据类型申请空间）
    //并用新的data指针指向新的内存空间
    newNode->data = malloc(stack->elementSize);
    if (!newNode->data) {
        free(newNode);
        return STACK_NO_MEMORY;
    }
    
    memcpy(newNode->data, data, stack->elementSize);
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
    
    return STACK_OK;
}
```

在使用链表实现的栈中，压栈（push）操作的核心是通过动态分配节点来存储新数据，同时保持对栈顶的追踪。让我们详细分解这个操作的设计思想和实现逻辑：

1.**检查栈的状态**

- **栈的有效性**：在任何操作之前，确保栈指针 `stack` 不为空，以避免空指针异常。这在 `push` 函数的开头检查。
- **栈满状态**：使用 `isStackFull` 函数检查栈是否已达到最大容量 `maxSize`，避免超过栈的容量限制。若栈已满，返回 `STACK_OVERFLOW`。

2.**创建新节点**

- **分配节点空间**：在栈中压入新元素前，首先为新节点 `newNode` 申请内存。`newNode` 是一个 `StackNode` 结构体，包含了指向数据的指针 `data` 和指向下一个节点的指针 `next`。
- **分配数据空间并复制数据**：`newNode->data` 使用 `malloc` 动态分配内存，大小为栈中每个元素的大小 `elementSize`，确保数据在栈中能够存储任意类型。使用 `memcpy` 将传入的 `data` 数据复制到 `newNode->data`，使节点拥有自己的数据副本。

3.**将新节点链接到栈顶**

- **设置新节点的指针**：将 `newNode->next` 指向当前的栈顶节点 `stack->top`，即新节点指向原来的栈顶。
- **更新栈顶**：将 `stack->top` 更新为 `newNode`，使新节点成为新的栈顶。
- **更新栈大小**：`stack->size++`，增加栈的大小来反映新的元素数。

4.**返回操作状态**

- 如果所有操作成功完成，返回 `STACK_OK`，表示压栈成功。

栈操作的设计思想总结

这种压栈操作通过分配节点实现了栈的动态扩展，使栈可以灵活支持任意类型的数据。将 `size` 和 `maxSize` 放入 `LinkedStack` 中作为额外控制手段，可以有效管理栈容量，防止栈无限增长。

**疑问1：**

 **为新节点 `newNode` 申请内存,难道不包含void* data;struct StackNode* next;	这两个数据类型的空间大小？反而还要再为data申请一次空间？意义何在？ newNode->data = malloc(stack->elementSize);**

这是一个很好的问题。在压栈操作中，虽然我们已经为 `newNode` 申请了节点本身的空间（`sizeof(StackNode)`），但这里的 `data` 是一个指针，指向了存储实际数据的内存块。因此，为了存放数据内容而不是指针本身，我们需要额外分配空间给 `data`。

**具体原因**：

1. **`data` 是一个指针**：在 `StackNode` 结构中，`void* data` 只是一个指针，占用的内存只是指针的大小（通常是4或8字节，具体取决于系统架构），并不包含数据本身的空间。
2. **支持不同数据类型**：通过将 `data` 作为一个通用指针（`void*`），栈可以支持任意类型的数据存储，比如 `int`、`float`、`struct` 等。为了保证每次压栈操作都能存储新数据的实际内容，我们需要为 `data` 申请具体数据类型大小的内存空间，这就是 `malloc(stack->elementSize)` 的用途。`elementSize` 是数据类型的字节数，确保分配到的数据空间正好符合所需大小。
3. **数据独立性和安全性**：通过动态分配 `data` 的空间，将每个数据内容独立存储，避免了内存访问的冲突。这种做法确保压栈数据的独立性，每次压栈都会把新数据的内容复制到 `newNode->data` 中，从而不受外部数据改变的影响。

**示例说明**

举例来说，如果我们压入的是一个 `int` 类型的数据，`elementSize` 会是 `sizeof(int)`（通常为4字节）。因此，`newNode->data = malloc(stack->elementSize);` 会分配4字节的内存，而 `memcpy(newNode->data, data, stack->elementSize);` 会把传入的 `int` 数据内容复制到 `newNode->data` 所指向的空间中。

这样设计的目的是使栈既支持任意数据类型的存储，又确保数据的完整性与独立性。

**疑问2：**

所以我为新节点 newNode 申请内存，这个内存是节点结构体的大小，指针（4或8字节）加上结构体指针的大小也就是总计8字节或16字节。也就是申请的内存保存的是两个指针本身。 那么如果要想存入实际类型的大小，还是需要利用stack->elementSize得到栈元素具体需要的空间大小。在用指针data指向这个内存空间？对吗？

1. **`newNode` 的内存分配**：当我们调用 `malloc(sizeof(StackNode))` 时，实际上分配的是 `StackNode` 结构体的大小，这个大小包含两个指针——一个是 `void* data` 指针，一个是 `struct StackNode* next` 指针。它们的大小总和通常为8字节或16字节，具体取决于系统的指针大小（32位系统是4字节，64位系统是8字节）。**相当于实例化两个指针了**
2. **实际数据的存储**：**为了在 `data` 指针中存储实际的数据内容，我们还需要额外的内存分配**。这就是 `newNode->data = malloc(stack->elementSize);` 这一行的作用。这里的 `stack->elementSize` 提供了我们要存储的数据的实际字节大小，例如 `int` 是4字节，`double` 是8字节，或者是其他自定义数据结构的大小。
3. **`data` 指向新分配的数据空间**：一旦分配了足够的空间来保存数据内容，`data` 指针就指向了这个新分配的内存区域。然后，我们可以使用 `memcpy(newNode->data, data, stack->elementSize);` 将外部传入的数据内容复制到 `data` 指针所指的内存空间。

这样设计的好处是，栈可以灵活地存储不同类型的数据，而不仅仅是指针本身，保证了每个节点可以存储任意数据类型的实际内容。

**疑问3：**

在为两个指针本身和具体存储的数据类型申请空间后， data指针也已经指向了为了存储实际数据的新分配的空间。 但是这个空间是空的啊，如何把实际的数据给到这个新分配的空间呢？ 这一行的意义是不是这个？ memcpy(newNode->data, data, stack->elementSize);？？？

完全正确！这行代码 `memcpy(newNode->data, data, stack->elementSize);` 的作用正是将实际的数据复制到新分配的空间中。

**分配数据存储空间**：`newNode->data = malloc(stack->elementSize);` 这行代码只是为 `data` 指针指向的内存区域分配了空间，空间的大小是 `stack->elementSize`，但其中的内容是空的（即未初始化的数据）。

**数据复制到新空间**：`memcpy(newNode->data, data, stack->elementSize);` 正是用来将实际数据放入这块新分配的空间中。这里的 `memcpy` 函数：

- **来源**：`data` 是外部传入的数据指针，指向我们希望压入栈的数据内容。
- **目标**：`newNode->data` 是指向刚刚分配的新空间的指针。
- **大小**：`stack->elementSize` 是数据的大小，确保复制的数据刚好覆盖所需的空间，不多也不少。

假设要压入一个 `int` 类型的值 `10`，调用 `push` 时会传入指向 `10` 的 `int` 指针 `data`。在 `push` 函数中：

- 通过 `malloc(stack->elementSize)` 分配了4字节的空间（假设 `int` 为4字节）。
- `memcpy(newNode->data, data, stack->elementSize);` 会把 `data` 所指的 `10` 的内容，逐字节复制到 `newNode->data` 所指的4字节空间中。

经过这一步，`newNode->data` 指向的内存空间就持有了实际的数据内容。

##### 出栈操作详解

```c
// 出栈操作
StackStatus pop(LinkedStack* stack, void* data) {
    if (!stack) {
        return STACK_NULL;
    }
    
    if (isStackEmpty(stack)) {
        return STACK_EMPTY;
    }
    
    StackNode* topNode = stack->top;
    memcpy(data, topNode->data, stack->elementSize);
    
    stack->top = topNode->next;
    free(topNode->data);
    free(topNode);
    stack->size--;
    
    return STACK_OK;
}
```

 **疑问1：**

 **top也是StackNode*类型的指针啊？为什么不可以直接通过箭头访问结构体成员变量data?还要重新用一个topNode来操作？是为了方便释放吗？因为不用另一个变量接收，就不好给free传递参数？**

你理解得很对！使用 `topNode` 临时变量确实是为了便于释放内存资源。具体原因如下：

1. **保存栈顶节点的指针**：直接使用 `stack->top` 进行操作是可能的，**但一旦 `stack->top` 被修改或释放，原来指向的节点内存位置就会丢失。**在这里，我们将 `stack->top` 的地址存入 `topNode`，便于之后进行 `free` 操作。
2. **释放 `topNode` 节点的内存**：
   - 如果不使用 `topNode` 作为临时变量而直接操作 `stack->top`，我们在 `free` 时将会失去对原栈顶节点的引用。
   - 使用 `topNode`，先将栈顶的数据复制到 `data`，再将 `stack->top` 更新为下一个节点后，最后释放 `topNode`，保证每一步操作不会影响到其他数据。
3. **更清晰的逻辑**：通过 `topNode` 明确指向当前出栈的节点，简化了逻辑，降低了内存管理出错的风险。这种方式不仅避免了直接操作 `stack->top`，更适合栈的动态内存分配，确保出栈时可以安全地释放不再需要的节点。

因此，`topNode` 临时变量的引入确实是为了便于安全地释放节点和管理栈顶数据，避免直接修改和释放 `stack->top` 带来的不确定性。

**疑问2：**

**既然都是指针，直接把topNode->data指向data不就行了？为什么还要复制？是因为是泛型void*吗？，原因是什么？void*？如果明确指针类型是不是可以直接可以修改指向即可？**

这是一个很好的问题！让我详细解释为什么需要复制数据而不是直接修改指针指向：

**1.内存所有权问题**

```c
// 假设不复制，直接改指向
data = topNode->data;  // 这样做的问题是，当我们后面free(topNode->data)时，free的是指针指向的那块空间
                       // data指向的内存也会被释放，造成悬空指针
                       //而data指向的空间已经被free掉了，会造成弹出元素无法被访问
```

2.**生命周期管理**

- 栈内部申请的内存应该由栈自己管理(申请和释放)
- 如果直接把指针给到外部，外部就无法确定何时该释放这块内存（确实，把地址给了外部指针，外部不知何时释放）

**3.关于明确类型的情况**

```c
// 比如对于int类型的栈
typedef struct {
    int* data;
    struct StackNode* next;
} IntStackNode;

// 这种情况下确实可以直接赋值指针
*outData = *topNode->data;  // 因为类型明确，生命周期也清晰
```

**4.为什么void*需要复制**

```c
// 考虑这种使用场景
int value = 42;
push(stack, &value);  // 压入value的地址
// 如果直接使用指针，当value离开作用域，栈中存的指针就变成了悬空指针
```

正确的设计模式:

```c
int main() {
    LinkedStack* stack = createStack(10, sizeof(int));
    int pushVal = 42;
    int popVal;
    
    // 压栈时复制数据
    push(stack, &pushVal);
    // 出栈时也复制数据
    pop(stack, &popVal);
    
    // 此时popVal有自己的内存空间，不依赖栈的内存
}
```

所以总结：

1. 使用memcpy复制数据可以确保数据的所有权清晰
2. 避免内存泄露和悬空指针问题
3. 对于明确类型的栈实现，确实可以简化这个过程
4. 但对于泛型实现(void*)，复制数据是更安全的做法

这也是为什么C++的STL容器会复制数据而不是直接存指针的原因之一。

**疑问3**

按照你的说法，当void*时，也可以**outData =** topNode->data; 也可以把值取出来啊？既能保证栈内部指针不泄漏，又能把值传递出去？

不能直接使用 `*outData = *topNode->data` 这种方式，因为有以下几个原因：

**1.void指针的解引用问题**

```c
void* data = topNode->data;
*data;  // 错误：不能直接解引用void指针
        // 编译器不知道应该取多少字节的数据
```

**2.类型大小不确定**

```c
// 考虑这种情况
struct Person {
    char name[20];
    int age;
} person;

LinkedStack* stack = createStack(10, sizeof(struct Person));
struct Person outPerson;

// 如果使用 *outData = *topNode->data
// 编译器不知道应该复制多少字节
```

**3.正确的做法是使用memcpy**

```c
// memcpy知道具体要复制多少字节，因为我们在创建栈时就指定了elementSize
memcpy(data, topNode->data, stack->elementSize);
```

这就是为什么需要：

- 在创建栈时保存elementSize
- 使用memcpy而不是简单的指针操作
- 让内存操作更安全可控

所以总的来说：

- 对于泛型实现，我们必须使用memcpy这样的内存操作函数
- 因为void指针不能直接解引用，编译器也不知道要操作多少字节的数据
- 这也是C语言泛型编程的一个特点和限制

**疑问4**：

**所以当明确类型时，可以直接使用解引用的方式*outData = *topNode->data;，把值传递出去，又可以不泄漏栈内指针？ 当然类型明确时，也不能使用直接修改指针的方式，data = topNode->data;**

对的！你理解得很准确。让我用代码示例来说明：

1. **明确类型时的正确做法**：

```c
// 以int类型为例的栈节点
typedef struct IntStackNode {
    int* data;          // 明确类型为int*
    struct IntStackNode* next;
} IntStackNode;

typedef struct {
    IntStackNode* top;
    size_t size;
    size_t maxSize;
} IntLinkedStack;

// 出栈操作
StackStatus intPop(IntLinkedStack* stack, int* outData) {
    if (!stack || isStackEmpty(stack)) {
        return STACK_EMPTY;
    }
    
    IntStackNode* topNode = stack->top;
    *outData = *topNode->data;    // √ 正确：通过解引用复制值
    // outData = topNode->data;   // × 错误：会导致指针泄露
    
    stack->top = topNode->next;
    free(topNode->data);  // 正确释放栈内存
    free(topNode);
    stack->size--;
    
    return STACK_OK;
}
```

2. **使用场景示例**：

```c
int main() {
    IntLinkedStack* stack = createIntStack(10);
    
    // 压栈
    int pushVal = 42;
    intPush(stack, &pushVal);
    
    // 出栈
    int popVal;
    intPop(stack, &popVal);//站内部通过解引用复制值的方式把值传递出来，旧栈顶指针也能正确free掉
    // 此时popVal = 42，而且栈内的内存已经被正确释放
    
    // 使用popVal是安全的，因为它有自己的内存空间
    printf("%d\n", popVal);
}
```

总结：

1. ✓ 明确类型时可以用解引用方式复制值：`*outData = *topNode->data`
2. ✗ 不能直接修改指针指向：`outData = topNode->data`
3. 这样既保证了：
   - 值能正确传递出去
   - 栈内存被正确管理（不泄露）
   - 代码更简洁直观
   - 类型安全

**疑问5：**

```c
// 出栈
    int popVal;
    intPop(stack, &popVal);
```

形式参数为void* data,实际参数为&popVal，未初始化int类型变量的空间首地址。

这相当于：void* data = &popVal。所以只是传入一个地址，并不知道实际类型，所以不能用解引用复制值的方式把值传递出去，所以使用memcpy把值传递出去？

**数据复制到新空间**：`memcpy(data, topNode->data, stack->elementSize);` 正是用来将实际数据放入这块新分配的空间中。这里的 `memcpy` 函数：

- **来源**：`topNode->data` 是栈内部的栈顶数据指针，指向我们希望弹出栈的数据内容。
- **目标**：`data` 是指向刚刚外部分配的新空间的指针。（外部一个变量空间的首地址，因为作用域的关系，只传递首地址所以不知道具体类型），
- **大小**：`stack->elementSize` 是数据的大小，确保复制的数据刚好覆盖所需的空间，不多也不少。
  - 这么大小刚好弥补了不知道数据类型的缺点，知道每一个元素的大小，就可以不多不少复制到外部新变量的空间中，(`topNode->data+elementSize`)一个栈顶元素大小复制到(`data+elementSize`)这个空间中，不多不少。当天前提是外部变量的类型和elementSize类型大小一致。

**你的理解基本正确！让我帮你进一步完善和补充一些细节：**

1.**参数传递过程**：

```c
int popVal;         // 在栈上分配了一个int大小的未初始化空间
void* data = &popVal;  // 形参data接收到的是popVal的地址

// 等效于这个过程：
memcpy(&popVal, topNode->data, sizeof(int));  // 因为data = &popVal
```

**2.为什么需要elementSize：**

```c
// 创建栈时
LinkedStack* stack = createStack(10, sizeof(int));  // elementSize = sizeof(int)

// 出栈时
void* data = &popVal;  // 虽然我们知道是int，但函数内部只知道是void*,因为作用域的关系
memcpy(data, topNode->data, stack->elementSize);  // elementSize确保复制正确大小
```

**3.类型安全问题：**

```c
// 正确使用：类型匹配
LinkedStack* stack = createStack(10, sizeof(int));
int popVal;//这个变量需要与栈中元素类型所一致，为了保证memcpy复制完成
pop(stack, &popVal);  // OK：popVal空间大小 == elementSize

// 错误使用：类型不匹配（数据会丢失，popVal空间(4字节) < elementSize(8字节)，导致数据丢失，读不到正确数据，按int来读的话）
LinkedStack* stack = createStack(10, sizeof(double));
int popVal;
pop(stack, &popVal);  // 危险：popVal空间(4字节) < elementSize(8字节)
```

**4.内存布局示意：**

```c
// 假设是int类型数据
[栈内存]
topNode->data: [  4字节数据  ]
              ↓ memcpy()
[外部变量]
&popVal:      [  4字节空间  ]  

// memcpy确保：
- 源数据大小（elementSize）
- 目标空间大小（外部变量类型大小）
- 这两个要相匹配，否则会有内存问题
```

补充重点：

1. 正是因为void*不知道具体类型，所以：
   - 不能用解引用（`*data`）
   - 必须通过memcpy配合elementSize
2. 使用时要确保：
   - 创建栈时指定的elementSize
   - 实际使用时外部变量的类型大小
   - 这两者必须匹配，否则会有内存安全问题
3. 这种设计实现了泛型，但要求使用者：
   - 正确指定elementSize
   - 使用匹配的数据类型
   - 否则会有未定义行为

##### 清空栈详解

```c
// 清空栈
StackStatus clearStack(LinkedStack* stack) {
    if (!stack) {
        return STACK_NULL;
    }
    
    //按照无头结点单链表的结构来看，删除和插入操作都是在头部，就是先进后出的栈结构。
    //那么逐个释放栈中节点时，只需要不断把top往后移动释放即可，知道top指向null就把所有栈中节点全部释放了
    while (stack->top) {
        StackNode* temp = stack->top;
        stack->top = temp->next;
        free(temp->data);
        free(temp);
    }
    
    stack->size = 0;
    return STACK_OK;
}
```

**1.清空过程的步骤分解：**

```c
// 假设栈中有三个节点：A -> B -> C -> NULL
// top指向A

// 第一次循环
temp = A           // 保存当前节点A
stack->top = B    // top移向下一个节点B
free(A的data)     // 释放A节点的数据空间
free(A)           // 释放A节点本身

// 第二次循环: B -> C -> NULL
temp = B
stack->top = C
free(B的data)
free(B)

// 第三次循环: C -> NULL
temp = C
stack->top = NULL
free(C的data)
free(C)

// 循环结束：stack->top == NULL
```

**2.为什么这样做是正确的：**

```c
while (stack->top) {
    StackNode* temp = stack->top;    // 1.保存当前节点防止丢失
    stack->top = temp->next;         // 2.移动top指针到下一个节点
    free(temp->data);                // 3.释放当前节点的数据
    free(temp);                      // 4.释放当前节点
}
```

符合栈的LIFO（后进先出）特性

不会丢失节点（通过temp保存）

不会产生内存泄漏（both data和node都被释放）

不会有悬空指针（通过stack->top保持正确的链接）

**3.注意事项：**

```c
// 清空后的状态
stack->size = 0;   // 重置size为0
stack->top = NULL; // top已经在循环中设为NULL

// 此时栈回到了初始空栈状态，"但栈结构本身还在"（节点已经全部释放了，但是栈结构体本身还在）
// LinkedStack结构体本身没有被释放
```

**4.与销毁栈的区别：**

```c
// 清空栈：只清空节点，栈结构保留
clearStack(stack);  // 栈可以继续使用

// 销毁栈：清空节点并释放栈结构
clearStack(stack);  // 先清空所有节点
free(stack);       // 再释放栈结构本身
*stack = NULL;      // 防止悬空指针
```

总结：

1. 你的理解完全正确
2. 这是一个典型的链表节点释放过程
3. 通过循环依次释放：
   - 保存当前节点
   - 移动top指针
   - 释放节点数据
   - 释放节点本身
4. 最后重置size确保栈状态一致性

##### 销毁栈详解

```c
// 销毁栈
void destroyStack(LinkedStack** stack) {
    if (stack && *stack) {
        clearStack(*stack);
        free(*stack);
        *stack = NULL;
    }
}
```

**销毁栈这个判断有一点不能理解，为什么传递一个二级指针？ 判断stack和*stack的原因？**

1.**为什么需要二级指针**：

```c
// 假设只用一级指针
void destroyStack(LinkedStack* stack) {
    clearStack(stack);
    free(stack);
    stack = NULL;  // ❌ 这个修改不会影响到外部的指针！传递的是地址，又没有const关键字，为什么不会影响外部指针？？？
}

int main() {
    LinkedStack* s = createStack(10, sizeof(int));
    destroyStack(s);  // s仍然指向已释放的内存！
    // s是一个悬空指针，很危险
}
```

2.**使用二级指针的正确方式**：

```c
	// 清理资源
    //本来stack就已经是一个指针了，保存的是栈的首地址
    //&stack就是拿stack指针本身在内存中的地址了
    destroyStack(&stack);

	//传入的是stack指针本身在内存中的地址
	//那么解引用得到的是stack指针指向的栈的首地址了
void destroyStack(LinkedStack** stack) {
    clearStack(*stack);
    free(*stack);
    *stack = NULL;  // ✓ 可以修改外部指针的值

int main() {
    LinkedStack* s = createStack(10, sizeof(int));
    destroyStack(&s);  // s被设置为NULL，安全！
    // s现在是NULL，而不是悬空指针
}
```

3.**关于两个判断条件**：

```c
if (stack && *stack) {  // 为什么需要两个判断？
    // stack检查指针参数是否有效,传入的是stack指针本身在内存中的地址
    // *stack检查指针指向的栈是否有效,解引用得到的是stack指针指向的栈的首地址了
}

// 考虑以下情况：
示例中：
    // 创建一个最大容量为100的整数栈
    LinkedStack* stack = createStack(100, sizeof(int));


LinkedStack* s = NULL;
destroyStack(&s);        // 如果不检查*stack，这里会出错，怕创建不成功

LinkedStack** ptr = NULL;
destroyStack(ptr);       // 如果不检查stack，这里会出错
```

4.**完整的安全检查示例**：

```c
void destroyStack(LinkedStack** stack) {
    if (!stack) {
        return;  // 传入的指针无效
    }
    if (!*stack) {
        return;  // 栈指针已经是NULL
    }
    
    clearStack(*stack);   // 清空栈中节点
    free(*stack);        // 释放栈结构
    *stack = NULL;       // 设置外部指针为NULL
}
```

5.**使用场景**：

```c
int main() {
    // 正常情况
    LinkedStack* s1 = createStack(10, sizeof(int));
    destroyStack(&s1);  // s1 变为 NULL
    
    // 特殊情况1：栈已经是NULL
    LinkedStack* s2 = NULL;
    destroyStack(&s2);  // 安全，不会出错
    
    // 特殊情况2：传入NULL指针
    destroyStack(NULL);  // 安全，不会出错
}
```

总结：

1. 二级指针的目的：
   - 能够修改外部指针的值
   - 防止产生悬空指针
2. 双重判断的目的：
   - `stack`：确保参数指针有效
   - `*stack`：确保栈指针有效
3. 这样的设计使得函数：
   - 内存安全
   - 防止悬空指针
   - 能处理各种异常情况

**疑问2：**

```c
// 假设只用一级指针
void destroyStack(LinkedStack* stack) {
    clearStack(stack);
    free(stack);
    stack = NULL;  // ❌ 这个修改不会影响到外部的指针！传递的是地址，又没有const关键字，为什么不会影响外部指针？？？
}
```

这是关于C语言参数传递的一个重要概念！让我详细解释：

1.**参数传递的本质**：

```c
// 当我们调用函数时
LinkedStack* s = createStack(10, sizeof(int));
destroyStack(s);

// 实际上是这样的：
void destroyStack(LinkedStack* stack) {
    // stack是一个新的局部变量，它的值是s的拷贝
    // stack和s存储了相同的地址，但它们是不同的变量
    clearStack(stack);
    free(stack);    // 释放stack指向的内存
    stack = NULL;   // 只修改了局部变量stack，不影响外部的s,确实两个指针都指向用一个地址，改一个指向并不能影响另一个指针的指向
}
```

2.**为什么修改指针指向的内容可以影响外部**：

```c
void modifyData(LinkedStack* stack) {
    stack->size = 0;  // ✓ 可以修改指针"指向的内容"
    // 因为stack和外部的s指向同一块内存
}
```

3.**为什么修改指针本身不影响外部**：

```c
void modifyPointer(LinkedStack* stack) {
    stack = NULL;  // ❌ 只修改了局部变量stack
    // 外部的s保持不变
}

// 相当于：
LinkedStack* s = createStack(10, sizeof(int));
LinkedStack* stack = s;  // stack是s的拷贝
stack = NULL;           // 只修改了stack，s不变
```

4.**使用二级指针才能修改外部指针**：

```c
void destroyStack(LinkedStack** ptr) {
    *ptr = NULL;  // ✓ 通过解引用修改外部指针的值
}

// 相当于：
LinkedStack* s = createStack(10, sizeof(int));
LinkedStack** ptr = &s;  // ptr存储s的地址
*ptr = NULL;            // "通过ptr修改s的值"
```

**5.图解说明：**

```c
// 一级指针：
[s: 0x1234] -----> [堆内存: Stack结构]
[stack: 0x1234] -/  
stack = NULL;     // 只改变stack，s不变

// 二级指针：
[s: 0x1234] <----- [ptr: &s] 
*ptr = NULL;      // 通过ptr修改s的值
```

总结：

1. 函数参数是传值的：
   - 参数是外部变量的拷贝
   - 修改参数不影响外部变量
2. 一级指针可以：
   - 修改指针指向的内容
   - 但不能修改指针本身
3. 二级指针可以：
   - 通过解引用修改外部指针
   - 实现真正的指针"置NULL"操作
4. 这就是为什么`destroyStack`需要二级指针的原因

##### 指针的改指向与改指向的内容

**改变外部指针的指向 -> 需要二级指针**：

```c
void changePointer(LinkedStack** ptr) {
    *ptr = NULL;  // ✓ 改变外部指针s的指向
}

int main() {
    LinkedStack* s = createStack(10, sizeof(int));
    changePointer(&s);  // s现在指向NULL
}
```

**改变指针指向的内容 -> 用一级指针**：

```c
void changeContent(LinkedStack* ptr) {
    ptr->size = 0;     // ✓ 改变stack结构体的内容
    ptr->top = NULL;   // ✓ 改变stack结构体的内容
}

int main() {
    LinkedStack* s = createStack(10, sizeof(int));
    changeContent(s);  // s指向的内容被修改
}
```

**对比两种情况**：

```c
// 情况1：修改指针指向
void case1(LinkedStack** ptr) {
    LinkedStack* newStack = createStack(20, sizeof(int));
    *ptr = newStack;  // ✓ 改变外部指针指向新创建的栈
}

// 情况2：修改指针内容
void case2(LinkedStack* ptr) {
    ptr->maxSize = 20;  // ✓ 修改现有栈的属性
    ptr->top = NULL;    // ✓ 修改现有栈的指针成员
}
```

**常见错误示例**：

```c
// ❌ 错误：试图用一级指针改变指针指向
void wrongWay(LinkedStack* ptr) {
    ptr = NULL;  // 无效！不会影响外部指针
}

// ✓ 正确：用二级指针改变指针指向
void rightWay(LinkedStack** ptr) {
    *ptr = NULL;  // 有效！会改变外部指针
}
```

**实际应用场景**：

```c
// 销毁栈：需要改变指针指向，用二级指针
void destroyStack(LinkedStack** stack) {
    clearStack(*stack);
    free(*stack);
    *stack = NULL;    // 改变指针指向
}

// 清空栈：只需要改变内容，用一级指针
void clearStack(LinkedStack* stack) {
    while (stack->top) {
        StackNode* temp = stack->top;
        stack->top = temp->next;  // 改变内容
        free(temp);
    }
    stack->size = 0;  // 改变内容
}
```

总结口诀：

1. 改指向用二级，解引用改地址
   - 要改变指针指向谁，就需要二级指针
   - `*ptr = newValue;`
2. 改内容用一级，点运算改内容
   - 要改变指针指向的内容，用一级指针
   - `ptr->member = newValue;`

#### 与动态数组实现区别

内存分配特点：

- 按需分配：push时才申请新节点
- 即时释放：pop时立即释放节点
- 无需预分配空间
- 不存在扩容/缩容问题

这就是链式存储栈的核心优势：

1. 不需要考虑空间大小
2. 不需要扩容/缩容
3. 内存利用率高，用多少占多少
4. 操作简单直接



## 三者实现方式的区别

### 静态数组实现栈

```c
// 固定大小的数组
typedef struct {
    int data[MAX_SIZE];  // 固定大小
    int top;            // 栈顶指针
} StaticArrayStack;
```

特点:

- 空间固定,不能扩展
- 空间连续
- 可能会造成空间浪费
- 存在栈满的情况

### 动态数组实现栈

```c
typedef struct {
    int* data;          // 动态分配的数组
    int top;           // 栈顶指针
    int capacity;      // 当前容量
} DynamicArrayStack;

// 扩容操作
void resize(DynamicArrayStack* stack) {
    int newCapacity = stack->capacity * 2;
    int* newData = (int*)realloc(stack->data, newCapacity * sizeof(int));
    stack->data = newData;
    stack->capacity = newCapacity;
}
```

特点:

- 空间可以动态调整
- 需要保持空间连续
- 扩容时需要整体搬移数据
- 可以通过缩容节省空间

### 链式存储栈

```c
typedef struct StackNode {
    int data;
    struct StackNode* next;
} StackNode;

typedef struct {
    StackNode* top;    // 栈顶指针
    int size;         // 当前大小
} LinkedStack;
```

特点:

- 按需申请节点空间
- 空间不需要连续
- 不需要考虑扩容/缩容
- push/pop时分别申请/释放节点

### 操作对比

```c
// 动态数组 push 需要考虑扩容
void push(DynamicArrayStack* stack, int value) {
    if (stack->top >= stack->capacity) {
        resize(stack);  // 扩容
    }
    stack->data[++stack->top] = value;
}

// 链表 push 直接申请新节点
void push(LinkedStack* stack, int value) {
    StackNode* newNode = malloc(sizeof(StackNode));
    newNode->data = value;
    newNode->next = stack->top;
    stack->top = newNode;
}
```

### 内存使用模式

1. 静态数组:
   - [**|**|**|**|__] 固定大小
2. 动态数组:
   - [**|**|**] → [**|**|**|**|**|__] 扩容
   - [**|**|**|**|**|**] → [**|**|__] 缩容
3. 链表:
   - Node1 → Node2 → Node3 (分散的独立节点)

这就是为什么链式存储栈不需要考虑扩容问题 - 因为它的每个节点都是独立申请和释放的,不需要连续空间,也就不存在空间不足需要扩容的情况。