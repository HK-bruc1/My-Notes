# C语言学习记录8之动态库与静态库

## 动态库和静态库的产生背景与使用场景

在早期计算机发展时期，程序都是**整体编译**的。随着软件规模增大，这种方式带来了一些问题，因此催生了库的概念。

**静态库(.a/.lib)的产生:**

**背景：**

- 早期程序规模变大，编译时间长
- 重复代码在不同程序间难以共享
- 团队开发需要代码复用机制

**主要使用场景：**

- 嵌入式系统等资源受限环境
- 追求最快运行速度的程序
- 不想依赖外部环境的独立程序
- 代码安全性要求高的场景



**动态库(.so/.dll)的产生：**

**背景：**

- 静态库导致可执行文件过大
- 内存使用效率低(相同代码被多次加载)
- 程序更新维护不方便

**主要使用场景：**

- 插件机制的实现
- 需要频繁更新的模块
- 多个程序共享的公共组件
- 运行时才确定使用哪个模块的场景

让我用一个简单的例子说明二者的区别：

```c
// math_lib.h,头文件中函数声明
int add(int a, int b);
int subtract(int a, int b);

// math_lib.c 源文件中定义函数的具体实现
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

// main.c
#include "math_lib.h"//包含对应的头文件
int main() {
    int result = add(5, 3);
    return 0;
}
```

如果使用静态库：

1. 编译时math_lib.c的代码会被完整复制到最终的可执行文件中
2. 程序体积较大但运行速度快
3. 更新库需要重新编译整个程序

如果使用动态库：

1. 可执行文件中只包含对math_lib函数的引用
2. 运行时才加载库文件
3. 更新库文件不需要重新编译程序

选择建议：

1. 如果注重运行效率和独立性，选择静态库
2. 如果注重灵活性和维护性，选择动态库
3. 实际项目中常常混合使用两种方式

需要注意的是：

1. 动态库版本管理很重要，需要考虑兼容性问题
2. 静态库会导致最终程序体积增大
3. 动态库可能存在运行时找不到库文件的问题

## 抽象：用一个生活中的比喻来加深理解

**静态库就像是把菜谱上的内容直接抄写到你自己的笔记本里:**

- 本子虽然变厚了(程序体积大)
- 但查看/使用很方便快捷(运行效率高)
- 如果菜谱更新了,你需要重新抄写(需要重新编译)

**动态库则像是在笔记本里只记录"参考XX菜谱第YY页":**

- 笔记本很薄(程序体积小)
- 用的时候需要去找菜谱(运行时加载,稍慢)
- 菜谱更新后,你的笔记依然有效(无需重新编译)
- 但如果找不到菜谱就麻烦了(动态库丢失问题)

```c
// 使用静态库的程序编译后:
int main() {
    // add函数的代码已经被编译进来了
    result = add(5, 3);  // 直接调用,快速
}

// 使用动态库的程序编译后:
int main() {
    // 只有一个add函数的引用
    void* handle = dlopen("math.so", RTLD_LAZY); // 运行时加载库
    int (*add)(int,int) = dlsym(handle, "add");  // 获取函数地址
    result = add(5, 3);  // 通过地址调用
}
```

从这个角度看:

- 静态库像是"复制-粘贴"
- 动态库像是"引用-链接"

## 标准库函数

**那使用标准库中的函数，是静态还是动态？ 我本身并没有编写函数直接调用标准库中的函数**

这个问题问得很好！标准库函数(比如printf、malloc等)的链接方式实际上取决于你的编译设置和系统环境：

- 默认情况下，在大多数现代系统中：

```
#include <stdio.h>

int main() {
    printf("Hello World\n");  // 这是动态链接的
    return 0;
}
```

Linux系统下默认使用动态链接，链接到libc.so

Windows系统下默认链接到msvcrt.dll

- 你可以用`ldd`命令(Linux)查看程序依赖的动态库：

```bash
$ ldd ./a.out
linux-vdso.so.1
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6
```

- 但你也可以强制静态链接：

```c
# Linux下使用-static选项进行静态链接
gcc -static hello.c
```

这样编译出来的程序会：

- 体积更大，因为包含了所有标准库代码
- 可以在没有安装对应动态库的系统上运行
- 运行效率可能略高

混合链接：

```c
#include <stdio.h>   // 动态链接
#include "mylib.h"   // 静态链接

int main() {
    printf("Hello");     // 动态链接的函数
    myFunction();        // 静态链接的函数
    return 0;
}
```

所以简单总结：

- 标准库默认是动态链接的
- 这样可以节省磁盘空间和内存(多个程序共享一份标准库)
- 系统更新标准库后，所有程序自动使用新版本
- 但你可以根据需要改为静态链接

## 总结

**标准库一般还是动态库，如果静态库程序打包规模会变得异常大 动态库本身也是要存在的，才能够运行时调用。 静态库的话，那么就不用依赖系统是否有依赖库了？**

标准库作为动态库的例子:

```c
#include <stdio.h>
int main() {
    printf("Hello");  // libc.so中的函数
    malloc(100);      // 同样来自libc.so
    // 程序本身很小,但需要系统有libc.so
}
```

如果把标准库静态链接:

```c
# 静态编译
gcc -static hello.c -o hello_static
gcc hello.c -o hello_dynamic  # 对比动态编译

# 查看文件大小
$ ls -lh
-rwxr-xr-x 1 user user 800K  hello_static   # 体积大很多
-rwxr-xr-x 1 user user  16K  hello_dynamic  # 体积小
```

关于依赖的现实场景:

```c
# 在Linux A电脑上开发
$ gcc myprogram.c  # 默认动态链接
$ ./a.out  # 正常运行

# 拷贝到Linux B电脑后
$ ./a.out
error: cannot open shared object file: libxxx.so: No such file or directory
# 因为缺少依赖库

# 如果是静态链接的程序
$ ./static_program  # 直接就能运行,不依赖环境
```

所以选择建议:

- 普通应用程序用动态链接
  - 体积小
  - 便于系统统一升级维护
  - 内存利用率高
- 以下场景考虑静态链接:
  - 制作独立工具程序**(打开就能运行，不依赖系统环境)**
  - 部署环境不确定
  - 追求极致启动速度

你说得对,这就是为什么现在大多数系统软件都采用动态链接库的方式,既节省空间又方便维护。只有一些特殊用途的程序才会选择完全静态链接。



## 包含头文件时，只能用双引号吗？非库函数？

在 C 语言中，包含头文件时可以使用以下两种方式：

### 1. **双引号 (`"file.h"`)**

- 用于包含**自定义头文件**。
- 编译器会**优先在当前目录**查找头文件，如果找不到，再去标准库路径查找。

```c
#include "queue.h"
```

适合你的项目中自己编写的头文件，比如 `queue.h`。

### 2. **尖括号 (`<file.h>`)**

- 用于包含**标准库头文件**或在指定路径下的文件。
- 编译器**直接在系统默认路径或指定的包含路径**中查找，不会在当前目录查找。

```
#include <stdio.h>
#include <stdbool.h>
```

### **两种方式的区别**

| **方式**   | **适用场景**           | **查找路径优先级**                   |
| ---------- | ---------------------- | ------------------------------------ |
| `"file.h"` | 自定义头文件           | 当前目录 → 标准库路径                |
| `<file.h>` | 标准库头文件或第三方库 | 系统路径（如 `C:\MinGW\include` 等） |

### **在你的场景中**

- **`queue.h` 是自定义头文件**，需要使用双引号：

```c
#include "queue.h"
```

如果你想使用尖括号，也可以通过编译器的**包含路径配置**实现：

1. 在 Dev-C++ 中，打开 **项目选项**。
2. 在 **参数** -> **编译器** -> **包含路径**中，添加 `queue.h` 所在的目录。
3. 之后可以用尖括号包含：

```c
#include <queue.h>
```

### **总结**

- 自定义头文件默认使用**双引号**。
- 使用**尖括号**时，需要确保头文件在标准库路径或指定的包含路径中。