# C语言学习记录

## 基本概念

**写程序思路**

-  头文件一定要按质按量的包含，避免不必要的转换（在IDE中其实不必要担心）。

- 以函数为单位来解决问题（模块化思想）。
- 声明部分+实现部分（先声明后使用）。
- return 0;是给父进程看的（谁调用谁就是父进程）。不写retrun 0;返回的值不默认是0，看具体情况。

- 多用空格空行
- 适当添加注释

```c
/**
 *前置说明
 *
 */

//单行注释

/*多行注释*/

#if 0

大段注释,预处理不会处理此段代码
    
#endif    
```

**算法**

解决问题的**方法**。（使用流程图，NS图，有限状态机FSM）

**程序**

用某种语言实现算法。

**进程**

防止写越界，防止内存泄露，谁打开谁关闭，谁申请谁释放。



## 数据类型，运算符，表达式

### string类型

在 **C语言** 中没有 `string` 类型。在 C 语言中，**字符串（string）** 是通过字符数组 (`char[]`) 或指向字符的指针 (`char*`) 实现的。

```c
char str[] = "床前明月光";
const char* str = "床前明月光";
```

**注意**：使用 `const` 修饰字符指针是因为**字符串常量通常保存在只读内存中，直接修改会导致未定义行为。**

- 在C语言中，字符串字面量（比如 `"床前明月光"`）在内存中的位置是只读的。这意味着如果你直接将一个字符串字面量赋值给一个非`const`的字符指针，你可能会遇到未定义行为（undefined behavior），因为你可能会试图修改一个只读内存区域。
- 虽然你可以不使用`const`，但为了代码的安全性和可维护性，建议在声明指向字符串字面量的指针时使用`const`。如果确实需要修改字符串，使用字符数组或动态分配内存会更安全。
- 当你使用 `const char *` 来修饰一个字符串变量时，如果你想将这个字符串传递给一个函数，而这个函数不会修改字符串的内容，那么：
  - **函数定义**也需要使用 `const char *` 作为参数类型，以匹配你传递的参数类型。

**原因：**C语言的字符串本质上是以 `\0` 结尾的字符数组或指向字符串常量的指针。

**C语言与C++的区别：**

- 在 **C++** 中，有一个 `string` 类型定义在 `<string>` 标头文件中，提供了更多的字符串操作功能。

### 字符数组的相关问题

**字符串常量**（双引号 `"`）

```c
char str[] = "床前明月光";
```

**`"床前明月光"`** 是一个字符串常量，它会**自动添加字符串结束符** `\0`（null字符）在末尾。

这是 C 语言里 **最常用的方式**，适用于需要存储和操作整个字符串的情况。

**字符数组中的字符**（单引号 `'`）:

你也可以逐个字符初始化字符数组，但这种方式需要手动管理 `\0`：

```c
char str[] = {'床', '前', '明', '月', '光', '\0'};
```

**单引号** `'` 用来表示单个字符，而不是整个字符串。

你必须自己在数组末尾添加 `\0`，否则程序无法识别字符串结束的位置。

具体二维字符数组的定义混淆示例去三座大山看。

![img](./C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/40b321e1399f0eaea93e3128158e9209.png)

### 数据类型的表示范围

**数据类型能表示的范围由它的字节数决定**，字节数直接关系到它的**二进制位数**。以 **无符号数据类型** 为例，1 个字节等于 8 位二进制，因此它能表示的范围就是由 8 位二进制数决定的。

#### 无符号数据类型的表示范围

- 1 个字节（8 位）：二进制数的范围是从全 0 到全 1。
  - 最小值：`00000000`（即 0）
  - 最大值：`11111111`（即 255）

用公式计算的话：

- 无符号类型的范围：

  ```
  0到 2^n - 1，其中 n 是位数。
  ```

- 例如，对于 8 位二进制，范围是 `0` 到 `2^8 - 1 = 255`。

#### 简单示例

- 1 个字节无符号整数（unsigned char）的范围：
- 0 到 255，即可以表示 `256` 个不同的值。

#### 进一步说明

- 如果是 2 个字节（16 位）无符号整数，它的范围就是：
  - 最小值：`0000000000000000`（即 0）
  - 最大值：`1111111111111111`（即 `2^16 - 1 = 65535`）
  - 这就是 `unsigned short` 能表示的范围：`0` 到 `65535`。

#### 总结

- **无符号数据类型的最大值**是由所有位都为 1 决定的，最小值是所有位都为 0。
- 1 个字节的无符号整数能表示的范围就是 **0 到 255**，2 个字节就是 **0 到 65535**，以此类推。

### 进制表示方法

- 254  （默认十进制）
- B11111110  （二进制表示，**C语言不能识别二进制数**，其余三种能识别）
- 0376  （八进制）
- 0xFE  (十六进制)

### 存储机制与区别

**整数型的存储机制**主要采用的是**原码、反码、补码**三种表示方式，尤其是**补码**，它在计算机中广泛用于表示和存储有符号整数。正数和负数在存储时，使用这些编码方式的规则不同。

#### 原码、反码、补码的定义

- **原码**：直接用二进制表示数值。
  - 符号位：最高位表示符号，`0` 表示正数，`1` 表示负数。
  - 其余位表示数值的绝对值。
  - 例如：`+5` 的原码为 `00000101`（8 位表示），`-5` 的原码为 `10000101`。
- **反码**：用于负数的表示，正数的反码和原码相同，负数的反码是对原码除符号位外的所有位取反（也就是其绝对值的所有位取反再+1。   0 变 1，1 变 0）。
  - 例如：`+5` 的反码仍是 `00000101`，而 `-5` 的反码为 `11111010`。
- **补码**：是整数在计算机中的实际存储方式。正数的补码和原码相同；负数的补码是反码加 1。
  - 例如：`+5` 的补码为 `00000101`，而 `-5` 的补码为 `11111011`（反码 `11111010` 加 1）。

#### 整数型存储区别

- **正数的存储**：
  - 以 **补码** 形式存储，但补码和原码一致。
  - 例如，`+5` 在 8 位表示下的补码为 `00000101`。
  - 最高位为 `0`，表示正数。
- **负数的存储**：
  - 以 **补码** 形式存储，但与原码不同。
  - 例如，`-5` 的原码是 `10000101`，反码是 `11111010`，补码是 `11111011`。
  - 最高位为 `1`，表示负数。

#### 原本的复杂性

机器本质上只能识别**二进制**，也就是 **0 和 1**。最初我们可以直接用**原码**（符号位加数值位）来存储正负数，但在进行正负数计算时会产生复杂性，比如在加法和减法运算时需要区分处理正负数，还可能出现两种 `0`（`+0` 和 `-0`），这都增加了处理的复杂性。

**如果使用原码**进行计算，就会导致需要**区分正数和负数的运算**，从而需要**单独设计加法和减法的逻辑或电路**。这是因为原码表示的负数无法简单地通过加法器处理减法操作，负数的运算会引发复杂的处理需求。

##### 问题原因

原码是最直观的二进制表示方法，使用最高位表示符号 (`0` 表示正，`1` 表示负)，其余位表示数值。但由于原码在表示负数时，和正数的表示不同，计算正数与负数之间的运算时会产生多种复杂情况。

1. **加法操作的问题**：

- **正数加正数**：可以直接通过加法器处理，没有额外的处理需求。
- **负数加负数**：由于负数的符号位是 `1`，计算负数加法时，如果使用原码表示，就必须特别处理符号位的进位、借位问题，因为负数的计算并不像正数那样简单。
- **正数加负数**：这相当于减法运算，但如果直接使用原码表示，会导致符号位的处理复杂化。不同符号的数相加时，需要特殊处理符号位、绝对值大小的比较、借位等。

2. **减法操作的问题**：

- **正数减正数**：可以直接通过减法器处理，但需要专门的减法器电路。
- **正数减负数**：这本质上相当于加法，但由于原码直接存储负数不方便，需要专门的逻辑来处理符号位和数值。
- **负数减正数**：这是负数加负数的情况，同样需要处理符号位，减法器的设计会比较复杂。

##### 如果使用原码的系统设计

1. **加法电路设计**：
   - 需要为正数加法设计一套逻辑，正数之间的加法较为简单。
   - 但对于负数，特别是正负数相加时，**必须单独设计处理符号位的逻辑**。
2. **减法电路设计**：
   - 需要单独设计减法器来处理减法运算。
   - 处理不同符号的数相减时，还需要额外的逻辑来确定运算结果的符号和借位情况。
3. **符号和借位处理**：
   - 使用原码时，符号位和数值位分离，符号的计算与数值的加减不同步，需要额外设计符号位的处理逻辑。

##### 补码如何解决这些问题

1. **补码表示**：补码用一种特殊的方式表示负数，将正数的减法问题转化为负数加法，使得加法器可以同时处理正数和负数的运算，不需要单独的减法器。
2. **符号位处理**：通过补码的定义，负数的加法直接可以通过加法器完成，符号位的处理也被简化为加法的进位问题。
3. **硬件设计简单**：不再需要专门设计减法电路，硬件只需要一个加法器即可处理所有的加减运算。

#### 补码在计算中的应用

通过引入**补码**，我们可以将**负数的减法问题转换为加法**，从而使得：

- **减法问题变成加法问题**：`a - b` 变成了 `a + (-b)`，这里的 `-b` 是通过补码表示的负数。
- **统一使用加法器**：补码使得计算机只需要设计一个加法器，而不需要额外设计减法器，所有的整数运算都可以通过加法完成。无论是正数加正数，正数加负数，还是负数加负数，结果都可以通过加法电路处理。

由于负数用补码表示，加减法运算可以**直接使用相同的加法电路**完成。例如，`5 + (-5)` 用补码表示如下：

```
  00000101  （+5 的补码）
+ 11111011  （-5 的补码）
------------
  00000000  （结果为 0，正确）
```

#### 总结

- **正数** 和 **负数** 在计算机中都以 **补码** 形式存储。
- **正数的补码**和**原码**相同，最高位是 `0`。
- **负数的补码**是**反码加 1**，最高位是 `1`。
- 补码表示的主要优势是简化了计算过程，使得加减法等操作更高效。

为了简化计算过程和硬件设计，**引入了补码机制**。补码的主要优势是：

1. **正负数计算的统一性**：补码表示可以将减法转换为加法，统一了正数和负数的加减运算。例如，`5 - 3` 可以直接通过 `5 + (-3)` 来计算。
2. **消除 `+0` 和 `-0` 的问题**：补码表示使 `0` 只有一种形式，即 `00000000`，避免了多种表示方式。
3. **溢出处理简单**：在补码系统中，溢出的情况可以简单地通过丢弃进位位处理，使得二进制加法运算更加简单。
4. **补码机制**的引入极大简化了计算机处理负数的方式，使得负数和正数的运算都可以通过**统一的加法逻辑**或**硬件加法器**来处理，而无需额外设计专门的减法电路或逻辑。
5. 即使负数的补码形式与正数的补码形式不同，也不需要额外考虑符号处理，计算机加法器可以处理所有的整数运算。这大大简化了运算逻辑和硬件设计。

#### 浮点数存储又是怎么样的机制呢？

浮点数的表示机制与整数不同，它遵循 **IEEE 754 标准**，通过一种**科学计数法**的方式来表示数字。浮点数主要分为两种表示形式：**单精度**（32位）和**双精度**（64位），每一种表示都有自己的结构。

##### 浮点数的表示

浮点数使用二进制表示，并且通过三个部分来表示一个数字：

1. **符号位（sign bit）**：表示数值的正负。
2. **指数部分（exponent）**：表示该数字的大小范围，即对应科学计数法中的指数部分。
3. **尾数部分（mantissa 或 significand）**：表示数字的有效位数，即科学计数法中的有效数字部分。

##### IEEE 754 单精度浮点数（32位）

单精度浮点数的结构如下：

- **1位符号位**：决定数值的正负，`0` 表示正数，`1` 表示负数。

- **8位指数**：用偏移量（也称为偏置，bias）表示，用来控制浮点数的范围。指数部分使用的是 **偏移127** 的编码方式。

- **23位尾数**：表示有效数字，存储浮点数的精确部分。IEEE 754 标准中尾数部分采用了**隐含1**的规则，实际上有效数字是24位，最高位为隐含的 `1`。

  ```
  符号位（1位） | 指数部分（8位） | 尾数部分（23位）
  S        | EEEEEEEE       | MMMMMMMMMMMMMMMMMMMMMMM
  ```

  ![image-20241002183927246](./C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20241002183927246.png)**符号位**：控制正负。

  - **尾数**：相当于 `1 + M`，其中 `M` 是尾数部分。
  - **指数**：以偏移127（单精度）的方式存储，因此实际指数需要减去 127。

##### 举例说明（64位类似方法）

假设浮点数 `01000000101000000000000000000000`：

- 符号位：`0`（正数）。
- 指数：`10000001`（对应十进制 `129`），实际指数为 `129 - 127 = 2`。
- 尾数：`01000000000000000000000`，相当于 `1.01`（二进制），转换为十进制是 `1.25`。

所以这个浮点数表示的是：1.25×2^2 =5。

##### 特殊情况：零、无穷大、非数值

- **零**：符号位为 `0` 表示 `+0`，符号位为 `1` 表示 `-0`，指数和尾数部分全为 `0`。
- **无穷大（Infinity）**：指数全为 `1`，尾数为 `0`。
- **非数值（NaN）**：指数全为 `1`，尾数不为 `0`，表示计算过程中出现错误，比如 `0/0` 或者 `无穷大-无穷大`。

##### 为什么使用浮点数？

浮点数之所以采用这种结构，是为了能够表示非常大和非常小的数字，同时保持一定的精度。通过指数控制数值的大小范围，尾数控制数值的精确度，符号位决定正负。相比整数，浮点数能够表示小数、极大数和极小数，因此广泛用于科学计算、工程计算等需要处理大范围数值的场合。

##### 浮点数与整数存储的主要区别

1. **表示方式**：整数是直接存储的二进制数，浮点数则采用科学计数法表示。
2. **范围和精度**：浮点数能表示的范围远大于整数，但精度有限，特别是小数部分可能会因为尾数位数的限制而丢失精度。
3. **存储结构**：整数的表示是直接的二进制补码，浮点数需要用符号位、指数和尾数联合表示。

##### 总结

- 浮点数采用符号位、指数和尾数的组合方式来存储。
- 单精度（32位）和双精度（64位）有不同的位数分配，但都遵循 IEEE 754 标准。
- 浮点数能够表示非常大和非常小的数，通过指数控制范围，尾数控制精度。

#### 那十进制小数如何转成 IEEE 754 标准的单精度二进制？

将十进制小数转换为 IEEE 754 标准的单精度二进制浮点数表示，通常需要经过以下几个步骤。我们以一个具体的例子为导向，来详细说明这个过程。

转换步骤：

1. **将十进制小数转换为二进制表示**。
2. **将二进制数调整为科学计数法**。
3. **根据 IEEE 754 结构，计算符号位、指数部分和尾数部分**。
4. **将结果组合为最终的 IEEE 754 表示**。

我们以 **十进制数 5.75** 为例，进行详细说明。

------

例子：转换十进制数 5.75

**Step 1: 将十进制小数转换为二进制**

将十进制数 `5.75` 分为 **整数部分** 和 **小数部分**，分别转换。

- 整数部分 5

   转换为二进制：

  - 5 除以 2，余数为 1，商为 2。
  - 2 除以 2，余数为 0，商为 1。
  - 1 除以 2，余数为 1，商为 0。

从下往上写出结果：`101`（即 5 的二进制表示）。

- 小数部分 0.75

   转换为二进制：

  - 0.75 乘以 2 = 1.5，取出整数部分 1。
  - 0.5 乘以 2 = 1.0，取出整数部分 1。

将这些整数部分依次写出：`0.11`。

所以，`5.75` 的二进制表示为：

101.11

**Step 2: 将二进制数调整为科学计数法**

我们将二进制数 `101.11` 调整为二进制科学计数法的形式：

1.0111×2^2（小数点右移了两位，所以指数是 2）。

**这里是变小了，所以为了保持一致，要变大回去，所以指数是正的**

**Step 3: 根据 IEEE 754 标准结构，计算符号位、指数部分和尾数部分**

1. 符号位：

- 5.75 是正数，**符号位为 `0`**。

2. 指数部分：

- 指数部分为 **8 位**，需要加上偏移值 `127`（单精度浮点数的偏移量）。

- 实际指数为 `2`，所以存储时指数为：

  2+127=1292 + 127 = 1292+127=129

- 将 `129` 转换为二进制：
  `10000001`（这就是指数部分）。

3. 尾数部分（有效位）：

- 二进制科学计数法中的小数部分 `1.0111`，我们省略隐含的 `1`，只保留后面的 `0111`。
- IEEE 754 单精度浮点数的尾数部分有 **23 位**，所以我们将 `0111` 后面补上 `0`： 
- 在 IEEE 754 标准中，如果尾数部分不足 23 位，需要在尾数部分**后面补 `0`**。当尾数部分超过 23 位时，需要**截断多余部分**。(**跟前面区分一下，前面进制转换时，位数不足是在前面补0**)

​	01110000000000000000000

**Step 4: 将结果组合为最终的 IEEE 754 表示**

我们现在有：

- **符号位**：`0`
- **指数部分**：`10000001`
- **尾数部分**：`01110000000000000000000`

#### char型的存储机制

`char` 型在 C 语言中确实与整数型有着相似的存储机制。尽管 `char` 主要用于存储字符，但它本质上是一个**整数类型**，并且以 **1 字节（8 位）** 的形式存储数据。

**存储机制**：

- `char` 型本质上存储的是 **8 位的二进制数**，无论是用来表示字符还是整数，它的存储机制和 `int` 类型的整数存储机制类似。唯一的区别在于它的位数：`char` 占用 **1 字节（8 位）**，而 `int` 通常占用 **4 字节（32 位）**。
- 因此，`char` 在计算机中存储时会使用 **二进制补码** 的形式来表示正数和负数，跟 `int` 的存储方式相同。

**有符号与无符号 `char`**（整数时）：

 char可以有两种形式：

1. **有符号 `char`（signed char）**：范围是 `-128` 到 `127`。在这种情况下，`char` 可以表示负数，因此遵循补码存储规则。
2. **无符号 `char`（unsigned char）**：范围是 `0` 到 `255`，没有负数表示。

**字符和整数之间的转换**：

- 在 `char` 型中存储的内容，其实可以看作是一个整数。例如，字符 `'A'` 的 ASCII 值是 `65`，它在计算机中实际上是以 `65` 的二进制形式（`01000001`）存储的。这种存储方式与整数的存储机制相同。
- 也就是说，`char` 的值可以直接与整数进行转换和运算。

**补码机制**：

- 有符号 `char`使用补码来表示负数。例如：
  - `-1` 的补码表示为 `11111111`（在 8 位的 `char` 类型中），存储时与 `int` 类型的负数补码存储方式一致。
  - `127` 的补码表示为 `01111111`，是正数的补码表示。
- **无符号 `char`** 不需要考虑负数，它直接使用二进制来表示整数值。例如 `255` 的二进制是 `11111111`。

总结

- `char` 型与 `int` 型一样，都是**以二进制补码**的形式存储。
- 有符号 `char` 使用补码机制来表示负数，而无符号 `char` 仅表示正数。
- 虽然 `char` 通常表示字符，但其底层的存储和整数是一样的，只是它占用的位数少（字符转换成整数后就和整数型存储机制一样）。

##### char类型的遗漏点补充

**1.char 本质上就是一个8位(1字节)的整数类型:**

- 有符号char范围: -128 到 127
- 无符号char范围: 0 到 255

**2.char 确实可以用来存储小范围的整数值:**

```c
char x = 65;  // 完全合法
x = x + 1;    // 可以直接参与数值运算
```

**3.关于ASCII编码:**

- 每个字符在ASCII表中对应一个数值
- 比如 'A' 对应数值65

**4.在内存中的表示是完全一样的:**

```c
char x = 65;    // 二进制: 01000001
char y = 'A';   // 二进制: 01000001
// x 和 y 在内存中的表示完全相同
```

这就是为什么我们可以进行如下操作:

```c
char c = 'A';
c = c + 1;        // 'A'(65) + 1 = 'B'(66)
printf("%c", c);  // 输出字符'B'
```

**所以char确实经常被用作小范围整数的存储类型,特别是在需要节省内存的场合。不过使用时要注意范围限制,防止溢出。(单片机设备性能有限)**



**ascii表是不是把有符号的char范围用完了？ 如果你使用单引号的话，计算机就按ascii表去转换为二进制。 如果直接赋值整型数值的话，计算机就把十进制转换为二进制？**

**ASCII表的范围:**

- ASCII表只使用了0-127这128个数值
- 这只占用了char的一半范围
- 所以ASCII没有用完有符号char的范围(-128到127)
- 无符号是0到255

关于编码转换:

```c
// 使用单引号 - 编译器查ASCII表
char c = 'A';    // 编译器看到'A',查表得到65,存储为 01000001

// 直接数值 - 直接转换为二进制
char x = 65;     // 编译器直接将65转换为二进制 01000001
```

扩展ASCII(128-255)和负值范围:

```c
// 128-255需要用无符号char
unsigned char c1 = 200;  // 合法
char c2 = 200;          // 溢出,因为有符号char最大127

// 负值范围(-128到-1)
char n = -50;           // 合法,用补码表示
```

一些有趣的例子:

```c
char c = 'A';      // 65
printf("%d", c);   // 输出65
printf("%c", 65);  // 输出'A'

// 超出ASCII范围的值就不对应任何标准字符
char x = 128;      
printf("%c", x);   // 输出可能是乱码
```

所以你说得对:

- 单引号方式是通过ASCII表进行转换
- 直接数值方式是直接进行二进制转换
- 但最终在内存中的表示是一样的

只要记住: ASCII只占用了0-127这个范围,而char的完整范围要大得多。**这就是为什么char既可以用来表示字符,也可以用来存储小范围的数值。**

#### 数据溢出

##### **环形结构的理解**

将数据类型的表示范围看作一个环形结构，可以帮助我们更好地理解溢出：

- **数据类型的范围**：比如一个 8 位有符号整数，其范围是从 -128 到 +127。

  - 如果我们达到最大值 127，再加 1 就会回到最小值 -128。
  - 如果我们达到最小值 -128，再减 1，就会回到最大值 127。

  这个环形结构意味着数据值不会无限增加或减少，而是在达到范围的边界时，自动回绕到对面的边界。

##### **溢出的计算方式**

**正向溢出**：

- 当你 **向正方向增加**，并超出数据类型的最大值时，数据会“绕回”到最小值，然后继续增长。

- 比如一个 8 位有符号整数（-128 到 127）：

  - 如果你从 127 增加 1，结果会变成 -128。
  - 你可以把它看作是“环绕”了一圈回到了最小值。

  **处理正向溢出的方法**：

  - 如果值超出了最大值（例如 128 超过了 127），你就减去该数据类型的总个数（在这个例子中是 256，`2^8`）。
  - 然后继续检查结果是否在范围内。如果不在范围内，继续减去 256，直到结果位于合法范围内。

**反向溢出**：

- 当你 **向负方向减少**，并超出数据类型的最小值时，数据会“绕回”到最大值，然后继续减少。

- 比如对于 8 位有符号整数：

  - 如果你从 -128 减少 1，结果会变成 127。

  **处理反向溢出的方法**：

  - 如果值超出了最小值（例如 -129 超过了 -128），你就加上该数据类型的总个数（在这个例子中是 256）。
  - 然后继续检查结果是否在范围内。如果不在范围内，继续加上 256，直到结果位于合法范围内。

##### **总结**：

- **环形结构**：可以将数据类型的取值范围想象为一个闭环。到达一个极限时，超出该极限的数据会“回绕”到另一个极限，继续计算。

- 溢出后的处理：

  - **正向溢出**：超出最大值后，减去该数据类型的总个数（如 256），直到结果在合法范围内。
- **反向溢出**：超出最小值后，加上该数据类型的总个数（如 256），直到结果在合法范围内。

##### 环形数据结构注意事项

环形结构确实适用于无符号整数和有符号整数，但它们处理溢出的方式有所不同：

- **无符号整数（Unsigned Integers）**：

  - 无符号整数在进行加法或减法时确实表现出环形结构。无论是加到最大值（如 `UINT_MAX`）然后再加1，还是减到0然后再减1，都会无缝地循环到另一个极端。这种行为是定义明确的，不会导致未定义行为。

  - ```c
    unsigned int x = UINT_MAX;
    x = x + 1; // x 变为0
    x = x - 1; // x 变为 UINT_MAX
    ```

- **有符号整数（Signed Integers）**：

  - 有符号整数也有类似的环形结构，但其行为在C语言标准中被定义为未定义行为或实现定义行为

    。这意味着在不同的编译器或硬件平台上，溢出行为可能不同：

    - 在一些平台上，可能实现了环形结构的行为，即当达到`INT_MAX`时再加1会变成`INT_MIN`，当达到`INT_MIN`时再减1会变成`INT_MAX`。

    - 在其他平台上，溢出可能导致程序崩溃、产生不可预测的结果或者编译器可能进行优化，假设溢出不会发生。

    - ```c
      int x = INT_MAX;
      x = x + 1; // 可能变为 INT_MIN 或导致未定义行为
      x = INT_MIN;
      x = x - 1; // 可能变为 INT_MAX 或导致未定义行为
      ```

- 因此，**虽然有符号整数在某些实现上可能表现出类似于无符号整数的环形结构，但这种行为不是标准C语言的一部分，在不同的环境下可能不一致或不可预测。无符号整数的环形行为是标准定义的，所以在需要循环计数或时间计数等场景下使用无符号整数更为安全和可靠。**

### 不同类型数据间的转换

```c
int i
float f
double d
char ch
```

#### 隐式转换

```c
ch + i —> i

f -d —> d

(ch + i) - (float - double)

int  -  double

double
```

当不显示指定数据类型时，默认向字节数高的（精准度高的靠拢）

这种自动类型提升的规则叫"整型提升"(Integer Promotion)和"算术转换"(Arithmetic Conversion),遵循以下基本原则:	

向更高精度转换(转向字节数更大或表示范围更大的类型):

```c
int a = 10;
double b = 3.14;
// a + b 的结果是 double 类型,a会被提升为double
```

基本转换层次(从低到高):

```c
char/short -> int -> unsigned int -> long -> unsigned long -> float -> double -> long double
```

一些具体例子:

```c
// 例1: char和int运算
char c = 'a';    // 1字节
int i = 10;      // 4字节
// c + i 结果为int类型

// 例2: float和double运算
float f = 3.14f;  // 4字节
double d = 2.0;   // 8字节
// f + d 结果为double类型

// 例3: 不同整型运算
short s = 10;     // 2字节
long l = 20;      // 8字节
// s + l 结果为long类型
```

注意事项:

- 如果无符号类型的范围大于有符号类型,结果是无符号类型
- 小于int的整型(如char,short)在运算前会先转换为int
- 在赋值时,如果目标类型范围小于源类型,可能会发生数据截断

常见的特殊情况:

```c
float f = 3.14;
int i = f;    // 会发生截断,小数部分丢失

int a = 32767;
short s = a;  // 如果short是16位,可能发生溢出
```

**所以在不指定运算结果类型的前提下，运算前会先进行类型转换再进行运算是吗？**

在C/C++中,当进行混合类型运算时,会按照以下顺序执行：

1. 首先进行运算前的类型转换(类型提升)
2. 然后用转换后的类型进行运算
3. 最后得到运算结果(结果类型是转换后的类型)

```c
// 例1：整数和浮点数运算
int a = 10;
double b = 3.14;
// 运算过程：
// 1. 先将a(int)转换为double
// 2. 然后进行double类型的加法运算
// 3. 结果类型为double
auto result1 = a + b;    // result1是double类型

// 例2：short和int运算
short s = 10;    // 2字节
int i = 20;      // 4字节
// 运算过程：
// 1. 先将s(short)转换为int
// 2. 然后进行int类型的加法运算
// 3. 结果类型为int
auto result2 = s + i;    // result2是int类型

// 例3：有符号和无符号混合运算
int x = -6;
unsigned int y = 4;
// 运算过程：
// 1. 先将x(int)转换为unsigned int
// 2. 然后进行unsigned int的加法运算
// 3. 结果类型为unsigned int
auto result3 = x + y;    // result3是unsigned int类型
```

这就解释了为什么有时候运算结果会出现意外：所有的转换都是在运算之前完成的，而不是先运算再转换。这个规则的理解对于避免程序中的类型转换相关bug非常重要。

#### 显示转换（强制类型转换）

强制类型转换(Type Casting)是程序员明确指定的类型转换。在C/C++中有几种不同形式的强制转换：

```c
// 基本语法: (目标类型)表达式
int a = 10;
double b = 3.14;

// 强制将运算结果转为int
int result1 = (int)(a + b);    // 13 (小数部分被截断)

// 先进行类型转换再运算
int result2 = (int)a + (int)b; // 13 (3.14被转成3后再加10)
```

强制转换的注意事项：

```c
// 1. 数据截断
double d = 3.99;
int i = (int)d;    // i = 3，小数部分被截断

// 2. 溢出问题
long long big = 1234567890LL;
short small = (short)big;   // 可能溢出

// 3. 符号转换
int negative = -5;
unsigned int positive = (unsigned int)negative; // 变成很大的正数

// 4. 精度损失
float f = (float)12345.6789;  // 可能损失精度
```

与隐式转换的区别：

```c
// 隐式转换：编译器自动完成
double d = 3.14;
int i = d;    // 编译器自动转换，可能有警告

// 显式转换：程序员明确指定
int j = static_cast<int>(d);    // 明确表明转换意图
```

### 特殊性

#### volatile关键字

1. **防止编译器优化**：
   - 当一个变量被声明为`volatile`时，编译器不会对这个变量进行优化。它会**确保每次访问这个变量时，都从内存中读取最新的值，而不是使用寄存器中的缓存值。这对于硬件寄存器、内存映射的I/O端口**或多线程编程非常重要。
2. **内存可见性**：
   - 虽然C语言没有像Java那样的内存模型，但`volatile`可以确保变量的变化对所有线程都是可见的。在多线程环境中，如果一个变量被`volatile`修饰，那么对**这个变量的修改会立即反映到内存中，其他线程读取时会看到最新的值。**
3. **防止编译器重排序**：
   - 编译器可能会对代码进行指令重排序以提高性能，但对于`volatile`变量，编译器会遵循其定义的顺序来处理访问，从而防止不希望的重排序。
4. **适用场景**：
   - **硬件寄存器和I/O端口**：访问硬件寄存器或内存映射的I/O端口时，因为这些值可能会被硬件改变。
   - **中断服务程序**：在中断服务程序中使用`volatile`，确保中断处理程序对变量的修改在主程序中是可见的。
   - **多线程环境**：当一个变量可能被多个线程同时访问时，可以使用`volatile`确保变量的可见性。
5. **注意事项**：
   - `volatile`并不保证原子性操作。对于需要原子操作的场景（如计数器），`volatile`是不够的，需要使用更高级的同步机制。
   - `volatile`也不能替代正确的同步机制，它主要是用来告知编译器如何处理变量，而不是提供线程安全性。

总之，在C语言中，`volatile`关键字主要用于处理需要特殊内存访问的变量，**确保变量的变化能够被及时反映**，并且防止编译器对这些变量进行不当的优化。使用`volatile`时，程序员需要明确其作用和适用场景，确保代码的正确性和可靠性。

#### bool布尔类型

**C语言的bool类型的声明和使用，我记得好像没有true 和false的关键字？**

C语言最初确实没有内置的布尔(bool)类型和true/false关键字。让我解释一下C语言中处理布尔值的几种方式：

1.传统C语言中：

```c
// 通常用整数表示布尔值
int flag = 0;  // 相当于false
int flag = 1;  // 相当于true

// 在条件判断中，0为假，非0为真
if(flag) {
    // flag不为0时执行
}
```

2.使用宏定义：

```c
#define TRUE 1
#define FALSE 0

int flag = TRUE;
if(flag == TRUE) {
    // 执行代码
}
```

3.C99标准后，可以使用<stdbool.h>头文件：

```c
#include <stdbool.h>

bool flag = true;   // 现在可以使用true
bool flag2 = false; // 和false关键字了

if(flag) {
    // 执行代码
}
```

建议：

1. 如果使用的是C99或更新的标准，推荐使用<stdbool.h>，代码更清晰易读
2. 如果需要考虑兼容性，可以使用宏定义或整数0/1
3. 注意在条件判断中，任何非0值都被视为真，不一定非要是1

**但是我使用时，可以使用_bool作为函数返回值类型，但是不能返回true和false，只能0和1？**

_Bool 是C99引入的内置布尔类型（stdbool.h 中的 bool 实际上是 _Bool 的typedef）。虽然 _Bool 是布尔类型，但在C语言中它本质上仍然是一个整型，只是被限制为只能存储 0 或 1。

```c
// 方法1：直接使用 _Bool
_Bool checkNumber(int num) {
    return num > 0;  // 会自动转换为 0 或 1
}

// 方法2：如果想要使用 true/false，需要包含 stdbool.h
#include <stdbool.h>

bool checkPositive(int num) {
    return num > 0;  // 仍然是返回 0 或 1
}

// 使用示例
int main() {
    _Bool result1 = checkNumber(5);    // result1 = 1
    _Bool result2 = checkNumber(-5);   // result2 = 0
    
    // 如果包含了 stdbool.h，可以这样比较
    if (result1 == true) {  // 虽然可以这样写，但实际上 true 就是 1
        // ...
    }
}
```

重要说明：

1. true 和 false 是 stdbool.h 中定义的宏，分别代表 1 和 0
2. _Bool 类型的变量只能存储 0 或 1
3. 给 _Bool 类型赋值时，非零值会被转换为 1，零值会被转换为 0
4. 从技术上讲，即使包含了 stdbool.h，返回值在底层仍然是 0 或 1

实用建议：

```c
#include <stdbool.h>

bool isValid(int num) {
    // 这些写法都是等价的：
    return num > 0;        // 推荐：直接返回条件表达式
    // return (num > 0) ? true : false;  // 可行但啰嗦
    // return (num > 0) ? 1 : 0;         // 可行但不推荐
}
```

所以简单来说：是的，从函数返回时本质上返回的是 0 或 1，这是 C 语言处理布尔值的基本方式。即使使用了 stdbool.h，true/false 本质上也只是 1/0 的别名。

这样设计是为了保持与C语言的传统行为兼容，其中条件判断一直是用整数值（0 表示假，非 0 表示真）来实现的。

**像枚举类型一样了，通过变量名访问整型？**

对,您理解得很准确! `true`/`false` 确实有点类似枚举类型的实现方式。让我们对比一下：

```c
// 枚举类型的定义和使用
enum Status {
    FAIL = 0,
    SUCCESS = 1
};

// stdbool.h 中的实现原理类似于：
#define false 0
#define true 1
#define bool _Bool   // bool 是 _Bool 的别名

// 两种方式的使用对比
void example() {
    // 枚举方式
    enum Status s1 = SUCCESS;    // s1 = 1
    
    // 布尔方式
    _Bool s2 = true;            // s2 = 1
    bool s3 = true;             // 如果包含了 stdbool.h
    
    // 本质上都是在操作整数
    printf("%d %d %d\n", s1, s2, s3); // 输出: 1 1 1
}
```

主要相似点：

1. 都是给整数值取了一个更有意义的名字
2. 编译后都会被转换为整数值
3. 都是为了提高代码的可读性和维护性

主要区别：

1. 枚举类型可以定义多个值，而布尔值就只有 true(1) 和 false(0)
2. 枚举类型的值可以自定义，布尔值固定为 0 和 1
3. _Bool 类型的变量赋值时会自动转换为 0 或 1，而枚举变量则保持原值

所以从实现机制来说，确实很像是一个只有两个值的特殊枚举类型！这种理解方式有助于我们更好地掌握 C 语言中布尔类型的本质。



#### float类型

```c
int func(float f)
{
	if(f < 0)	
		return -1;
    else if(f == 0)
     	 return 0;
    else
    	 return 1;
}
```

float类型的数没办法真正的比较是否与一个数相等。只能让他跟一个数的误差很小来对比：

|f - 0| <= 10^-6

0.000001

#### char型是否有符号（是未定义行为）

**在 C 语言中，`char` 类型的符号性（有符号或无符号）是由具体的编译器实现决定的，并不是语言本身明确规定的**。因此，在某些系统中，`char` 默认是有符号的，而在另一些系统中，它可能是无符号的。

**`char` 类型的符号性在 C 标准中是未定义的**：

- C 语言标准定义了三种字符类型：
  1. **`char`**
  2. **`signed char`**
  3. **`unsigned char`**
- `signed char` 和 `unsigned char` 明确规定了符号性：`signed char` 是有符号的，`unsigned char` 是无符号的。
- **`char`** 本身没有明确规定是有符号还是无符号。这意味着 `char` 的符号性是由具体的编译器来决定的。
  - 某些编译器将 `char` 视为 **有符号的**，因此其取值范围是 `-128` 到 `127`。
  - 其他编译器可能将 `char` 视为 **无符号的**，其取值范围是 `0` 到 `255`。

**这导致了在不同平台上行为可能不同**：

- 在某些系统中，如果你定义了一个 `char` 类型变量，它会被当作 `signed char` 处理，其他系统可能会当作 `unsigned char`。
- 这种不确定性会在跨平台开发中引发问题，尤其是在比较 `char` 类型的值时，可能会导致意想不到的结果。

**未定义行为解释**

“未定义行为”在 C 语言中的意思是：如果代码依赖于编译器未定义的特性（如 `char` 的符号性），那么程序的行为可能是不确定的，编译器可以根据自己的实现做不同的处理。

**举个例子**

假设在一个编译器中 `char` 被视为有符号的，而在另一个编译器中它被视为无符号的：

```c
char a = 200;
printf("%d", a);
```

如果 `char` 是 **有符号的**，那么 `200` 超出了有符号 `char` 的范围（`-128` 到 `127`）。在这种情况下，`200` 可能会被解释为负数（补码机制），结果可能会输出负值。

如果 `char` 是 **无符号的**，则 `200` 是合法的无符号 `char` 值，程序会正常输出 `200`。

**避免问题的做法**

为了避免这种符号性带来的未定义行为，最好明确使用 **`signed char`** 或 **`unsigned char`**，而不是直接使用 `char`，尤其是在跨平台或需要处理负数的场景中。

##### 总结

- `char` 的符号性（有符号还是无符号）是编译器定义的，C 语言标准并未明确规定。
- 在不同平台或编译器下，`char` 的符号性可能不同，这会导致行为的不确定性，称为未定义行为。
- 为了避免这种问题，建议明确使用 `signed char` 或 `unsigned char`，而不是依赖于默认的 `char` 符号性。

#### 不同形式的0值

##### 区别总结

| 形式   | 含义                   | 类型     | ASCII 值（十进制） | 用途                       |
| ------ | ---------------------- | -------- | ------------------ | -------------------------- |
| `0`    | 整数 0                 | `int`    | 无                 | 数值运算、条件判断         |
| `'0'`  | 字符 '0'               | `char`   | 48                 | 单个字符操作，如输入、输出 |
| `"0"`  | 包含字符 '0' 的字符串  | `char[]` | `'0'` = 48         | 字符串处理，如比较、拼接   |
| `'\0'` | 空字符，字符串结束标志 | `char`   | 0                  | 用于表示字符串的结束位置   |

##### 小结

- **`0`** 是整数 `0`，主要用于数值计算。
- **`'0'`** 是字符 `'0'`，ASCII 值为 48，主要用于字符操作。
- **`"0"`** 是包含字符 `'0'` 的字符串，常用于字符串操作。
- **`'\0'`** 是空字符（NUL），用于字符串结尾。

#### 数据类型与后续代码中所使用的输入输出要相匹配

在 C 语言中，**数据类型与输入输出格式必须匹配**，否则可能会出现**数据丢失、精度丢失或错误输出**的情况。

##### **输入输出函数匹配性**

- 在 C 语言中，使用 `printf()` 输出数据或 `scanf()` 输入数据时，**格式化字符串**（如 `%d`、`%f` 等）需要与变量的数据类型匹配。
- 如果数据类型和格式化字符串不匹配，可能会导致以下问题：
  - **错误的输出结果**：输出的值与预期不符。
  - **数据精度丢失**：如果类型不匹配，高精度数据（如浮点数）会被截断，损失精度。
  - **内存问题或崩溃**：在一些情况下，不匹配的数据类型会导致程序崩溃或产生未定义行为。

##### **常见的匹配错误及后果**

- 整数与浮点数的混用：
  - 假设你将一个 `int` 类型的变量用作 `float` 类型的输出：

```c
int x = 10;
printf("%f", x);  // 错误：int 类型使用了 %f 格式化符
```

这可能会输出垃圾值，甚至导致程序崩溃，因为 `%f` 期望的是一个浮点数的内存布局，而 `int` 的内存布局不同。

- **浮点数与整数的混用**：
  - 同样，如果你用 `%d` 输出一个浮点数，会导致精度丢失，甚至错误的输出：

```c
float y = 5.5;
printf("%d", y);  // 错误：float 类型使用了 %d 格式化符
```

这会丢失小数部分，或者输出意料之外的结果。

##### **数据转换与精度丢失**

如果数据类型不匹配，尤其是在数据类型转换时，可能会导致**精度丢失**，尤其是在以下两种场景中：

- **浮点数转换为整数**：
  - 当浮点数被强制转换为整数时，小数部分会被截断，导致精度丢失。

```c
float a = 3.14;
int b = (int)a;  // b 的值将为 3，小数部分被截断
```

此时，小数部分 `0.14` 被丢失，最终的值是 `3`

- **使用不合适的格式化符**：
  - 如果你用错误的格式符来输出一个高精度的浮点数，也会丢失精度。例如，`double` 类型使用 `%f` 输出时，默认只显示 6 位小数，更多精度会被截断。

```c
double pi = 3.14159265358979;
printf("%f", pi);  // 结果只输出 3.141593，精度丢失
```

##### **整数溢出**

数据类型不匹配还可能导致**整数溢出**问题。例如，使用一个 `short` 类型存储超出其范围的值时，会导致值被截断或溢出：

```c
short s = 32767; // short 的最大值
s = s + 1;       // 溢出，s 变成 -32768
```

##### **正确的数据类型匹配和转换**

- 当进行类型转换时，如果可能导致精度丢失，C 语言不会发出警告，因此需要开发者自己确保匹配性。例如，`float` 转换为 `int` 时应明确使用显式转换。
- 在输入输出时，确保使用正确的格式化符：
  - **`%d`** 用于 `int` 型整数。
  - **`%f`** 用于 `float` 和 `double` 型浮点数（`double` 需指定精度）。
  - **`%c`** 用于 `char` 型字符。
  - **`%s`** 用于字符串（`char[]`）。

##### 输入格式不太匹配的问题

在 C 语言中，`scanf` 可以用来接收整型并存入一个 `char` 类型的变量，但需要注意以下细节：

**类型匹配问题**

使用 `scanf` 时，格式说明符必须与变量类型匹配。如果你尝试使用 `%d` 来读取一个整型数并存入 `char` 类型的变量，`scanf` 本身不会报错，但这是不安全的，因为整型数可能会超出 `char` 的存储范围（通常是 `-128` 到 `127` 或 `0` 到 `255`，取决于 `char` 是有符号还是无符号）。

```c
char c;
scanf("%d", &c);  // 格式匹配%d，但变量是char，可能会导致问题
```

在这种情况下，超出 `char` 范围的值可能会被截断，导致未定义行为。

**直接给 `char` 赋值整型**

`char` 本质上是一种特殊的整型（整数类型），它的大小通常为一个字节（1 字节 = 8 位）。因此，你可以直接将一个整型数赋值给 `char` 类型的变量，编译器会自动进行截断。例如：

```c
char c;
c = 300;  // 假设char是有符号的，300超出了范围，实际存储的值可能是 300 % 256 = 44
```

赋值时，如果整型数超出了 `char` 的范围，较高位会被丢弃，只保留最低的 8 位。

**正确使用 `scanf` 和 `char`**

如果你确定输入的数字不会超出 `char` 的范围，可以使用 `%hhd` 来读取一个整型并存入 `char` 类型变量：

```c
char c;
scanf("%hhd", &c);  // %hhd 表示“短整型”，适用于char类型
```

`%hhd` 是专门用于读取 `char` 类型变量的格式说明符，它可以确保类型匹配。

##### 总结

- **数据类型与输入输出格式需要匹配**，否则会导致**错误的输出或输入**，并可能产生**精度丢失**或**未定义行为**。
- 不同类型之间的转换要小心处理，尤其是浮点数转整数时，确保你理解会发生的**精度损失**。
- 养成使用合适的格式化符（如 `%d`、`%f` 等）的好习惯，确保代码的可移植性和正确性。

### 常量和变量

#### **常量：在程序执行过程中值不会发生变化的量**

分类：整数常量，实型常量，字符常量，字符串常量，标识常量

- 整数常量：1，250，52，

- 实型常量：3.14，5.26，1.9999

- 字符常量：由**单引号**引起来的单个的字符或转义字符，如‘a’,‘X’，‘\n’,‘\t’,‘\015’,‘\x7f’

- 字符串常量：由**双引号**引起来的一个或多个字符组成的序列，如“a”, “aAc”，“”，“abc\n\021\018”(注意划分是哪一种转义字符)

- 标识常量：

  - 使用时用PI，预处理时他会把所有的PI换成3.14。**不做语法检查，只是替换**。可以实现一改全改。
  - 如果有运算符宏体记得加括号
  - 还可以带参数的形式，往里面传入参数，参数也可能有运算符也要考虑优先级，所以参数也要带括号
  - 函数也可以实现（占用运行时间），用宏（占用编译时间），宏不太安全和稳定，但是可以减少运行时间
  - 内核对宏的使用已经到极致了，不会有更复杂的写法了。

  ```c
  #define 宏名  宏体
  //定义常量
  #define PI 3.14
  //带参数的宏
  #define MAX(a,b)  ((a) > (b) ? (a) : (b)) 
  ```

- 常量无法出现在赋值的左边

#### **变量：用来保存一些特定内容，并且在程序中执行过程中值随时可能变化的量**

[存储类型]   数据类型   标识符  =  值

type name = value；

- 标识符：由字母，数字，下划线组成且不能以数字开头的一个标识符序列。（给某一块空间起的名字，给人看的，要做到见名生义）
- 数据类型：基本数据类型+构造类型
- **存储类型：auto  static  register  extern(说明型)，前三个为定义型**
  - auto：默认，自动分配空间，自动回收空间。`auto` 是局部变量的默认存储类型，**只能在函数内使用**
    - 在函数外部定义的变量是**全局变量**，默认存储在**静态存储区**（即数据区），即使使用`auto`修饰也是如此。**注意**：在C语言中，**全局作用域的变量不能使用`auto`修饰**，因为`auto`只能用于局部变量。
  - register：（建议型，寄存器太珍贵）寄存器类型，此变量要高频繁的用，就建议放在寄存器中，减少获取时间（但是GCC不一定会放），只能定义局部变量，不能定义全局变量，大小有限制，只能定义32位大小的数据类型，如double就不行，寄存器没有地址，所以一个寄存器类型的变量没办法打印出地址查看或使用
  - static：静态型，自动初始化为0值或空值，并且其变量的值具有继承性，另外常用于修饰变量或函数（**使作用域限定在当前源文件.c中**）
  - extern：说明型，意味着不能改变被说明的变量的值或类型。就是说我在mian.c文件中定义了一个全局变量i,那么我在proj.c中要用，我就可以extern int i;告诉GCC去其他地方找。**全局变量**的存储类型默认是 `extern`，即使你不显式使用 `extern` 关键字，全局变量也是默认对编译单元（即源文件）外部可见的。

#### 全局变量与static修饰的变量的区别

在C语言中，全局变量和`static`修饰的变量虽然都可以在同一个源文件中使用，但它们的作用域和链接属性不同，具体区别如下：

1.**全局变量**

- **定义方式**: 在**函数外（包括main函数）**定义变量，未加`static`修饰。

- **作用域**: 在**整个程序范围内**（即跨多个源文件）可见，只要在其他文件中通过`extern`声明，就可以访问该变量。

- **链接属性**: **外部链接（external linkage）**。意味着它在其他源文件中是可见的，可以在不同的源文件之间共享。

- 特点:

  - 对于任何引用了该变量的源文件，只需使用`extern`声明即可访问。
  - 适合存储程序的公共状态。

- ```c
  // file1.c
  int globalVar = 10;  // 全局变量，外部链接
  
  // file2.c
  extern int globalVar;  // 引用 file1.c 中的全局变量
  ```

2.**`static`修饰的变量（静态全局变量）**

- **定义方式**: 在函数外部定义变量，并加`static`修饰。

- **作用域**: **仅限当前源文件**（编译单元）内可见。

- **链接属性**: **内部链接（internal linkage）**。意味着它在**当前源文件**之外不可见，无法在其他源文件中通过`extern`引用。

- 特点:

  - 仅能在定义它的源文件中使用，无法被其他文件共享。
  - 用于限制变量的访问范围，**防止命名冲突**。

- ```c
  // file1.c
  static int staticVar = 20;  // 静态全局变量，仅 file1.c 内部可见
  
  // file2.c
  extern int staticVar;  // 错误！file2.c 无法访问 file1.c 中的静态全局变量
  ```

3.**适用场景**

- **全局变量**: 用于需要在多个源文件中共享状态的场景。
- **`static`静态全局变量**: 用于隐藏变量的实现细节，避免跨文件的命名冲突。

#### static局部变量与普通局部变量的区别

在C语言中，如果`static`修饰一个**函数内部的变量**，它会变成**静态局部变量**。这种变量有其独特的特性和用途。

**静态局部变量的特性**

1. **生命周期**:

   - 与普通的局部变量不同，`static`修饰的局部变量在程序运行期间**只初始化一次**，并且它的值会在函数调用结束后**保留**，不会被销毁。（**具有继承性**）
   - **普通局部变量**在每次函数调用时都会被创建，并在函数返回时销毁。

2. **作用域**:

   - **仅限于定义它的函数内部**（即作用域和普通局部变量相同），但其生命周期贯穿整个程序的执行周期。

3. **存储位置**:

   - 静态局部变量存储在**静态存储区**（通常是程序的全局数据区或BSS段），而不是栈中。

4. **初始值**:

   - 如果未显式初始化，`static`局部变量的默认初始值为**0**（与全局变量类似）。

5. ```c
   #include <stdio.h>
   
   void staticTest() {
       static int count = 0;  // 静态局部变量
       int regularVar = 0;    // 普通局部变量
   
       count++;
       regularVar++;
   
       printf("Static count: %d, Regular variable: %d\n", count, regularVar);
   }
   
   int main() {
       staticTest();  // 第1次调用
       staticTest();  // 第2次调用
       staticTest();  // 第3次调用
       return 0;
   }
   输出结果
   Static count: 1, Regular variable: 1
   Static count: 2, Regular variable: 1
   Static count: 3, Regular variable: 1
   ```

   - **解释**:
     1. **`count`是静态局部变量**:
        - 它在第一次调用时初始化为`0`，然后**每次调用函数时保持上次调用后的值**，所以在每次输出时，它的值会累加。
     2. **`regularVar`是普通局部变量**:
        - 每次函数调用时都会重新初始化为`0`，因此每次输出时，它的值都是`1`。

6. **静态局部变量的使用场景**

   - **计数器**: 记录函数被调用的次数。
   - **状态保持**: 在多次函数调用之间保留状态。
   - **性能优化**: 避免不必要的重复初始化。

7. **小结**

   - `static`在函数内修饰的变量是**静态局部变量**，**其作用域局限于函数内，但生命周期贯穿整个程序执行过程。**
   - 它结合了**局部变量的作用域**和**全局变量的生命周期**的特点。

#### 变量的生命周期和作用范围

##### 全局变量与局部变量

**定义位置**

- 全局变量：定义在所有函数之外（包括main函数）
- 局部变量：定义在函数内部（包括main函数）

**作用域**

- 全局变量：整个程序文件都可以访问（**[跨源文件访问需要做一些其他操作](#####全局变量的可见性与extern的关系)**）
- 局部变量：仅在定义它的函数内部可以访问

**生命周期**

- 全局变量：程序开始运行时分配内存，程序结束时释放
- 局部变量：函数被调用时分配内存，**函数执行结束时释放**

```c
#include <stdio.h>

int globalVar = 10;  // 全局变量

void function1() {
    int localVar = 20;  // 局部变量
    printf("在function1中：\n");
    printf("globalVar = %d\n", globalVar);  // 可以访问全局变量
    printf("localVar = %d\n", localVar);    // 可以访问局部变量
}

void function2() {
    printf("在function2中：\n");
    printf("globalVar = %d\n", globalVar);  // 可以访问全局变量
    // printf("localVar = %d\n", localVar); // 错误！不能访问function1的局部变量
}

int main() {
    function1();
    function2();
    return 0;
}
```

初始化特点

- 全局变量：如果没有显式初始化，会被自动初始化为0
- 局部变量：如果没有显式初始化，其值是随机的

存储位置

- 全局变量：存储在静态存储区
- 局部变量：存储在栈区

注意事项：

- 局部变量优先级高于同名全局变量
- 过多使用全局变量可能导致程序难以维护
- 建议适当使用局部变量，减少全局变量的使用

##### **局部变量**

- auto就是调用一次函数执行完就会释放。（调用多次的情况下）

- static在多次调用的情况下，变量的值不会被重复定义，会继承上一次调用结果的值。

- 局部变量和全局变量的作用范围，**就近原则**（内部的优先级会大于外部），一个{}就是小作用域

```c
int i = 100;//作用域：从定义开始到程序结束

int main()
{
	int i = 3;//作用域只在这一个{}中
	printf("i = %d\n",i);//这个程序是见不到外层的只在这一个{}中
	exit(0);

}
```

##### 全局变量的坏处

```c
int i = 0;//改动会被全局可见，导致只能打印一次，如果在for中定义for(int i = 0 ; i < 5 ; i++),就不会出现这种问题。需要多个模块使用时才定义全局变量

void print_star(void)
{
	for(i = 0 ; i < 5 ; i++)
		printf("*");
	printf("\n");	
}

int main()
{
	for(i = 0 ; i < 5 ; i++)
		print_star();
	exit(0);
}
```

**命名冲突**：

- 当多个开发人员在不同的源文件中工作时，如果不小心使用了同名的全局变量，可能会导致**命名冲突**。这种冲突很难调试，因为全局变量可以被任何文件访问，变量名的覆盖和冲突会导致程序行为不可预测。
- 例如，多个源文件中定义了全局变量 `int i;`，程序在链接阶段可能报错或覆盖其中的一个 `i`，这会导致程序在运行时行为不符合预期。

**难以维护**：

- 全局变量在整个程序中都可以被修改，随着项目规模的增长，**维护全局变量变得复杂**，尤其是当很多函数都可以访问和修改这些变量时，调试和追踪哪个函数修改了全局变量会变得非常困难。

**不符合模块化编程思想**：

- 使用全局变量违反了模块化和封装的编程原则，因为它让变量的作用域扩展到整个程序，**破坏了代码的独立性**。模块化编程提倡限制变量的作用范围，使得代码更加模块化和可控。

**线程安全问题**：

- 在多线程环境中，全局变量会引发**线程安全问题**，因为多个线程可能同时访问和修改同一个全局变量，导致数据竞争和不可预测的行为。如果不使用同步机制（如锁），全局变量会变得非常不可靠。

**用 `static` 解决全局变量的命名冲突问题**

为了避免上述问题，尤其是在开发多个源文件时，可以使用 `static` 修饰符来限制全局变量的作用域。`static` 修饰符可以将全局变量的**可见性限制在当前源文件**，防止其他源文件中的代码访问该变量。

`static` 关键字的作用

- **作用域**：将全局变量的作用域限制在定义它的源文件内，使得变量只能在当前源文件中被访问，其他文件即使使用相同的变量名也不会产生冲突。
- **用途**：在多文件项目中，可以通过 `static` 修饰全局变量，确保该变量在其他文件中不可见，从而避免命名冲突。

##### 全局变量的可见性与extern的关系

在 C 语言中，全局变量的**可见性**和**定义**有着清晰的规则，即使没有使用 `static` 修饰，它也不会自动对其他源文件可见。

**全局变量的默认可见性（没有使用 `static` 修饰时）**

- **全局变量**默认是具有“**外部链接**”的，也就是说它在**当前源文件中可见**，并且如果通过 `extern` 声明，也可以在其他源文件中访问。
- 但是，**其他源文件不会自动知道它的存在**。在其他源文件中，编译器不知道你已经在某个源文件定义了这个变量，因此你必须显式声明 `extern`，告诉编译器这个全局变量存在于别的文件中。

因此，虽然全局变量默认有“外部链接”，理论上可以跨文件使用，但仍需要通过 `extern` 来显式声明。

**全局变量不可自动在其他源文件中可见的原因**

即使全局变量有外部链接属性，它也**不会自动在其他源文件中可见**，这是因为编译器在编译一个源文件时不会自动搜查其他源文件的内容。每个源文件都会被独立编译，而不是作为一个整体处理。因此，编译器不知道你在其他源文件中定义了这个变量，必须通过 `extern` 明确声明它的存在。

**为什么同名全局变量会报错？**

当你在多个源文件中**定义了同名的全局变量**，**编译器在链接阶段会报错**，提示**重复定义**。

每个源文件都有一个独立的全局变量 `i`，它们各自都占用内存空间。当编译器在链接阶段试图将两个源文件合并时，发现有两个相同名字的全局变量 `i`。链接器无法判断哪一个 `i` 是正确的，或者哪一个是应该使用的，因此报错。

**如何避免同名全局变量的冲突？**

为了避免不同源文件中同名全局变量的冲突，有两种方法：

1. **使用 `extern`：**
   - 只在一个源文件中定义全局变量，其他源文件通过 `extern` 来声明，避免重复定义。
2. **使用 `static`：**
   - 如果你确实需要在不同源文件中使用同名的变量，但希望它们彼此互不影响，可以使用 `static` 修饰符。`static` 会将变量的作用域限制在**当前源文件**，即使其他文件中有同名变量，也不会引发冲突。
3. 全局变量默认不自动对外可见，跨文件使用需要使用extern声明一下。编译器在编译一个源文件时不会自动搜查其他源文件的内容。每个源文件都会被独立编译，而不是作为一个整体处理。因此，编译器不知道你在其他源文件中定义了这个变量，必须通过 `extern` 明确声明它的存在。
4. 既然不自动可见为什么还会出现多个源文件的全局变量同命名冲突？这是因为在链接阶段，GCC不知道变量定义到底信谁的。**这是两个阶段的问题，并不冲突。**

| **类型**       | **作用域** | **生命周期**   | **存储位置**                    |
| -------------- | ---------- | -------------- | ------------------------------- |
| auto变量       | 一对{}内   | 当前函数       | 栈区                            |
| static局部变量 | 一对{}内   | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| extern变量     | 整个程序   | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| static全局变量 | 当前文件   | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| extern函数     | 整个程序   | 整个程序运行期 | 代码区                          |
| static函数     | 当前文件   | 整个程序运行期 | 代码区                          |
| register变量   | 一对{}内   | 当前函数       | 运行时存储在CPU寄存器           |
| 字符串常量     | 当前文件   | 整个程序运行期 | data段                          |

各类型变量的存储位置见后面课程



##### 疑惑

**定义在main中的int i ,int j,外层for用i,外层循环没有结束前，i的值是不会释放的。 内层for使用j,为啥外层每循环一次内层的j值会被释放重置？ 以函数角度来看，外层每循环一次，内层for循环已经循环完了？所以会被释放？**

```c
int main() {
    int i, j;  // 都是main函数的局部变量
    
    for(i = 0; i < 3; i++) {     // 外层循环
        printf("外层 i = %d\n", i);
        
        for(j = 0; j < 2; j++) { // 内层循环
            printf("  内层 j = %d\n", j);
        }
    }
    return 0;
}

外层 i = 0
  内层 j = 0
  内层 j = 1
外层 i = 1
  内层 j = 0
  内层 j = 1
外层 i = 2
  内层 j = 0
  内层 j = 1
```

变量的作用域：

- i 和 j 都是定义在 main() 函数内的局部变量
- 它们都在整个 main() 函数执行期间都是有效的
- 它们都不会被"释放"，直到 main() 函数结束

j 值"重置"的原因：

- j 实际上并不是被"释放"了

- **而是在每次进入内层 for 循环时，j 都被重新赋值为初始值 0**

- 这是因为 for(j = 0; j < 2; j++) 中的 j = 0 每次都会执行

- ```c
  i = 0:
      j = 0  // 内层for的初始化
      j = 1  // 内层for的递增
      j = 2  // 循环结束
  
  i = 1:
      j = 0  // 内层for的初始化（不是释放，是赋值！）
      j = 1  // 内层for的递增
      j = 2  // 循环结束
  
  i = 2:
      j = 0  // 内层for的初始化（不是释放，是赋值！）
      j = 1  // 内层for的递增
      j = 2  // 循环结束
  ```

从函数角度来看：

- **这里并不涉及函数的调用和返回**
- 内层循环确实每次都"完整执行完"，**但这不是变量被"释放"的原因**
- j 的值看起来像"重置"，实际上是被重新赋值为0

要验证 j 确实没有被释放，我们可以修改代码：

```c
int main() {
    int i, j = 100;  // 给j一个初始值
    
    for(i = 0; i < 3; i++) {
        printf("外层 i = %d, 进入内层前 j = %d\n", i, j);
        
        for(j = 0; j < 2; j++) {
            printf("  内层 j = %d\n", j);
        }
        printf("内层循环结束后 j = %d\n", j);  // j仍然存在，值为2
    }
    return 0;
}
```

这段代码会清楚地显示 j 在整个过程中都存在，只是值在不断变化。内层循环结束后，j 的值会是 2（因为这是使循环结束的值）。

关键点是要理解：这里的"重置"实际上是变量的重新赋值，而不是变量的释放和重新创建。在嵌套循环中，所有变量都会持续存在，直到它们的作用域（这里是整个main函数）结束。

### 运算符和表达式

- 表达式与语句的区别

i = j*2; 加分号就是语句，不加就是表达式

- 运算符部分
  - 每个运算符所需要的参与预算的操作数个数
  - 结合性
  - 优先级
  - 运算符的特殊用法
  - 位运算的重要意义

以下是 C 语言中常见运算符的类别、结合性以及优先级表。结合性表示在遇到多个相同优先级的运算符时，操作的方向（左结合或右结合）。

![img](./C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/548763-20190918105016384-1557418531.jpg)

除法：A/B，B不能为0

取模：C%D，两者都必须为整型

**自增：**

运算符在前，先进行计算，再取变量值使用。

变量在前，先取变量值使用，再进行计算。

**后缀自增**（`i++`）先使用当前值i1，然后自增i1=i1+1，导致使用的是自增前的 `i1` 而不是 自增后`i1`。

**前缀自增**（`++j`）先自增j1=j1+1，后使用，所以使用的是自增后的 `j1`。

```c
int i = 1,j = 10,value;
value = i++ + ++j;
//先取i,
//再取j = j + 1
//再算value = i + j
//最后算i = i + 1
//结果就是value=12，j=11,i=2
这个可以参考for循环中的i++,他是等括号中执行完一边后再自增的 
```

单独使用时没有区别:

```c
int a = 5, b = 5;
a++;    // a变成6
++b;    // b变成6
// 此时a和b都是6,没有任何区别
```

在混合表达式中才有区别:

```c
int a = 5, b = 5;
int x = a++ + 2;   // x = 7, a = 6  (先用5计算,再加1)
int y = ++b + 2;   // y = 8, b = 6  (先加1变成6,再计算)
混合运算中的后置自增行为
在混合运算中，比如 a + b++，b++ 的值确实是 b 的当前值，然后才执行自增。也就是说，b++ 先返回 5，自增的效果在表达式计算完成后才应用。所以这里应该是 5 + 5 = 10。
```

也就是说:

- 单独使用时,`a++` 和 `++b` 的效果完全相同,都是把变量加1
- 只有在参与其他计算(混合表达式)时,才能体现出前缀(++b)和后缀(a++)的区别:
  - 后缀(`a++`): 先使用,后增加
  - 前缀(`++b`): 先增加,后使用

- 逻辑与，逻辑或的短路特性

```c
int a = 1, b = 2, c = 3, d = 4;
int n = 1, m = 1;
(m = a > b) && (n = c > d);//当(m = a > b)为0时，后面是不判断的，因为无论如何都是假。导致m=0,n=1
(m = a > b) || (n = c > d);//当(m = a > b)为0时，还会往后判断，因为有一个为真就为真。导致m=0,n=0
```

- 强制类型转换：（）。[隐式转换传送门](####隐式转换)

```c
int a ;
float f = 3.9;
a = f;//再算数表达式中才会倾向高精度类型，赋值的话，要看复制目标的数据类型
```

强制转换是一个中间过程，不会改变f的值和类型。

#### 位运算（以二进制位来运算）

在嵌入式开发中，**位运算**的重要性可以总结为以下几点：

1. **控制硬件寄存器**：用于直接操作和控制硬件设备的寄存器位，如设置引脚状态等。
2. **高效数据处理**：提供快速的数据处理能力，节省嵌入式系统的存储和计算资源。
3. **状态标志与掩码操作**：通过单个位标记状态，使用位掩码修改或读取特定的位。
4. **多路复用**：通过位运算将多个信号或状态合并到一个变量中进行传输或存储。
5. **功耗优化**：通过位操作快速控制硬件启停，从而优化功耗。

```c
例子1：
int flag1=0,1;
int flag2 = 0,1;
int flag3 = 0,1,2,3;
int flag4 = 0~7;
这一些都可以用二进制位表示

例子2：
int i = B1100 = 12
i >> 1 --->110 = 6
B110 << 1 --->1100 = 12
~i ---> B0011  全部取反操作

例子3：按位或（没有1就是0），按位与（有0就是0）     注意区分逻辑或，逻辑与
i | j    
	1 1 0 0
|	1 0 0 1
----------------
	1 1 0 1
	
例子4：按位异或(两个位相同时结果为0，不同时结果为1)，先异就为1，同为0
i ^ j
	1 1 0 0
^	1 0 0 1
----------------
	0 1 0 1
```

- 不使用额外变量两个变量实现交换

```c
#include <stdio.h>

int main() {
    int a = 5, b = 10;

    // 打印交换前的值
    printf("Before swap: a = %d, b = %d\n", a, b);

    // 使用位运算进行交换
    a = a ^ b; // 步骤1: a 变为 a ^ b
    b = a ^ b; // 步骤2: b 变为 a (原来的 a)
    a = a ^ b; // 步骤3: a 变为 b (原来的 b)

    // 打印交换后的值
    printf("After swap: a = %d, b = %d\n", a, b);

    return 0;
}
```

注意事项：

1. **整数溢出问题**：在某些情况下，位运算可能会涉及较大的数值（如超出 `int` 范围），这时可能会导致溢出或未定义行为。确保数值的范围适合当前的数据类型。
2. **类型兼容**：位运算**要求操作数类型是整数类型**（如 `int`, `unsigned int` 等）。对浮动类型（如 `float`, `double`）使用位运算会导致编译错误或不符合预期的行为。
3. **可读性和维护性**：虽然位运算交换很高效，但它可能不如使用临时变量那样直观。在维护和调试代码时，可能会增加理解和排错的难度。如果代码可读性更重要，可以选择使用临时变量交换。

总体来说，位运算交换是一个高效且节省空间的技巧，但要确保在实际应用中理解其使用场景，避免不必要的复杂性。

- 将操作数中第n位置变1（注意二进制从0开始的），其他位不变：num = num | 1 << n；

```c
在第2位上进行按位或1左移到指定位置的话，一定变成1.
其他位都是0不会变，有1不会影响，是0下来还是0
	1 1 0 0
|	0 1 0 0	
----------------
	1 1 0 0
```

- 将操作数中第n位置清0，其他位不变：num = num & ~（1 << n）；

```c
在第2位上进行清0，直接在对应位置进行按位与0即可，其他位都是1，有1不会影响，有0下来也是0
1 0 1 1不特殊，取反 0 1 0 0这个就特殊了。
	1 1 0 1
&	1 0 1 1	
----------------
	1 0 0 1
```

- 测试第n位是0还是1

```c
到对应位置上按位与1，有1下来还是1，有0下来就是0
但是最后的值不一定是1或者0，除非第0位，反正这里非0即真
if(num & (1 << n))
    
在 C 语言中，if 语句的条件部分只关心表达式的值是否为 0。无论表达式是十进制、二进制、十六进制，还是其他进制，只要表达式的计算结果不是 0，if 语句的条件就会成立。
1 << n：
	将 1 左移 n 位，表示在第 n 位上放置一个 1，其余位全为 0。
	例如，1 << 3 结果为 00001000（二进制表示）。
num & (1 << n)：
	这是一个按位与操作。
	只有当 num 的第 n 位为 1 时，结果才会是非零，否则结果为零。
判断是否为非零：
	如果结果是非零值（意味着第 n 位是 1），if 条件成立。
	如果结果是零（意味着第 n 位是 0），if 条件不成立。
```

- 从一个指定宽度的数中取出其中的某几位

```
10011010 1010 0011100
从第7位开始，取到第10位
取四位数，(num & (1111 << 6)) >>6
	10011010 1010 0011100
&	00000000 1111 0000000
----------------------------
	00000000 1010 0000000
```

- 总结

```
左移 (<<)：整体左移，原来的位置补零，左边没有墙
数字 << n = 数字 × 2ⁿ
例如：
3 << 2 = 12  (二进制：11 -> 1100)

右移 (>>)：右边有墙，整体右移几位就会被挤掉几位
数字 >> n = 数字 ÷ 2ⁿ（向下取整）
例如：
7 >> 1 = 3   (二进制：111 -> 11)

与运算 (&)
x & (2ⁿ - 1) = 取x的最后n位
例如：
1101 & 0011 = 0001（保留最后两位）

或运算 (|)
x | 2ⁿ = 将第n位置为1
例如：
1001 | 0100 = 1101（第3位置为1）


正确的"翻转第n位"方法是：
用一个1左移n位（形成只有第n位是1的数）
然后与原数异或
例如要翻转第3位：
x = x ^ (1 << 2)  // 左移2位得到0100，然后异或
等价于X ^=(1<<2)
这样无论原数第n位是0还是1，都会被翻转：
如果原来是0，0^1=1
如果原来是1，1^1=0


取反运算 (~)：这不是补码操作！
~x = -(x+1)  对于有符号数
例如：
~5 = -6

一些常用技巧：
判断奇偶：x & 1 = 1为奇数，= 0为偶数

取最低位的1：x & (-x)
清除最低位的1：x & (x-1)
```

#### 总结

**char类型在GCC处理时会自动转换为二进制？进而可以直接用位运算？ 那么int类型也可以直接使用位运算？**

所有数据在计算机内存中都是以二进制形式存储的,不管是 char、int 还是其他类型。这就是为什么我们可以直接对任何整数类型使用位运算。

1. 所有整数类型都可以直接使用位运算
   - char (1字节 = 8位)
   - int (通常4字节 = 32位)
   - long (在不同系统上可能是4字节或8字节)
2. 常见的位运算符
   - `<<` 左移
   - `>>` 右移
   - `&` 按位与
   - `|` 按位或
   - `^` 按位异或
   - `~` 按位取反
3. 数据在内存中的存储
   - 不管我们用什么格式输入输出(十进制、十六进制等)
   - 计算机内部都是按二进制处理
   - 这就是为什么位运算可以直接使用
4. 类型大小的区别
   - char 只能操作8位
   - int 可以操作32位
   - 但位运算的原理是完全相同的

所以,当我们做位运算时,不需要手动转换为二进制,计算机会直接在二进制层面进行操作。这就是为什么位运算通常比普通算术运算更快。

这个特性在以下场景特别有用:

- 标志位的设置和检查
- 权限管理
- 底层协议开发
- 嵌入式系统编程
- 高性能计算

#### 例子

```c
#include <stdio.h>

// 打印二进制的辅助函数
void printBinary(unsigned char n) {
    for(int i = 7; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
    }
    printf("\n");
}

int main() {
    // 示例1：以数字13为例
    unsigned char n = 13;
    printf("示例1：数字13\n");
    printf("n   = "); printBinary(n);     // 13的二进制：00001101
    printf("n-1 = "); printBinary(n-1);   // 12的二进制：00001100
    printf("n&(n-1) = "); printBinary(n & (n-1)); // 结果：00001100
    printf("\n");

    // 示例2：以数字8为例
    n = 8;
    printf("示例2：数字8\n");
    printf("n   = "); printBinary(n);     // 8的二进制： 00001000
    printf("n-1 = "); printBinary(n-1);   // 7的二进制： 00000111
    printf("n&(n-1) = "); printBinary(n & (n-1)); // 结果：00000000
    printf("\n");

    // 示例3：以数字15为例
    n = 15;
    printf("示例3：数字15\n");
    printf("n   = "); printBinary(n);     // 15的二进制：00001111
    printf("n-1 = "); printBinary(n-1);   // 14的二进制：00001110
    printf("n&(n-1) = "); printBinary(n & (n-1)); // 结果：00001110
    
    return 0;
}
```

在计算机中，所有的加减法都是直接在二进制层面进行的。当我们写 n-1 时，计算机会直接在二进制层面进行减法运算。

**我知道二进制减法，当最右边有1时，减去1，最右边的1会变成0。但是要做一开始最右边不是1呢？结果就与通常的减法法不一样了，有一点难以理解**

让我帮你理解当最右边不是1时的二进制减法。其实这遵循了我们小学学习的"借位"的概念，只是在二进制中表现得特别有规律。

```c
以数字6（二进制：110）减1为例：

     1 1 0    (6)
   - 0 0 1    (1)

1. 个位是0，要减1：
   - 从右数第二位借来1
   - 借1在二进制中相当于借 2（二进制：1 0）
   - 所以个位实际上是 2 减 1 = 1

2. 第二位因为借出去了1：
   - 原来是1，借出后变成0

3. 最高位不变，还是1

最终： 1 0 1    (5)
    
连续借位的情况：
  1 0 1 0 0  (20)
- 0 0 0 0 1  (1)
-----------------
第1步：个位借位
- 个位0减1，需要向左借
- 但左边是0，这个0也需要借，无法借出，继续向左

第2步：继续往左借
- 继续向左，遇到1
- 这个1借出后，相当于给它右边的0借来了2
- 但是这个2要经过一个0传递到个位
- 当2经过每个0时，这个0最多留下1（否则不够后面用）
- 所以经过的每个0都变成1

最终：10011  (19)
    
20:  1 0 1  0  0
   - 0 0 0  0  1
------------------
19:  1 0 0  1  1
     |   |  |  |
     |   借 变  变
     |   1  成  成
    不变 变  1   1
         0
```

让我解释二进制减法和 `n & (n-1)` 的原理：

- 所以我们可以总结出[一个规律](####类比十进制减法借位)：

  - 单次借位时，是向左借2
  - 连续借位时，经过的所有0都变成1（因为每个位置都需要留下一些值来维持借位传递），到个位是2

- **为什么 n & (n-1) 会消除最右边的1**:（在二进制上的区别就是只相差最右边上的1（num与num-1））

  - n-1 会把最右边的1变成0，并把其右边的所有0变成1
  - 当我们做 & 运算时：
    - 原数最右边的1右侧的位都会变成0（因为与运算的规则：1&0=0，0&1=0）
    - 原数最右边的1自己也会变成0（因为与1变成0的位做与运算）
    - 原数最右边的1左侧的位保持不变（因为n-1没有改变这些位）
  - 

- ```c
  13:     00001101
  12:     00001100
  13&12:  00001100  (消除了最右边的1)
  
  8:      00001000
  7:      00000111
  8&7:    00000000  (消除了最右边的1)
      
  // 方法3：使用与运算技巧
  int countOnes3(unsigned char num) {
      int count = 0;
      while(num) {
          num = num & (num - 1);  // 每次消除最右边的1
          count++;
      }
      return count;
  }
  ```

这就是为什么这个技巧可以用来计数二进制中1的个数 - 每次操作都会消除一个1，直到所有的1都被消除（数字变成0）。这个方法比遍历所有位更高效，因为它只需要循环1的个数次，而不是固定循环8次或32次。

这种操作在计算机底层就是直接的二进制运算，不需要考虑ASCII码。计算机会直接在二进制层面进行所有的运算，这也是为什么位运算通常比普通的算术运算更快。

#### n & (n-1) 会消除最右边的1思想

1.假设我们有一个数 n，我们关注它最右边的1所在的位置。在这个1的右边，可能有若干个0。

2.对于数字 n-1:

- **最右边的1会变成0**
- **这个1右边的所有0会变成1**
- 这个1左边的所有位保持不变

```
n     = 1 0 1 1 0 1 0 0
n-1   = 1 0 1 1 0 0 1 1

当我们做 n & (n-1) 时:
n     = 1 0 1 1 0 1 0 0
n-1   = 1 0 1 1 0 0 1 1
-----------------------
        1 0 1 1 0 0 0 0
n & (n-1) = 1 0 1 1 0 0 0 0
```

观察可以发现:

- 对于最右边的1的右侧：在 n-1 中全变成了1，但是与原数字 n 做与运算后都变成了0
- 对于最右边的1自己：在 n-1 中变成了0，与原数字 n 做与运算后也变成了0
- 对于最右边的1的左侧：保持不变

这就是为什么 n & (n-1) 总能消除最右边的1！这种位操作的巧妙之处在于它利用了减1操作对二进制位的影响特性。

这个技巧在实际编程中很有用，比如你展示的计算1的个数的函数就很巧妙 - 每次操作都消除一个1，消除了多少次就有多少个1。这比逐位检查要高效得多。

要特别注意这种技巧的关键点：

1. n-1 操作会把最右边的1变成0，并把它右边的所有0变成1
2. 而 & 操作则刚好可以消除这些变化，只留下最右边的1被消除的效果

#### 类比十进制减法借位

```c
  2000
-    1
------
第1步：个位0要减1，向左借位
- 十位是0，继续借
- 百位是0，继续借
- 千位是2，借1变成1
- 经过的0都变成9
- 到个位时是10，减1等于9

所以：
  2000
-    1
------
  1999
     
二进制对比
      
  10000  (16)
-     1  (1)
--------
第1步：个位0要减1，向左借位
- 向左遇到的0都需要继续借
- 直到遇到1，借1变成0
- 经过的0都变成1（相当于十进制中的9）
- 到个位时是2（二进制10），减1等于1

所以：
  10000
-     1
--------
   1111  (15)
```

完全对应的规律：

1. 十进制借位
   - 借出的位减1
   - 中间经过的0都变成9（因为每位最多留9）
   - 到最后变成10，够减1
2. 二进制借位
   - 借出的1变成0
   - 中间经过的0都变成1（因为每位最多留1）
   - 到最后变成2（二进制10），够减1

本质上：

- 十进制中，每一位借1相当于借10（向右进一位就是10进制）
- 二进制中，每一位借1相当于借2（向右进一位就是2进制）
- 经过的位都要留下进制1（十进制留9，二进制留1）

这就解释了为什么：

- 十进制中经过的0变成9
- 二进制中经过的0变成1

从**结果**来总结口诀：

- **从右往左逐位检查**：
  - **遇到 1 时**：变为 `0`。
  - **遇到 0 时**：变为 `1`（进行借位）。
- **继续向左推进**，直到遇到第一个 `1`，将其变为 `0`，然后停止。

## 输入输出

input & output —>I/O(标准IO，文件IO)

- 格式化输入输出函数：scanf,printf
- 字符输入输出函数：getchar,putchar
- 字符串输入输出函数：gets(!),puts

#### 格式化输入输出函数

`scanf`: 用于从标准输入读取数据，支持格式化读取。

```c
int a';
float f;
scanf("%格式字符", 地址表项);
scanf("%d，%f", &a,&f); //有逗号的话，输入时也要带逗号，不然不是期望的值
scanf("%d%f", &a,&f);//不加东西的话，tab 和空格，enter都可以
scanf("%d", &a); 从标准输入（通常是键盘）读取一个整数。
&a 是 a 变量的地址，scanf 将读取到的值存储到这个地址中，也就是存储在 a 变量中。
```

**注意事项**：

- **读取时需要提供变量的地址符（如`&a`）,因为 `scanf` 需要修改传入变量的值（即修改 `a` 的值），所以它需要知道 `a` 在内存中的地址才能将输入的整数写入到正确的位置。如果不传递地址，而是直接传递 `a`，那么 `scanf` 只是得到 `a` 当前的值，而无法修改 `a` 变量的值。**
- `scanf`遇到空白字符（空格、换行、制表符等）会停止读取。
- 使用`%s`读取字符串时会在空格处停止，可以使用更高级的输入函数（如`fgets`）来避免此问题。
- `scanf`输入不匹配时会导致意外行为，需要谨慎处理输入数据。
- **`%d\n`**：如果在格式字符串中包含 `\n`，`scanf` 会尝试读取完整数后，再继续等待，直到用户输入的下一个非空白字符。这可能导致不必要的阻塞，因为 `\n` 告诉 `scanf` 去读取并忽略**所有后续的空白字符**，直到遇到一个非空白字符（包括换行符、空格或制表符等）。
- 在 C 语言中，如果你在 `scanf` 中使用数组，那么**数组名本身就是指向数组首元素的地址**，因此不需要使用 `&` 来获取地址。数组名在很多场景下可以直接当作指针使用。
- 使用 `%s` 读取和输出字符串时，需要注意以下几点，以避免潜在的错误和问题。

  - **避免缓冲区溢出**

    - 使用 `scanf("%s", str);` 读取字符串时，`scanf` 并不会检查输入字符串的长度，如果输入的字符串超过了数组的大小，可能会导致**缓冲区溢出**，引发未定义行为或程序崩溃。
    - 为了防止溢出，推荐使用**宽度限定符**或其他安全的输入函数。

    ```c
    char str[10];  // 定义一个长度为10的字符串
    scanf("%9s", str);  // 限制输入长度为9，留一个位置给'\0'
    ```

- 连续使用scanf时，会把enter结束键作为输入。

```c
scanf("%d",&i);
scanf("%c",&ch);
这种情况会把enter键作为第二个输入的参数，导致第二个输入提前结束

使用抑制符*，让它吃掉一个字符，再把输入赋值给ch
scanf("%d",&i);
scanf("%*c%c",&ch);

或者中途接收一个但不赋值
scanf("%d",&i);
getchar();
scanf("%c",&ch);
```



##### 值传递和地址传递的区别

**为什么不能直接传递 `a` 的值给 `scanf`？**

1. **`a` 只是一个整数**： 当你直接传递 `a` 给 `scanf` 时，传递的是 `a` 的**当前值**，而不是 `a` 的内存地址。`scanf` 只能读到这个值，但无法知道该值存储在内存的哪个位置，因此它不能修改 `a`。
2. **`scanf` 需要修改 `a` 的值**： `scanf` 之所以需要传递 `&a`，是因为它需要**直接修改 `a` 的值**。通过传递 `a` 的地址（`&a`），`scanf` 能够访问 `a` 的内存位置，并将用户输入的值直接存储到这个位置。因此，`a` 的值在输入后会更新。

```c
#include <stdio.h>

void example(int a) {
    a = 20;  // 这只是修改了 a 的副本，不影响 main 中的 a,感觉就像局部变量，作用域只在这个函数中
    //当然你要是把a的地址传过来，就是直接把a的值改了
    //拿复印件办事和拿原件办事的效果不一样
}

int main() {
    int a = 10;
    example(a);  // 传递 a 的值
    printf("%d\n", a);  // 输出仍然是 10
    return 0;
}
```

在上面的代码中，`example` 函数中的 `a` 是传入的**副本**，修改 `a` 并不会影响到 `main` 函数中的原始变量 `a`。

但是如果我们传递 `a` 的地址，就能修改原始变量：

```c
#include <stdio.h>

void example(int *a) {
    *a = 20;  // 通过地址修改原始变量的值
}

int main() {
    int a = 10;
    example(&a);  // 传递 a 的地址
    printf("%d\n", a);  // 输出 20
    return 0;
}
```

这也是为什么在 `scanf` 中需要传递 `&a`，因为 `scanf` 需要直接修改 `a` 的值，而不是修改它的副本。



**`printf`: 用于向标准输出打印数据，支持格式化输出。**

```c
printf("Hello %s, your score is %d.\n", name, score);
printf("%[修饰符]格式字符",输出表项)
```

**注意事项**：

- 输出格式必须与变量类型匹配，如`%d`用于整数，`%f`用于浮点数。
- `printf`不会自动在结尾添加换行符，需手动添加`\n`。
  - **缓冲区机制**： 在C语言中，标准输出（如`printf`）通常是行缓冲的，这意味着输出会先存储在缓冲区中，直到满足特定条件后才会真正显示到屏幕上。以下情况会导致缓冲区刷新：
    - 遇到换行符 `\n`。
    - 缓冲区满了。
    - 程序正常结束（如`return 0;`）。
    - 手动刷新缓冲区（如调用 `fflush(stdout)`）。
  - **手动添加 `\n` 的作用**：
    - **刷新缓冲区**：当输出中包含换行符时，缓冲区会立即刷新，确保内容显示在终端或屏幕上。这在调试时特别重要，**因为如果不添加换行符，可能会看到延迟的输出。**
    - **格式化输出**：除了缓冲区刷新，换行符也能让输出内容格式化得更整齐，自动换行。

- **在C语言中，printf是有运算优先级的对吗？ printf("%d %d %d\n",++x,y--,x+z++);**

  - C语言标准**未明确规定**函数参数的求值顺序，这意味着**不同的编译器和平台可能采用不同的顺序**。

  - 常见顺序有：
    - **从右到左（右优先）**：这是大多数编译器（如GCC、MSVC）的默认行为。
    - **从左到右（左优先）**：某些特殊编译器可能使用这种顺序。

  即使参数的求值顺序不固定，**参数在栈中的位置**始终是按照从左到右的顺序传递的。

- **但是编译器不就是GCC吗？还有其他编译器？ 那求值顺序只可能是两种情况吗？从左到右入栈，和从右到左入栈？还是编译器自己选择优化求值顺序？**

  - 除了 GCC，确实还有很多其他常用的 C 语言编译器：

    1. 主流编译器：

    - GCC (GNU Compiler Collection)
    - Clang/LLVM
    - Microsoft Visual C++ (MSVC)
    - Intel C++ Compiler (ICC)
    - MinGW (Windows 上的 GCC 移植版)

  - 关于求值顺序，不仅仅是简单的从左到右或从右到左。编译器可以按照任意顺序对参数求值，只要遵循以下规则：

    - 每个参数表达式最终都会被计算
    - 所有参数都会在函数调用前计算完成

  - ```c
    printf("%d %d %d\n", ++x, y--, x+z++);
    ```

  - 可能的求值顺序包括但不限于：

    1. ++x → y-- → x+z++  (从左到右)
    2. x+z++ → y-- → ++x  (从右到左)
    3. y-- → x+z++ → ++x  (任意顺序)
    4. y-- → ++x → x+z++  (任意顺序) ... 等等

  - 编译器会基于多种因素选择求值顺序：

    1. 硬件架构特点
    2. 代码优化策略
    3. 寄存器分配
    4. 指令流水线优化

  - 所以编译器优化时不仅仅考虑简单的方向性（左到右或右到左），而是会根据具体情况选择最优的求值顺序。这就是为什么这种代码的行为是不可预测的。

  - 要写出可靠的代码，最好：

    1. 避免在同一个表达式中多次修改同一个变量
    2. 如果必须这样做，明确地分步骤写出来
    3. 不要依赖特定的求值顺序

- 最好是参数传入函数之前，已经提前计算完成了，不要在传入时计算并且多次修改同一个变量？

  - ```c
    // 好的写法：先计算所有值，再传入函数
    int temp1 = x + 1;
    x = temp1;         // 如果需要更新x
    
    int temp2 = y;
    y = y - 1;         // 如果需要更新y
    
    int temp3 = x + z;
    z = z + 1;         // 如果需要更新z
    
    printf("%d %d %d\n", temp1, temp2, temp3);
    
    // 不好的写法：在参数中直接计算和修改变量
    printf("%d %d %d\n", ++x, y--, x+z++);
    ```

  - 这样做有几个好处：

    1. 代码更容易理解和维护
    2. 避免未定义行为
    3. 便于调试（可以单步查看每个值的变化）
    4. 如果需要多次使用计算结果，不用重复计算

  - 这个原则不仅适用于 printf，也适用于所有函数调用！





以下是C语言常用格式化符的总结，按照表格形式展示：

| 格式化符 | 描述                                | 示例                         | 输出结果         |
| -------- | ----------------------------------- | ---------------------------- | ---------------- |
| `%d`     | 输出整数                            | `printf("%d", 10);`          | `10`             |
| `%f`     | 输出浮点数                          | `printf("%f", 3.14);`        | `3.140000`       |
| `%.2f`   | 浮点数，保留2位小数                 | `printf("%.2f", 3.14);`      | `3.14`           |
| `%s`     | 输出字符串                          | `printf("%s", "Hello");`     | `Hello`          |
| `%c`     | 输出字符                            | `printf("%c", 'A');`         | `A`              |
| `%p`     | 输出指针（地址）                    | `printf("%p", &a);`          | `0x7ffee3b5e9d4` |
| `%x`     | 输出整数的十六进制形式              | `printf("%x", 255);`         | `ff`             |
| `%o`     | 输出整数的八进制形式                | `printf("%o", 10);`          | `12`             |
| `%ld`    | 输出长整型（long）                  | `printf("%ld", 123456789L);` | `123456789`      |
| `%u`     | 输出无符号整数                      | `printf("%u", 3000000000U);` | `3000000000`     |
| `%-10d`  | 左对齐宽度为10的整数                | `printf("%-10d", 123);`      | `123 `(左对齐)   |
| `%10d`   | 右对齐宽度为10的整数                | `printf("%10d", 123);`       | `123` (右对齐)   |
| `%10.2f` | 右对齐宽度为10的浮点数，保留2位小数 | `printf("%10.2f", 3.14);`    | `3.14`           |

**表格总结：**
	**`%f`**：浮点数输出，默认保留6位小数。

**`%p`**：指针（内存地址）输出。

**`%x`**：十六进制整数输出。

**`%o`**：八进制整数输出。

下面是C语言中常用的修饰字符（修饰符）的总结，按照表格形式展示：

| 修饰字符   | 描述                                          | 示例                         | 结果                       |
| ---------- | --------------------------------------------- | ---------------------------- | :------------------------- |
| `-`        | 左对齐输出                                    | `printf("%-10d", 123);`      | `123 `（左对齐，宽度为10） |
| `+`        | 输出符号（正数带`+`号，负数带`-`号）          | `printf("%+d", 123);`        | `+123`                     |
| `0`        | 用零填充空位（在宽度不足时）                  | `printf("%05d", 42);`        | `00042`                    |
| `.`        | 指定小数点后精度（浮点数）                    | `printf("%.2f", 3.1415);`    | `3.14`                     |
| `#`        | 对 `o`, `x`, `X` 类型，强制加前缀 `0` 或 `0x` | `printf("%#x", 255);`        | `0xff`                     |
| ` `（空格） | 在正数前加空格，负数前加负号                  | `printf("% d", 123);`      | `123`（正数前有空格）  |
| `h`        | 短整型修饰符（用于`short`类型）               | `printf("%hd", (short)123);` | `123`                      |
| `l`        | 长整型修饰符（用于`long`类型）                | `printf("%ld", 123456789L);` | `123456789`                |
| `L`        | 用于长双精度浮点数（`long double`）           | `printf("%Lf", 3.1415L);`    | `3.141500`                 |

**表格总结：**

1. **`#`**：用于八进制和十六进制数，强制输出 `0` 或 `0x` 前缀。
2. `printf("%5d", 421231231);`,宽度不足，就按实际输出
3. `printf("%.2f", 3.1415);` 后面是四舍五入。如果是字符串就是留下多少有效字符
4. `printf("%-10d", 123);` 左对齐的话这个空格就补在后面了

##### 连续输入导致的问题

**在C语言中，scanf连续输入时，除了%c前需要空格之外，其他不需要空格会自动跳过？**

在C语言中，`scanf` 的行为会根据输入的格式说明符决定如何处理输入缓冲区中的内容。除了 `%c` 和 `%[]` 这类特殊的格式说明符，`scanf` 通常会跳过输入中的空白字符（包括空格、换行符和制表符）。

**原因：**

- 对于 `%d`、`%f`、`%s` 等格式说明符，`scanf` 会自动跳过输入中的空白字符。
- 而 `%c` 不会跳过空白字符，因为 `%c` 是读取单个字符，包括空格或换行符。

```c
#include <stdio.h>

int main() {
    int a, b;
    char c;

    printf("请输入两个整数和一个字符，中间用空格或回车分隔：\n");
    scanf("%d%d", &a, &b);  // 自动跳过空格或换行
    scanf(" %c", &c);      // 在%c前加空格，跳过缓冲区中的空白字符

    printf("a = %d, b = %d, c = '%c'\n", a, b, c);
    return 0;
}
```

如果不加 `" %c"` 中的空格，而直接用 `%c`：

```c
a = 10, b = 20, c = '\n'
```

原因是换行符 `\n`（回车）仍然在缓冲区中，`%c` 直接读取了它。



**在C语言中，如何解决连续scanf输入导致吞值跳过的情况？在格式匹配符号前面打一个空格？**

scanf的吞值(吃掉输入)问题是C语言编程中常见的一个坑。

**最常见的方法是在格式控制符前加一个空格:**

```c
scanf(" %c", &ch);  // 注意%c前有个空格
```

- 对于 `%c`：一定要在前面加空格（除非你真的想读取空白字符）,这个空格会跳过之前可能存在的空白字符(包括换行符)。

- 对于其他格式符：不需要加空格，因为它们会自动跳过空白字符

**更可靠的方法是在读取字符前清空输入缓冲区:**

```c
while(getchar() != '\n');  // 清空输入缓冲区
scanf("%c", &ch);
```

对于连续读取的情况,可以这样处理:

```c
int num;
char ch;
scanf("%d", &num);    // 先读取数字
getchar();           // 吸收掉换行符
scanf("%c", &ch);    // 再读取字符
```

推荐使用的最佳实践是:

- 对于字符输入,在格式符前加空格
- 需要精确控制时,使用getchar()清空缓冲区
- 考虑使用fgets()代替scanf来读取字符串,可以更好地控制输入

**主要是当我使用do while语句时，不断调用一个函数时，有时候使用while(getchar() != '\n'); *// 清空输入缓冲区* 反而也会跳过跳出循环**

在do-while循环中使用getchar()清空缓冲区确实可能会导致意外的行为。

```c
do {
    printf("请输入选项(1-5): ");
    scanf("%d", &choice);
    while(getchar() != '\n');  // 这里可能导致问题
    
    // 处理选项...
    
    printf("继续？(Y/N): ");
    scanf("%c", &continue_flag);  // 这里可能被跳过
} while(continue_flag == 'Y' || continue_flag == 'y');
```

更可靠的解决方案：

1. 使用fgets()和sscanf()组合：

```c
char buffer[100];
int choice;

do {
    printf("请输入选项(1-5): ");
    fgets(buffer, sizeof(buffer), stdin);
    sscanf(buffer, "%d", &choice);
    
    // 处理选项...
    
    printf("继续？(Y/N): ");
    fgets(buffer, sizeof(buffer), stdin);
    continue_flag = buffer[0];
} while(continue_flag == 'Y' || continue_flag == 'y');
```

2. 或者使用更严格的scanf控制：

```c
do {
    printf("请输入选项(1-5): ");
    scanf("%d", &choice);
    getchar();  // 只清除一个换行符
    
    // 处理选项...
    
    printf("继续？(Y/N): ");
    scanf(" %c", &continue_flag);  // 注意%c前的空格
} while(continue_flag == 'Y' || continue_flag == 'y');
```

推荐使用第1种或第2种方案，因为：

1. 更容易理解和维护
2. 不容易出现意外的跳过问题
3. 对用户输入的处理更可靠

**getchar(); *// 只清除一个换行符* 这个是因为我使用scanf输入后，按了回车键吗？**

当你使用scanf输入后按回车键时，实际上发生了这样的过程：

假设你输入：

```
23↵    (这里↵代表回车键)
```

输入缓冲区的情况：

```
23\n
  ↑
在scanf("%d")读取完23后，指针停在这里
```

过程分解：

- scanf("%d") 读取数字23
- 但回车键产生的'\n'仍然留在输入缓冲区中
- 如果之后要读取字符，这个遗留的'\n'会被读取，导致跳过实际想要的输入

为了更直观地理解，这里有一个演示程序：

```c
#include <stdio.h>

int main() {
    int num;
    char ch;
    
    printf("输入一个数字: ");
    scanf("%d", &num);
    
    printf("输入缓冲区中的字符ASCII码是: %d\n", getchar());  // 会打印10，即\n的ASCII码
    
    printf("输入一个字符: ");
    scanf("%c", &ch);
    printf("你输入的字符是: %c\n", ch);
    
    return 0;
}
```

如果去掉getchar()，运行结果会是：

```c
输入一个数字: 23
输入一个字符: 你输入的字符是:        // 直接跳过了字符输入
```

加上getchar()后：

```c
输入一个数字: 23
输入缓冲区中的字符ASCII码是: 10      // 显示了换行符的ASCII码
输入一个字符: a
你输入的字符是: a                    // 正常读取到输入的字符
```

这就是为什么每次用scanf读取数字后，如果接下来要读取字符，都需要用getchar()清除那个换行符。这是C语言输入处理中的一个重要细节。

#### 字符输入输出函数

`getchar`: 从标准输入读取一个字符。

```c
int c = getchar();
```

**注意事项**：

- `getchar`会等待用户输入并返回输入的第一个字符。
- `getchar`会读取包括空格、换行在内的所有字符。

`putchar`: 向标准输出打印一个字符。(**不会换行**)

```c
putchar(c);
```

**注意事项**：

- `putchar`只输出一个字符。
- 常用于逐字符输出或配合`getchar`实现字符回显。

当你输入一个字符并使用 `getchar()` 函数接收时，通常需要用 `int` 类型来存储它。这是因为 `getchar()` 实际上返回的是**字符的 ASCII 值**，而不仅仅是字符本身。`int` 类型可以容纳所有可能的字符，包括特殊的返回值，如 `EOF`（文件结束符）。以下是几个重要的原因：

**`getchar()` 返回 `int` 类型**

- `getchar()` 返回一个 `int`，而不是 `char`。这不仅是为了读取普通的字符，还可以表示一个特殊的值：`EOF`（End of File）。`EOF` 是一个整数常量，通常为 `-1`，用于表示输入结束或发生错误。
- **如果使用 `char` 类型接收 `getchar()` 的返回值，`EOF` 可能无法正确表示，因为 `char` 类型无法区分所有可能的字符值和 `EOF`**。

**`putchar()` 也接受 `int` 类型**

- `putchar()` 也接受 `int` 类型的参数。虽然它最终只输出单个字符，但传递 `int` 可以兼容所有字符和 `EOF`，确保兼容性。

**在处理字符输入输出时，使用 `int` 类型来接收字符是更为安全和通用的做法。**

#### 字符串输入输出函数

`gets`: 从标准输入读取字符串，读取直到遇到换行符（换行符不包含在字符串中）。

```c
char str[100];
gets(str);
```

**注意事项**：

- **`gets`非常不安全**，因为它无法防止缓冲区溢出，可能会导致程序崩溃或安全漏洞。尽量避免使用，**推荐使用`fgets`替代**。（gets没办法抹除，牵一发动全身。改一下就要把用到的地方全改了）,getline也可以

- `fgets` 是 C 语言中推荐使用的函数，用来安全地读取字符串。与 `gets` 不同，`fgets` 能够防止缓冲区溢出，并且可以限制读取的字符数量，从而减少安全漏洞的风险。

  - `fgets` 的基本语法：`char *fgets(char *str, int n, FILE *stream);`

  - 参数说明：

    - `str`：用于存放读取到的字符串的字符数组（缓冲区）。
    - `n`：要读取的最大字符数，包含最后的空字符 `'\0'`，因此 `n-1` 是可读取的实际字符数。
    - `stream`：输入流，通常是 `stdin`，表示从标准输入读取数据，也可以是其他输入流（如文件）。

  - 返回值：

    - 如果成功，`fgets` 返回指向字符串缓冲区 `str` 的指针。
    - 如果遇到错误或到达文件末尾（`EOF`），则返回 `NULL`。

  - ```c
    //从标准输入读取字符串
    #include <stdio.h>
    
    int main() {
        char str[50];  // 定义一个存放输入的字符数组
    
        printf("Enter a string: ");
        // 使用 fgets 从 stdin 读取最多 49 个字符（最后一个位置留给 '\0'）
        fgets(str, sizeof(str), stdin);
    
        // 输出读取到的字符串
        printf("You entered: %s", str);
    
        return 0;
    }
    在这个例子中，fgets 会读取最多 49 个字符，自动将第 50 个字符设置为 '\0'，从而保证字符串正确以空字符结尾。如果输入超过 49 个字符，fgets 会截断它，防止缓冲区溢出。
        
    从文件中读取字符串
    #include <stdio.h>
    
    int main() {
        char str[100];
        FILE *file = fopen("example.txt", "r");
    
        if (file == NULL) {
            printf("Failed to open file.\n");
            return 1;
        }
    
        // 从文件中读取字符串
        if (fgets(str, sizeof(str), file) != NULL) {
            printf("File content: %s", str);
        }
    
        fclose(file);
        return 0;
    }
    在这个例子中，fgets 从文件流 file 中读取字符串，直到遇到换行符或到达 n-1 个字符时停止。
    ```


`puts`: 输出字符串，并在末尾自动添加换行符。

```c
puts("Hello, World!");
```

**注意事项**：

- `puts`自动在输出的字符串末尾添加换行符，无需手动添加`\n`。

## 选择结构

### 总结表格

| 选择结构          | 形式                           | 使用场景                                         |
| ----------------- | ------------------------------ | ------------------------------------------------ |
| `if`              | `if (condition) {}`            | 单条件判断，条件为真时执行                       |
| `if-else`         | `if (condition) {}` `else {}`  | 二选一，条件真或假时分别执行不同的代码块         |
| `if-else if-else` | `if (cond1) {}` `else if {}`   | 多条件互斥判断，不同条件对应不同的处理           |
| 嵌套 `if`         | `if (cond1) { if (cond2) {} }` | 复杂条件的组合判断                               |
| `switch`          | `switch (expression) {}`       | 离散值的多分支判断，常用于枚举、整型、字符型变量 |

------

### 使用场景总结

- **`if` 系列** 适用于处理更复杂的条件判断，尤其是表达式、区间等情况。
- **`switch`** 适用于单一变量的多值判断时更加简洁且高效。在 **C 语言** 中，`switch` 语句的 `case` 后面**只能是常量表达式**，不能是**范围**或**变量**。因此，**`case` 后不能使用范围**。每一层case中必须要有break，不然程序会往后面继续执行。

else只与离它最近的if相匹配：是的，您理解得很正确。**“`else` 只与离它最近的未匹配的 `if` 相匹配”** 这句话在**没有使用大括号 `{}` 明确代码结构**时成立。当您使用大括号来明确地定义代码块时，`if-else` 的匹配关系就取决于大括号所包裹的结构，而不再仅仅是根据位置匹配。

## 循环结构

### 循环结构的比较和使用场景

| 循环结构       | 形式                          | 适用场景                                       | 特点                               |
| -------------- | ----------------------------- | ---------------------------------------------- | ---------------------------------- |
| **`for`**      | `for (初始化; 条件; 增量) {}` | 已知循环次数的情况下，如计数循环               | 条件、增量控制集中在一起，结构清晰 |
| **`while`**    | `while (条件) {}`             | 循环次数不确定，依赖条件判断，可能不执行循环体 | 先判断条件，再执行循环             |
| **`do-while`** | `do { } while (条件);`        | 必须执行一次循环体，再决定是否继续循环         | 先执行后判断，至少执行一次循环体   |

### 自增迭代时机区别

```c
for(int i = 0; i < 5; i++) {
    // 自增发生在本次循环体执行完之后
    // 执行顺序：
    // 1. 执行循环体
    // 2. 执行 i++
    // 3. 判断 i < 5
}

while(*p++) {
    // 自增发生在使用值的同时
    // 执行顺序：
    // 1. 获取 *p 的值
    // 2. 立即自增 p
    // 这会导致第一个元素可能被跳过
}

while(*p) {
    // 手动控制自增位置
    usart1_send_byte(*p);
    p++;  // 自增发生在使用值之后
}
```

关键区别：

- `for` 循环：循环体执行完后自增
- `while` 中的 `*p++`：使用值的同时自增
- 手动 `while` 循环：使用值后再自增

建议：

- `for` 循环最直观
- `while` 中要小心 `*p++`
- 手动控制自增更可控

### 总结

- **`for` 循环** 更适合**已知循环次数**且需要**精确控制循环变量**的情况。
- **`while` 循环** 适合**不确定循环次数**且需要在每次循环前判断条件的情况。
- **`do-while` 循环** 适合**必须至少执行一次**的循环需求，常用于用户输入或菜单操作。

## 辅助控制

在 C 语言中，`continue`、`break` 和 `return` 都用于控制循环结构和程序流的执行，但它们的作用和使用场景有所不同。下面详细说明它们在循环中的作用以及区别：

### `continue`：跳过当前循环迭代

- **作用**：`continue` 用于**跳过当前循环中的剩余语句**，立即进入下一次迭代。
- **适用场景**：当你希望跳过某些条件下的操作，并继续下一次循环时使用。

```c
#include <stdio.h>

int main() {
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            continue;  // 跳过 i 为 3 的这次循环
        }
        printf("%d\n", i);  // 输出 1, 2, 4, 5
    }
    return 0;
}
```

在这个例子中，当 `i == 3` 时，`continue` 跳过了 `printf` 的执行，并立即进入下一次循环，因此没有打印出 `3`。

### `break`：终止整个循环

- **作用**：`break` 用于**立即终止循环**，跳出循环结构，继续执行循环之后的代码。
- **适用场景**：当你不再需要继续执行循环时，或者某个条件满足时要提前退出循环，可以使用 `break`。

```c
#include <stdio.h>

int main() {
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            break;  // 当 i 为 3 时退出循环
        }
        printf("%d\n", i);  // 输出 1, 2
    }
    return 0;
}
```

这里，当 `i == 3` 时，`break` 立即终止循环，导致 `i == 3` 和之后的循环迭代不再执行，只输出 `1` 和 `2`。

### `return`：退出函数

- **作用**：`return` 用于**终止当前函数的执行**，并返回一个值（如果需要）。当 `return` 语句执行时，无论在哪个位置，当前函数都会立即结束执行。
- **适用场景**：当你需要立即结束函数执行，无论是在循环中还是其他位置，都可以使用 `return`。

```c
#include <stdio.h>

int main() {
    for (int i = 1; i <= 5; i++) {
        if (i == 3) {
            return 0;  // 立即终止 main 函数，程序结束
        }
        printf("%d\n", i);  // 输出 1, 2
    }
    printf("This will not be printed.\n");  // 不会执行
    return 0;
}
```

这里，当 `i == 3` 时，`return` 直接结束了 `main` 函数，导致程序终止。循环后的代码也不会执行。

### 区别总结

| 控制语句   | 作用                                   | 影响范围               | 使用场景                       |
| ---------- | -------------------------------------- | ---------------------- | ------------------------------ |
| `continue` | 跳过当前迭代的剩余语句，进入下一次循环 | 当前的循环迭代         | 跳过某些条件下的操作           |
| `break`    | 终止当前整个循环，跳出循环             | 当前的循环体           | 提前退出循环                   |
| `return`   | 结束当前函数的执行，返回值（可选）     | 当前函数，整个函数返回 | 提前结束函数，无论是否在循环中 |

### 使用注意

- **`continue`** 只影响当前循环的当前迭代，循环仍然继续。
- **`break`** 终止当前循环，并跳出循环，循环之后的代码继续执行。
- **`return`** 会立即终止整个函数的执行，即使在循环中，`return` 也会直接结束当前函数的执行。

### `goto` : 无条件跳转到指定的标号处

其中goto语句比较特殊,它允许程序跳转到同一函数内的任意标号位置。不过需要注意:

- goto语句会使程序的逻辑流程变得混乱,降低代码的可读性和可维护性

- 它可能会跳过变量初始化等重要操作

- 在现代编程中,建议尽量不使用goto,而是使用其他结构化的控制语句

- ```c
  #include <stdio.h>
  
  int main() {
      int i = 0;
      
  start:  // 标号
      printf("%d ", i);
      i++;
      if(i < 5)
          goto start;  // 跳转到start标号
      
      return 0;
  }
  ```

现代编程确实很少需要使用goto,因为:

1. 结构化编程提供了更清晰的替代方案:
   - while/for 循环替代循环跳转
   - if/else 条件语句处理分支逻辑
   - 函数调用处理子程序
2. goto的主要缺点:
   - 代码逻辑容易变成"意大利面条式"
   - 调试困难
   - 不利于代码维护和理解
   - 容易产生bug

不过在一些特殊场景下,goto仍然可能有用,比如:

- 深层嵌套的错误处理中快速退出
- 某些底层系统编程场景
- 某些需要优化性能的特定场合

但对于一般的应用开发,完全可以不使用goto,用其他结构化的控制语句就足够了。
