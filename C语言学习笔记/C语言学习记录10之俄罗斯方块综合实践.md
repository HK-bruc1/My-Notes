# 俄罗斯方块

屏幕闪烁是因为我们使用 system("cls") 清屏导致的。让我们通过修改绘制方式来解决这个问题。我们可以使用 Windows API 来优化绘制，减少闪烁。

主要改进：

1. 添加了 initConsole() 函数来初始化控制台设置，包括：
   - 隐藏光标
   - 设置合适的窗口大小
   - 设置缓冲区大小
2. 优化了绘制方法：
   - 使用缓冲区预处理要显示的内容
   - 一次性绘制整个游戏区域，减少闪烁
   - 使用中文字符显示方块，视觉效果更好
3. 改进了游戏逻辑：
   - 添加了自动下落功能
   - 添加了退出游戏选项（按'q'键）
   - 优化了游戏循环的时间控制

操作方式：

- 'a': 左移
- 'd': 右移
- 's': 加速下落
- 'q': 退出游戏

现在游戏的显示应该更加流畅，没有明显的闪烁了。如果你觉得游戏速度太快或太慢，我们可以调整 Sleep() 的参数和 fallCounter 的阈值。

```c
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <conio.h>
#include <time.h>

// 游戏区域大小
#define GAME_HEIGHT 20
#define GAME_WIDTH 12

// 方块的形状定义
typedef struct {
    int shape[4][4];
    int x, y;
} Block;

// 游戏状态
typedef struct {
    int board[GAME_HEIGHT][GAME_WIDTH];
    int score;
    Block current_block;
    int game_over;
} GameState;

// 控制台缓冲区
HANDLE hConsole;
COORD cursorPos;
CONSOLE_CURSOR_INFO cursorInfo;

// 函数声明
void initGame(GameState *game);
void drawGame(GameState *game);
void moveBlock(GameState *game, int dx);
void rotateBlock(GameState *game);
int checkCollision(GameState *game);
void mergeBlock(GameState *game);
void clearLines(GameState *game);
void generateNewBlock(GameState *game);
void gotoxy(int x, int y);
void initConsole(void);

// 俄罗斯方块的形状数组
const int SHAPES[][4][4] = {
    // I形
    {
        {0,1,0,0},
        {0,1,0,0},
        {0,1,0,0},
        {0,1,0,0}
    },
    // L形
    {
        {0,1,0,0},
        {0,1,0,0},
        {0,1,1,0},
        {0,0,0,0}
    },
    // 方形
    {
        {0,0,0,0},
        {0,1,1,0},
        {0,1,1,0},
        {0,0,0,0}
    }
};

// 初始化控制台设置
void initConsole() {
    // 获取标准输出句柄
    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    
    // 隐藏光标
    cursorInfo.dwSize = 1;
    cursorInfo.bVisible = FALSE;
    SetConsoleCursorInfo(hConsole, &cursorInfo);
    
    // 设置控制台窗口大小
    SMALL_RECT windowSize = {0, 0, GAME_WIDTH * 2 + 20, GAME_HEIGHT + 5};
    SetConsoleWindowInfo(hConsole, TRUE, &windowSize);
    
    // 设置缓冲区大小
    COORD bufferSize = {GAME_WIDTH * 2 + 21, GAME_HEIGHT + 6};
    SetConsoleScreenBufferSize(hConsole, bufferSize);
}

// 移动光标位置
void gotoxy(int x, int y) {
    cursorPos.X = x;
    cursorPos.Y = y;
    SetConsoleCursorPosition(hConsole, cursorPos);
}

// 初始化游戏
void initGame(GameState *game) {
    for(int i = 0; i < GAME_HEIGHT; i++) {
        for(int j = 0; j < GAME_WIDTH; j++) {
            if(j == 0 || j == GAME_WIDTH-1 || i == GAME_HEIGHT-1)
                game->board[i][j] = 1;
            else
                game->board[i][j] = 0;
        }
    }
    
    game->score = 0;
    game->game_over = 0;
    generateNewBlock(game);
}

// 生成新方块
void generateNewBlock(GameState *game) {
    int shape_idx = rand() % 3;
    
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            game->current_block.shape[i][j] = SHAPES[shape_idx][i][j];
        }
    }
    
    game->current_block.x = GAME_WIDTH / 2 - 2;
    game->current_block.y = 0;
    
    if(checkCollision(game)) {
        game->game_over = 1;
    }
}

// 绘制游戏界面
void drawGame(GameState *game) {
    // 创建临时缓冲区
    char buffer[GAME_HEIGHT][GAME_WIDTH * 2 + 1];
    
    // 准备绘制数据
    for(int i = 0; i < GAME_HEIGHT; i++) {
        for(int j = 0; j < GAME_WIDTH; j++) {
            int value = game->board[i][j];
            
            // 检查当前位置是否有活动方块
            for(int bi = 0; bi < 4; bi++) {
                for(int bj = 0; bj < 4; bj++) {
                    if(game->current_block.shape[bi][bj] &&
                       i == game->current_block.y + bi &&
                       j == game->current_block.x + bj) {
                        value = 2;
                    }
                }
            }
            
            // 填充缓冲区
            switch(value) {
                case 0: // 空白
                    buffer[i][j*2] = ' ';
                    buffer[i][j*2+1] = ' ';
                    break;
                case 1: // 边界或固定方块
                    buffer[i][j*2] = 0xA1;
                    buffer[i][j*2+1] = 0xF6;
                    break;
                case 2: // 活动方块
                    buffer[i][j*2] = 0xA1;
                    buffer[i][j*2+1] = 0xF1;
                    break;
            }
        }
        buffer[i][GAME_WIDTH * 2] = '\0';
    }
    
    // 一次性绘制整个游戏区域
    for(int i = 0; i < GAME_HEIGHT; i++) {
        gotoxy(0, i);
        printf("%s", buffer[i]);
    }
    
    // 显示分数
    gotoxy(GAME_WIDTH*2 + 2, 0);
    printf("Score: %d", game->score);
}

// 检查碰撞
int checkCollision(GameState *game) {
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            if(game->current_block.shape[i][j]) {
                int board_y = game->current_block.y + i;
                int board_x = game->current_block.x + j;
                
                if(board_x < 0 || board_x >= GAME_WIDTH ||
                   board_y >= GAME_HEIGHT ||
                   game->board[board_y][board_x]) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

// 合并方块到游戏板
void mergeBlock(GameState *game) {
    for(int i = 0; i < 4; i++) {
        for(int j = 0; j < 4; j++) {
            if(game->current_block.shape[i][j]) {
                int board_y = game->current_block.y + i;
                int board_x = game->current_block.x + j;
                if(board_y >= 0 && board_y < GAME_HEIGHT && 
                   board_x >= 0 && board_x < GAME_WIDTH) {
                    game->board[board_y][board_x] = 1;
                }
            }
        }
    }
}

// 自动下落
void autoFall(GameState *game) {
    game->current_block.y++;
    if(checkCollision(game)) {
        game->current_block.y--;
        mergeBlock(game);
        generateNewBlock(game);
    }
}

// 主函数
int main() {
    GameState game;
    char key;
    int fallCounter = 0;
    
    // 初始化控制台和游戏
    initConsole();
    srand((unsigned int)time(NULL));
    initGame(&game);
    
    // 游戏主循环
    while(!game.game_over) {
        drawGame(&game);
        
        // 处理输入
        if(_kbhit()) {
            key = _getch();
            switch(key) {
                case 'a': // 左移
                    game.current_block.x--;
                    if(checkCollision(&game))
                        game.current_block.x++;
                    break;
                case 'd': // 右移
                    game.current_block.x++;
                    if(checkCollision(&game))
                        game.current_block.x--;
                    break;
                case 's': // 加速下落
                    autoFall(&game);
                    break;
                case 'q': // 退出游戏
                    game.game_over = 1;
                    break;
            }
        }
        
        // 自动下落
        fallCounter++;
        if(fallCounter >= 20) { // 每20个循环周期下落一次
            autoFall(&game);
            fallCounter = 0;
        }
        
        Sleep(50); // 控制游戏速度
    }
    
    // 游戏结束
    gotoxy(GAME_WIDTH*2 + 2, 2);
    printf("Game Over!");
    gotoxy(0, GAME_HEIGHT + 1);
    
    return 0;
}
```



## 初步单体架构

### 头文件引用和宏定义

```c
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <conio.h>
#include <time.h>
#define GAME_HEIGHT 20
#define GAME_WIDTH 12
```

这里导入了必要的头文件来支持终端控制、随机数生成、以及游戏区域的大小。

### 数据结构定义

```c
typedef struct {
    int shape[4][4];
    int x, y;
} Block;

typedef struct {
    int board[GAME_HEIGHT][GAME_WIDTH];
    int score;
    Block current_block;
    int game_over;
} GameState;

```

`Block`：用于表示方块的位置和形状，`shape`是4x4的二维数组，用于存储当前方块的形状，`x`和`y`用于表示方块的坐标。

`GameState`：存储整个游戏的状态，包括游戏区域的网格`board`，分数`score`，当前方块`current_block`，以及游戏结束标志`game_over`。

### 控制台设置

```c
HANDLE hConsole;
COORD cursorPos;
CONSOLE_CURSOR_INFO cursorInfo;
```

这几个变量用于设置控制台的光标位置和控制光标的显示。

### 函数声明

代码中声明了多个函数，用于初始化游戏、绘制游戏界面、控制方块移动、检查碰撞、合并方块、清除行等。这些函数可以归类为：

- **游戏初始化**：`initConsole()`、`initGame()`
- **游戏逻辑**：`moveBlock()`、`rotateBlock()`、`checkCollision()`、`mergeBlock()`、`clearLines()`、`generateNewBlock()`
- **控制台操作**：`gotoxy()`、`initConsole()`
- **游戏界面**：`drawGame()`

### 方块形状的定义

```c
const int SHAPES[][4][4] = {
    // I形、L形、方形等
};
```

定义了若干种方块形状的模板，以4x4的二维数组表示。每一个数组代表一种方块的形状。

### 初始化函数

- `initConsole()`：设置控制台窗口大小和缓冲区，并隐藏光标。
- `gotoxy()`：用于将光标定位到指定位置，实现刷新显示效果。

### 游戏逻辑实现

- `initGame(GameState *game)`：初始化游戏状态，设置边界和生成初始方块。
- `generateNewBlock(GameState *game)`：生成新方块并随机选择形状。
- `drawGame(GameState *game)`：绘制游戏界面，包括边界、当前方块、以及分数。
- `checkCollision(GameState *game)`：检查方块是否碰撞墙壁或其他方块。
- `mergeBlock(GameState *game)`：将当前方块合并到游戏板上，表示方块落地后固定的位置。
- `autoFall(GameState *game)`：控制方块自动下落的逻辑，每经过一定时间自动下降一行。

### 主函数实现游戏循环

```c
int main() {
    GameState game;
    char key;
    int fallCounter = 0;

    initConsole();
    srand((unsigned int)time(NULL));
    initGame(&game);

    while(!game.game_over) {
        drawGame(&game);

        // 处理输入
        if(_kbhit()) {
            key = _getch();
            switch(key) {
                case 'a': // 左移
                case 'd': // 右移
                case 's': // 加速下落
                case 'q': // 退出游戏
            }
        }

        // 自动下落
        fallCounter++;
        if(fallCounter >= 20) {
            autoFall(&game);
            fallCounter = 0;
        }

        Sleep(50);
    }
    printf("Game Over!");
    return 0;
}
```

`main` 函数：启动并管理游戏的运行逻辑。它初始化控制台和游戏状态，并不断刷新游戏界面、处理键盘输入和方块的下落操作。每次下落时检查方块碰撞，若碰撞则固定当前方块并生成新的方块。

### **流程控制**

- 主循环依赖 `_kbhit()` 和 `_getch()` 检测键盘输入，并在每个游戏循环中调用 `autoFall` 让方块自动下落。

## 整个程序执行流程

**如果我想了解整个程序的执行流程，我该在哪里打断点？**

要了解整个程序的执行流程，你可以在以下关键位置打断点，以便逐步观察代码的执行：

### 1. **初始化阶段**

- **`main` 函数的开始**：在 `main` 函数的开始位置设置一个断点。这将帮助你观察整个游戏是如何被初始化的，包括控制台和游戏状态的初始化。
- **`initConsole` 函数内**：在 `initConsole` 中打断点，可以查看控制台设置、光标隐藏等初始化控制台的过程。
- **`initGame` 函数内**：这里的断点帮助你查看游戏区域（包括边界）是如何构建的，并确认游戏的初始状态，比如分数和游戏是否结束。

### 2. **生成新方块**

- **`generateNewBlock` 函数**：在 `generateNewBlock` 函数开头打断点，观察新方块的生成和随机形状的选择过程。这也是每次新方块生成的核心步骤，可以观察到方块位置和形状的初始化。

### 3. **游戏主循环**

- **`drawGame` 函数**：打断点观察游戏界面的刷新逻辑，包括如何将当前的方块和固定方块绘制到控制台。
- **键盘输入检测**（`_kbhit`）：在 `while` 循环中处理 `_kbhit()` 的位置打断点，检查用户输入的捕捉。
- **各个键盘输入操作**：在 `switch` 语句下的各个 `case` 位置，观察方块移动、下落、加速下落的响应。
- **自动下落**：在调用 `autoFall` 的位置，可以观察方块每次自动下落时的流程，比如碰撞检测和方块固定的过程。

### 4. **碰撞和合并**

- **`checkCollision` 函数**：在 `checkCollision` 开头设置断点，观察是否发生了方块与其他固定方块或边界的碰撞。
- **`mergeBlock` 函数**：在 `mergeBlock` 处打断点，检测方块下落到底部或碰撞后如何固定在游戏区域内。

### 5. **游戏结束检测**

- **`game.game_over` 设置的地方**：观察 `game_over` 状态被置为 1 的条件。你可以在 `generateNewBlock` 里检测到游戏是否因为新的方块生成而碰撞导致结束。

### 6. **循环退出**

- **`main` 中的 `while` 循环结束位置**：在循环即将退出时的条件打断点，查看游戏如何检测到结束状态并退出主循环。

### 关键断点总结

1. `main` 开头 - 检查整个程序启动。
2. `initConsole` 和 `initGame` - 初始化控制台和游戏状态。
3. `generateNewBlock` - 生成新方块。
4. `drawGame` - 绘制界面。
5. `_kbhit` - 检测用户输入。
6. `checkCollision` - 检测碰撞。
7. `mergeBlock` - 合并方块。
8. `while` 循环结束 - 检查游戏退出条件。

通过这些断点，可以全面理解代码的执行流程，了解各个模块如何交互。

## 设计理念

### 二维数组存放方块

**为什么会想到用用数组来存放方块？ 还是二维数组？是怎么抽象出来的逻辑？** 

在实现俄罗斯方块时，用二维数组来表示方块形状是一个很直观且有效的方式。俄罗斯方块的方块形状大多是规则的小块组合，因此二维数组适合描述每个方块的结构。让我们看看这样设计的原因和逻辑：

**1.方块的抽象表示**

- 方块在游戏中可以看成是一个在网格中排列的“单元格”矩阵。例如，"L" 形方块由 4 个小块组成，排列成特定的形状。二维数组非常适合这种表示，因为数组的每个元素可以简单地表示一个单元格，`1` 表示这个单元格包含块，`0` 表示空白。
- 将方块抽象为一个 4x4 的二维数组后，可以统一处理不同形状和大小的方块，无论是"长条"、"L"形还是"方形"等，都可以通过设置不同的`1`和`0`布局来表示。
- **一维数组只有一个方向，不太适合，二维数组在直观上和布局上就非常适合方块的表示**

2.**二维数组的结构和可操作性**

- 在`int shape[4][4]`中，4x4 的大小选择符合俄罗斯方块的基本需求，**因为在经典俄罗斯方块中，任何一个标准方块都可以包含在 4x4 的矩阵中。**
- **二维数组的结构使得旋转和移动操作更容易实现**。例如，通过行列交换、倒序等操作，可以实现方块的旋转（顺时针或逆时针）。这种矩阵结构在旋转过程中非常方便。对于变换图形非常方便。

3.**便于处理方块的边界和碰撞**

- 使用二维数组来表示方块形状，可以使碰撞检测更直观。你可以轻松**遍历 `shape` 数组的元素，并检查它们是否与游戏区域中的其他方块重叠，或者是否超出边界。**
- 比如，当方块下落或左右移动时，**只需检查二维数组中 `1` 的位置（方块的边界位置表示），判断它们是否与当前游戏区域的其他方块发生了重叠，从而确定是否发生碰撞。**

4.**代码复用性和可维护性**

- 使用固定的 4x4 矩阵和不同的形状数组 (`SHAPES`) 可以轻松扩展新的方块形状。只需定义新的 4x4 数组布局即可，无需修改其他逻辑。
- 这种方式增强了代码的复用性和模块化，每个方块形状都可以用一个简单的 4x4 数组定义，使代码结构更清晰且易于维护。

代码示例说明

在定义 `Block` 时：

```c
typedef struct {
    int shape[4][4];
    int x, y;
} Block;
```

- `shape[4][4]` 是一个二维数组，用来定义一个方块的固定形状。

- `x` 和 `y` 用于标记方块在游戏区域的坐标位置。

例如，以下是"长条"形的二维数组定义：

```c
{
    {0,1,0,0},
    {0,1,0,0},
    {0,1,0,0},
    {0,1,0,0}
}
```

这个结构表示一个竖直的长条方块，如果旋转，就可以把这4x4矩阵“旋转”成水平的表示。

#### 总结

使用二维数组存放方块形状的逻辑来源于：

1. **网格化的游戏区域与矩阵结构天然适配**；
2. **数组便于统一处理形状、旋转和碰撞检测**；
3. **4x4 矩阵足够表示所有方块形状，便于代码的通用性和扩展性**。

这种设计不仅高效，还使方块在游戏中的控制和渲染更为简单。

### 相关变量可以使用结构体集中管理

**游戏界面相关的变量都放在这个结构体中了，是因为他们都比较相关，可以在main中一起实例化或者初始化。其实他们可以单独定义并初始化的。**

将所有与游戏状态相关的变量统一放在 `GameState` 结构体中，确实是为了方便集中管理这些状态信息，并在 `main` 函数中统一初始化或实例化。

#### 为什么将相关变量放在结构体中

1. **便于管理和传递**：在游戏的不同函数中，如绘制界面、检测碰撞、移动方块等，**多个状态变量都需要被访问**。**如果这些变量集中在一个结构体中，我们只需传递 `GameState` 指针（就可以通过指针+箭头访问结构体成员了），而不需要每次传递多个独立变量（多个独立变量到处传递很麻烦）。**
2. **逻辑关联性**：`GameState` 中的变量（如 `board`、`score`、`current_block`、`game_over`）都属于游戏的核心状态，并会随游戏进程而改变。将它们放在一起符合“高内聚”的设计原则，使得代码结构更清晰。
3. **方便初始化和重置**：在 `initGame` 等初始化函数中，可以一次性初始化 `GameState` 中所有变量，这对游戏重开、重置等操作也很有用。

#### 可以单独定义和初始化的情况

确实，这些变量可以独立定义，比如 `int board[GAME_HEIGHT][GAME_WIDTH];`，`int score;` 等都可以分开定义。这样做在小项目中完全可行，但缺点是**需要在每个使用它们的地方额外管理和传递，尤其在多个函数中调用时。（那就不得不把独立变量到处作为参数传递，很麻烦）**

#### 总结1

结构体的使用是一种更模块化、更易扩展的设计方式，让代码便于维护和理解。在一些更简单的程序中，将变量单独定义也没有问题，但在项目增大、逻辑更复杂时，集中在结构体中会让管理更轻松。

#### 初始化游戏信息

**给GameState结构体初始化的依据和逻辑是什么？**

```c
// 初始化游戏
void initGame(GameState *game) {
	for(int i = 0; i < GAME_HEIGHT; i++) {
		for(int j = 0; j < GAME_WIDTH; j++) {
			if(j == 0 || j == GAME_WIDTH-1 || i == GAME_HEIGHT-1)
				game->board[i][j] = 1;
			else
				game->board[i][j] = 0;
		}
	}
	
	game->score = 0;
	game->game_over = 0;
	generateNewBlock(game);
}
```

`initGame()` 函数的设计依据是为了将游戏状态（`GameState`）的每个部分初始化为合理的初始值，从而确保游戏从一个清晰的初始状态开始运行。以下是对各个初始化操作的依据和逻辑分析：

**1.初始化游戏区域边界 (`game->board`)**

```c
for(int i = 0; i < GAME_HEIGHT; i++) {
    for(int j = 0; j < GAME_WIDTH; j++) {
        if(j == 0 || j == GAME_WIDTH-1 || i == GAME_HEIGHT-1)
            game->board[i][j] = 1;
        else
            game->board[i][j] = 0;
    }
}
```

**依据**：`board` 是一个 `GAME_HEIGHT x GAME_WIDTH` 的二维数组，用于存储游戏区域中的内容。每个元素值决定了该位置是否为空、是固定方块，还是边界。

**逻辑**：

- 边界区域（左、右侧列和底部行）被设为 `1`，表示不可通行的固定墙壁。
- 游戏区域的中部为 `0`，表示空白区域，用于容纳和移动方块。

**目的**：设定边界和空白区域的初始状态确保游戏区域具备基本的结构，使得方块能在中心区域内自由下落，而不会穿越墙壁。

**2.初始化分数 (`game->score`)**

```c
game->score = 0;
```

**依据**：分数初始为 `0`，因为在新游戏开始时玩家没有消除任何行。

**逻辑**：`score` 作为累积消除行数的计数器，随着游戏进展不断增加。在游戏初始化时，将其设为 `0` 符合游戏的起始状态。

**3.初始化游戏结束标志 (`game->game_over`)**

```
game->game_over = 0;
```

**依据**：`game_over` 变量用于标识游戏是否结束。

**逻辑**：`0` 表示游戏正在进行，`1` 表示游戏结束。在初始化时将其设为 `0` 以确保游戏可以正常开始，而不会被认为已经结束。

**4.生成新的方块 (`generateNewBlock(game);`)**

```c
generateNewBlock(game);
```

- **依据**：游戏从第一个方块开始，因此需要生成一个随机方块放置在顶部初始位置。
- **逻辑**：`generateNewBlock()` 函数会从预定义的方块形状中随机选择一个，将其初始化在游戏区域顶部的适当位置。生成方块是游戏开始的核心之一，因此在 `initGame()` 的最后调用此函数。

**在这里就可以直观的看到，只需要传递结构体的指针，就可以通过指针访问结构体的成员，并进行赋值，不然就要以形式参数的方式传递进来，还要求是全局变量才行，因为函数参数传递的都是副本，出了这个作用域就失效了？？？**

使用指针传递结构体的确是更高效且灵活的做法,通过指针传递 `GameState` 结构体有几个好处：

1. **直接访问和修改结构体成员**：当我们将 `GameState` 结构体的指针传递给 `initGame()` 等函数时，可以直接在函数内访问和修改结构体的成员。这使得初始化、更新和操作这些成员更加直观和集中。
2. **避免拷贝副本**：如果我们以值传递的方式传入整个结构体，函数将会接收结构体的副本。结构体可能较大，复制整个结构体会增加内存开销和时间开销。此外，函数内对副本的修改在函数结束后会丢失，而通过指针直接修改结构体可以确保修改生效。
3. **减少对全局变量的依赖**：通过指针传递结构体可以避免使用全局变量来存储游戏状态。全局变量虽然可以被所有函数访问，但会让代码耦合度更高，调试和维护变得困难。使用结构体指针来传递数据，使函数设计更加模块化和灵活，也提高了代码的可读性和可维护性。
4. **便于代码扩展和重用**：通过指针传递结构体使得代码更具扩展性，比如我们可以轻松地创建多个 `GameState` 实例并分别管理不同的游戏状态，而不会互相影响。这在游戏设计中十分重要，尤其是想要同时运行多个实例时。

**所以不使用结构体的话，以独立变量单独实例化和初始化很不方便。 特别是被多个函数访问时，需要单独传递各自的指针才行?**

完全正确！如果不使用结构体而是将每个变量独立定义，那么：

1. **管理和维护变复杂**：各个变量都需要单独实例化、初始化，且在**不同函数中使用时需要分别传递**。变量一多，代码的可读性就会降低，而且会增加出错的可能性。
2. **参数传递复杂**：在函数调用中，**必须为每个独立变量传递单独的指针**，特别是在更新或访问这些变量时。函数签名会变得长且难以管理，也容易因遗漏某个参数而引入问题。
3. **缺乏逻辑关联**：结构体将相关的变量组合成一个整体，明确地表明它们之间的关系和作用。而单独变量则显得散乱，**不利于表示“这些变量共同构成一个状态（比如 `GameState`）”的含义。**
4. **可扩展性低**：当要添加新的变量或状态时，如果使用结构体，只需在结构体中添加成员即可，调用处的代码也无需改变太多。**但如果变量独立定义，则必须在每个函数中手动增加这些变量传递，维护成本更高。**

**使用结构体的好处总结:**

结构体在数据管理上非常高效，尤其是在处理需要集中管理的复杂数据（如游戏状态）时，不仅提高了代码清晰度，还减少了耦合。

使用指针传递结构体的方式，在内存效率和代码维护性上都有明显优势。直接修改结构体中的成员而不依赖全局变量，让代码更清晰、更模块化。

#### 总结2

`initGame()` 的初始化逻辑确保了 `GameState` 的所有核心属性都具备合理的初始值。边界的设置、分数的清零、`game_over` 标志的初始化，以及生成一个新的方块，都是为了确保游戏有一个可控制的起点，使游戏逻辑在后续操作中正常运行。

### 控制台缓冲区的设计

**控制台缓冲区？是什么意思？是基于什么需求？没有会出现什么问题？**

```c
// 控制台缓冲区
HANDLE hConsole;
COORD cursorPos;
CONSOLE_CURSOR_INFO cursorInfo;
```

控制台缓冲区在这里是指程序用来**存储控制台输出的一个临时存储区域**，在游戏中可以通过**缓冲区控制光标、隐藏光标以及修改文本的输出位置，形成动态效果（方块的下落效果，旋转效果）**。对于基于控制台的俄罗斯方块游戏，控制台缓冲区的主要需求如下：

#### 1.光标控制和屏幕刷新

- **需求**：俄罗斯方块游戏需要**频繁刷新屏幕（不断打印不断输出，隐藏光标从而形成下落效果）**，以展示方块的**实时移动和下落效果**。通过缓冲区，可以**精确控制每个方块的显示位置**，并在屏幕上**指定的区域进行刷新，而不是重新输出整个界面。（重新输入整个界面，那整个屏幕就会闪，游戏体验不好）**
- **如果没有缓冲区**：没有缓冲区的话，每次更新都会直接显示在控制台上，容易造成屏幕闪烁（刷新过快、过于频繁）或抖动，使得用户体验较差。（缓冲区会保留历史输出在控制台，并指定区域刷新，并不更新整个界面）

#### 2. 光标隐藏和控制光标位置

- **需求**：游戏界面中通常不需要光标显示，因此**隐藏光标可以让界面更整洁**。`CONSOLE_CURSOR_INFO` 用于设置光标的隐藏和显示。
- **如果没有光标控制**：如果没有控制台缓冲区或光标控制，**每次操作时光标的位置会默认在最后输出的位置，不利于营造动态、清晰的界面效果。**

#### 相关变量解释

- **`HANDLE hConsole`**：控制台句柄，表示当前程序的控制台窗口，可以通过这个句柄进行位置设置、输出等操作。
- **`COORD cursorPos`**：用于控制光标的具体位置，指示每次更新方块时应该将光标放在游戏区域的哪个坐标。
- **`CONSOLE_CURSOR_INFO cursorInfo`**：用于设置光标的属性，如是否可见。游戏中通常会设置光标不可见，以免影响界面的整洁性。

总结来说，控制台缓冲区的设置目的是实现一个更流畅、稳定的游戏显示，避免直接输出带来的频繁刷新问题。

#### 3. 改善绘制性能

- **需求**：缓冲区允许游戏逻辑处理完一个完整帧后，再一次性输出到控制台，使得屏幕上的变化流畅稳定。直接输出每一行、每一个字符会让渲染变慢，影响游戏体验。
- **如果没有缓冲区**：游戏可能在输出复杂内容时产生明显的延迟或闪烁，影响用户的体验。

#### 4.控制台的具体初始化

```c
// 初始化控制台设置
void initConsole() {
	// 获取标准输出句柄
	hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	
	// 隐藏光标
	cursorInfo.dwSize = 1;
	cursorInfo.bVisible = FALSE;
	SetConsoleCursorInfo(hConsole, &cursorInfo);
	
	// 设置控制台窗口大小
	SMALL_RECT windowSize = {0, 0, GAME_WIDTH * 2 + 20, GAME_HEIGHT + 5};
	SetConsoleWindowInfo(hConsole, TRUE, &windowSize);
	
	// 设置缓冲区大小
	COORD bufferSize = {GAME_WIDTH * 2 + 21, GAME_HEIGHT + 6};
	SetConsoleScreenBufferSize(hConsole, bufferSize);
}
```

`initConsole()` 函数的设计目的是初始化控制台的显示环境，以确保俄罗斯方块游戏在控制台中的布局和表现方式达到预期效果。具体的设计需求和各部分的实现原因如下：

- 获取控制台句柄

  - ```c
    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    ```

    **需求**：程序需要能够**直接控制控制台输出的位置、光标状态**等，因此需要获得控制台的句柄(具体属性)。

    **原因**：句柄 (`hConsole`) 是一个标识符，用于与操作系统通信，让程序能够操控控制台的属性，如光标的位置和窗口大小。

- 隐藏光标

  - ```c
    cursorInfo.dwSize = 1;
    cursorInfo.bVisible = FALSE;
    SetConsoleCursorInfo(hConsole, &cursorInfo);
    ```

    **需求**：游戏界面不需要光标，这样玩家在观看游戏画面时，不会被光标的闪烁干扰。

    **原因**：光标的隐藏设置可以让显示效果更整洁，让用户只专注于游戏内容。`dwSize` 是光标的大小，而 `bVisible` 设置为 `FALSE` 隐藏光标。

- 设置控制台窗口大小

  - ```c
    SMALL_RECT windowSize = {0, 0, GAME_WIDTH * 2 + 20, GAME_HEIGHT + 5};
    SetConsoleWindowInfo(hConsole, TRUE, &windowSize);
    ```

    **需求**：确保控制台窗口的大小能够**显示完整的游戏区域和附加信息（如分数等）**。

    **原因**：窗口大小需要根据 `GAME_WIDTH` 和 `GAME_HEIGHT` 的游戏区域参数进行设置。这里的大小 `(GAME_WIDTH * 2 + 20, GAME_HEIGHT + 5)` 会根据游戏的宽度和高度动态调整。游戏区以外的额外空间可以显示分数、提示信息等附加内容。

- 设置控制台缓冲区大小

  - ```
    COORD bufferSize = {GAME_WIDTH * 2 + 21, GAME_HEIGHT + 6};
    SetConsoleScreenBufferSize(hConsole, bufferSize);
    ```

    **需求**：控制台缓冲区应该与窗口大小一致，以避免滚动条的出现，使得游戏区域固定显示，不会因为内容多余窗口而产生滚动。

    **原因**：缓冲区的大小要与窗口相匹配，以确保控制台不会因为内容超出窗口大小而导致滚动。`COORD` 结构体的 `bufferSize` 设置要稍大于窗口尺寸，以确保显示效果流畅。

- **总结**

  `initConsole()` 函数的各个步骤确保游戏的控制台界面显示简洁、固定并且无滚动干扰。这些设置在控制台游戏开发中是常见的，因为控制台环境不像图形化界面那样能够灵活调整和刷新，需要手动设置窗口和缓冲区来确保布局的稳定性。

### 光标的移动位置设计

**这个函数的设计需求是什么？为什么这么写？不是通过控制台句柄隐藏了吗？**

```c
// 移动光标位置
void gotoxy(int x, int y) {
	cursorPos.X = x;
	cursorPos.Y = y;
	SetConsoleCursorPosition(hConsole, cursorPos);
}
```

`gotoxy()` 函数的设计需求是能够将控制台光标精确地移动到指定的 `(x, y)` 坐标位置，以便在需要的地方更新显示内容(**新方块的产生和显示都需要参考位置**)。虽然光标是隐藏的（通过 `initConsole` 的设置），但在更新控制台显示时，光标位置的控制仍然是必要的。这里是它的具体需求和设计原因：

#### 1. 需求：实现定点更新显示

- **需求**：游戏在控制台上需要**频繁更新特定位置的内容（如方块、边界、分数等）**。为了避免清除整个控制台再重新绘制（**重新输出整个界面会导致闪烁，影响用户体验**），`gotoxy()` 可以**直接移动光标到某个具体位置进行局部更新。**
- **原因**：这样能有效地减少屏幕闪烁并提升渲染效率，因为只需更新变化的部分，避免刷新整个游戏界面。

#### 2.如何工作：控制光标位置

```c
cursorPos.X = x;
cursorPos.Y = y;
SetConsoleCursorPosition(hConsole, cursorPos);
```

**操作**：`cursorPos` 是一个 `COORD` 结构，用于存储光标的目标坐标。`SetConsoleCursorPosition()` 函数会将光标移动到 `(x, y)`。

**目的**：这种控制使得光标可以精确定位在控制台的任何位置，为显示内容指定输出点。

#### 3.隐藏光标 VS 定位光标

- **隐藏光标**：`initConsole` 中隐藏光标 (`bVisible = FALSE`) 是为了不让用户看到光标闪烁，但隐藏光标并不影响 `gotoxy()` 定位光标位置。隐藏光标只是让光标不可见，而 `gotoxy()` 仍然让程序控制其在指定位置上进行输出。
- **定位光标**：虽然光标不可见，但它的当前位置仍然决定了控制台输出的起点。`gotoxy()` 实际上是为了精确地在控制台中更新某个区域内容（如下一步的方块位置），而不受用户视角影响。

#### 4.总结

`gotoxy()` 的作用是为了实现精准位置更新，而光标的隐藏仅仅是为了视觉效果的优化。这种设计保证了游戏在控制台上实现定点显示更新，既不会影响用户体验，也能实现快速、无闪烁的显示效果。

### 游戏区域与方块的总体设计

**游戏区域（不是整体边界，不包括分数等其他区域，只包括方块可以移动的区域+边界）和边界是一个二维数组，而方块也是存放在一个二维数据中，那么相当于一个小的二维数组在一个大的二维数组中移动，保存？ 这在逻辑上行的通吗？抽象能力不够**

是的，确实可以把这个游戏逻辑理解为“小的二维数组在大的二维数组中移动和存放”，这种抽象方式在逻辑上行得通，而且非常有效！

#### 具体逻辑

1. **大二维数组表示游戏区域和边界**：
   - `game->board` 是一个 `GAME_HEIGHT x GAME_WIDTH` 的二维数组，用于表示游戏区域（包括边界）。`1` 表示边界或固定方块，`0` 表示空白。
2. **小二维数组表示方块形状**：
   - `Block` 结构体中的 `shape[4][4]` 存储方块形状，例如 `I`、`L`、`O` 等方块。每个 `1` 表示方块的一个小块（单元），而 `0` 表示空白。
3. **小数组在大数组中移动**：
   - 在游戏中，方块从顶部出现并逐渐向下移动，相当于小的二维数组（方块形状）“叠加”在大的二维数组上。
   - 每当玩家移动方块时（左右、旋转、加速下落），程序会调整方块的位置，然后检查是否与 `board` 上的其他方块或边界发生碰撞。
4. **逻辑上的抽象**：
   - 可以将 `board` 看成一个“画布”，而 `shape` 是在画布上移动的“图形”。每次更新都重新绘制该图形在新位置上的状态。
   - 当方块落到底部或碰撞固定方块时，程序将方块合并到 `board` 上，形成新的固定图案，保持二维数组的一致性。

#### 这种抽象的优点

- **直观**：逻辑简单明确，可以很自然地映射出方块的移动和边界的碰撞检测。
- **简洁性**：通过二维数组的结构，避免了大量的单独变量来表示每个小块的位置状态。
- **可扩展性**：后续添加新的方块形状或变换方式，只需定义新的二维数组形状，不需要大改游戏逻辑。

这种设计的简洁和效率确实体现了程序设计中利用数据结构（二维数组）来简化游戏逻辑的抽象能力。

### 生成新方块的逻辑

**生成新方块的逻辑是什么？这个只是随机生产新方块而已对吗？并存放到shape[i][j]二维数组中？光标位置设置的依据是什么？**

这段 `generateNewBlock` 函数的主要逻辑是随机生成一个新方块，并设置其初始位置，以便它从屏幕顶部中央开始下落。具体来说，它的设计包含以下几个步骤：

**1.随机选择方块形状**

- 使用 `rand() % 3` 生成一个随机数 `shape_idx`，用于选择一个形状。
- `SHAPES` 是一个方块形状的集合（三维数组存的都是每一个方块形状的二维数组），其中每种形状是一个 `4x4` 的二维数组。例如，`SHAPES[0]` 可以是一个“L”形的方块，`SHAPES[1]` 是一个“Z”形方块，依此类推。
- 随机选择的 `shape_idx` 决定了当前生成的方块形状。

**2.初始化方块形状到当前方块的 `shape` 数组**

- 使用**双层循环**将 `SHAPES[shape_idx]` 里的数据复制到 `game->current_block.shape` 中。
- 这样就把当前方块的形状数据存入 `current_block` 的 `shape[i][j]` 中，**使其具有选定形状的配置。**

**3.设置初始位置**

- `current_block.x = GAME_WIDTH / 2 - 2`：方块水平居中，起始位置是游戏区域宽度的一半（中心点）向左偏移 2 个单位，使方块中心对齐。
- `current_block.y = 0`：将方块起始高度设置为 `0`，即顶部。
- **保证新方块从游戏区域的中心顶部开始下落**

**4.碰撞检测**

- 生成方块之后，立即调用 `checkCollision` 来检测方块是否与其他固定方块或边界发生碰撞。
- 如果在起始位置有碰撞，意味着没有足够空间生成新的方块，此时设置 `game->game_over = 1`，游戏结束。

#### 生成新方块的逻辑总结

- 这个函数不仅随机生成一个新方块，还设置了它的初始位置并检测初始状态下的碰撞，以确保游戏的正确性和流畅性。如果没有使用这种集中初始化，生成方块的位置和形状会分散到其他代码部分，从而增加管理复杂性。

这种逻辑设计确保了方块生成的合理性和位置的一致性，使游戏界面的方块运动更加流畅。

#### 三维数组复制到二维数组

**SHAPES是一个三维数组？数组中存放了每一个方块形状的二维数组，当随机数作为id时，就可以从三维数组中拿出一个方块的二维数组来？ 三维数组还是抽象为一个大的一维数组里面存放的是两个二维数组好理解一点？**

是的，`SHAPES`确实是一个三维数组，其结构可以理解为一个大数组，里面每个元素都是一个方块形状的二维数组。这样，当随机数作为索引时，可以直接从`SHAPES`里提取一个特定的形状。这个设计允许程序在生成新方块时轻松获得不同的形状。

将`SHAPES`理解成一个一维数组，内部存储二维数组是有效的抽象思路。它可以更直观地理解为：“一个大数组，里面每个元素都是一个特定方块的二维数据。”



**三维数组中的元素复制到一个二维数组中？这在逻辑上的实现是怎么样的？ 使用双层循环将 SHAPES[shape_idx] 里的数据复制到 game->current_block.shape 中。**

是的，`generateNewBlock` 函数中使用双层循环，将 `SHAPES[shape_idx]` 中的二维数组元素逐一复制到 `game->current_block.shape` 中，以初始化新方块的形状。下面是逻辑的详细解释：

1. `SHAPES` 是一个三维数组，形状为 `SHAPES[shape_idx][4][4]`，其中 `shape_idx` 是方块的类型索引。例如，`SHAPES[0]` 是 I 形方块，`SHAPES[1]` 是 L 形方块。

2. `game->current_block.shape` 是一个二维数组，形状为 `shape[4][4]`，用于存储当前方块的形状。

3. 双层循环的作用是遍历 `SHAPES[shape_idx]` 的每个元素，把它们赋值给 `game->current_block.shape`。

4. ```c
   for (int i = 0; i < 4; i++) {
       for (int j = 0; j < 4; j++) {
           game->current_block.shape[i][j] = SHAPES[shape_idx][i][j];
       }
   }
   ```

   在逻辑上，`SHAPES[shape_idx]` 可以视作一个二维数组，表示某个特定方块的形状。通过双层循环遍历 `i` 和 `j`，可以将 `SHAPES[shape_idx]` 的二维元素完整复制到 `game->current_block.shape`，从而初始化新生成的方块形状。这种方法确保了方块的形状能按照定义正确呈现，并可在后续的逻辑中被使用。

**其实当shape_idx拿到之后，SHAPES[shape_idx]就相当于是一个二维数组了， 那就是把一个二维数组的所有元素复制到一个新的二维数组而已？**

完全正确！一旦获取了 `shape_idx` 后，`SHAPES[shape_idx]` 就是一个具体的二维数组了。此时，`generateNewBlock` 函数的任务就是将 `SHAPES[shape_idx]`（一个二维数组）的每个元素复制到 `game->current_block.shape`（另一个二维数组）。

具体地说：

- `SHAPES[shape_idx]` 已是一个 `4x4` 的二维数组，表示特定方块的形状。
- 双层循环遍历 `SHAPES[shape_idx]` 中的所有元素，并将它们一一复制到 `game->current_block.shape` 对应位置。

代码片段中的复制操作就是一个简单的二维数组元素逐个复制过程。这种逻辑不仅清晰明了，而且高效，确保了新方块的形状与定义的 `SHAPES` 完全一致。

### 逻辑数据可视化为游戏界面

是的,这个drawGame函数的主要目的是将游戏的逻辑数据转换成可视化的界面。让我详细解析一下它的实现逻辑:

#### 缓冲区设计

```c
char buffer[GAME_HEIGHT][GAME_WIDTH * 2 + 1];
```

为什么宽度要 *2+1?

- 因为每个方块位置用两个字符表示(比如空白用"  "，方块用"■")
- +1 是为了在每行末尾存放字符串结束符'\0'

**缓冲区的大小有疑问：** 高度我可以理解，因为整个方块可以上下移动的区域都需要缓冲区， 宽度为什么不是方块左右可以移动的区域？是因为整个界面是由游戏区域+边界+右边的计数区域，他们都要缓冲区以达到局部更新的效果，避免闪屏？

- 实际上，这个缓冲区只是用于游戏主区域（包括边界）的显示，而不包含右边的计分区域。宽度为`GAME_WIDTH * 2 + 1`的原因是：

  - `GAME_WIDTH`的定义是12，这包含了：

  - ```
    左边界(1格) + 游戏活动区域(10格) + 右边界(1格)
    ```

  - 为什么要 `* 2`：
    - 因为每个游戏格子使用两个字符来显示
    - 比如空白格用两个空格" "
    - 方块用两个字符组成一个完整的方块"■"(由0xA1,0xF6这两个字符组成)
  - 为什么要 `+ 1`：
    - 这是为了在每行末尾添加字符串结束符'\0'
    - 因为后面使用printf("%s")打印时需要字符串结束符

- 右边的计分区域（Score显示）是单独处理的：

  - ```c
    // 显示分数 - 这部分不使用缓冲区，而是直接打印
    gotoxy(GAME_WIDTH*2 + 2, 0);  // 移动到游戏区域右侧
    printf("Score: %d", game->score);
    ```

  - ```
    游戏区域的实际显示（每个数字代表占用的字符数）：
    ■■■■■■■■■■■■   Score: 100
    ■          ■
    ■          ■
    ■    ■■    ■
    ■    ■■    ■
    ■          ■
    ■          ■
    ■■■■■■■■■■■■
    
    缓冲区布局：
    [0,0]  [0,1]  [0,2] ... [0,23] [\0]  -- 第一行，24个字符+结束符
    [1,0]  [1,1]  [1,2] ... [1,23] [\0]  -- 第二行
    ...
    ```

- 所以你最初的理解有一点不太准确：缓冲区只负责游戏主区域（包括边界）的显示，而右边的计分区域是直接打印的，不经过缓冲区。这样的设计可能是因为：

  1. **游戏主区域需要频繁整体更新，用缓冲区可以减少闪烁**
  2. **计分区域变化频率较低，直接打印就够用了**(因为只有一小块，如果加进来，就要浪费大块缓冲区？)

- 因为只有一小块，如果加进来，就要浪费大块缓冲区？

  - ```c
    // 当前缓冲区大小
    char buffer[GAME_HEIGHT][GAME_WIDTH * 2 + 1];
    // 20 * (24 + 1) = 500 字节
    
    // 如果包含计分区域
    // 假设计分区域宽度为10个字符
    char buffer[GAME_HEIGHT][(GAME_WIDTH * 2 + 10) + 1];
    // 20 * (24 + 10 + 1) = 700 字节
    ```

  - 计分区只需要很小的显示区域(比如"Score: 100")

  - 但为了保持缓冲区矩形结构,会导致每一行都要多分配这些空间

  - 这些额外空间大多数行都是浪费的

  - 更新频率不同:

    - ```c
      // 游戏区域 - 需要频繁整体刷新
      - 活动方块每帧都在移动
      - 每一行都可能有变化
      - 需要缓冲区来防止闪烁
      
      // 计分区域 - 更新频率低
      gotoxy(GAME_WIDTH*2 + 2, 0);
      printf("Score: %d", game->score);
      - 只在得分变化时才更新
      - 局部更新就足够
      ```

    - 这是空间和效率的权衡:

      - 小区域用直接打印 -> 省内存
      - 大区域用缓冲区 -> 防闪烁,提高性能

  - 这也是一个很好的优化设计思路：根据不同区域的特点(更新频率、大小)采用不同的处理策略。

#### 数据准备过程

```c
for(int i = 0; i < GAME_HEIGHT; i++) {
    for(int j = 0; j < GAME_WIDTH; j++) {
        int value = game->board[i][j];
```

- 首先获取游戏板上的基础数据(0表示空白,1表示已固定的方块)

#### 活动方块的处理

```c
for(int bi = 0; bi < 4; bi++) {
    for(int bj = 0; bj < 4; bj++) {
        if(game->current_block.shape[bi][bj] &&
           i == game->current_block.y + bi &&
           j == game->current_block.x + bj) {
            value = 2;
        }
    }
}
```

- 检查当前位置是否与活动方块重叠

- 如果重叠则将value设为2,表示这里要显示活动方块

#### 字符映射

```c
switch(value) {
    case 0: // 空白
        buffer[i][j*2] = ' ';
        buffer[i][j*2+1] = ' ';
        break;
    case 1: // 边界或固定方块
        buffer[i][j*2] = 0xA1;
        buffer[i][j*2+1] = 0xF6;
        break;
    case 2: // 活动方块
        buffer[i][j*2] = 0xA1;
        buffer[i][j*2+1] = 0xF1;
        break;
}
```

- 将不同的value值映射成对应的显示字符
- 0xA1和0xF6等是用来显示方块图形的特殊字符编码

#### 显示过程

```c
for(int i = 0; i < GAME_HEIGHT; i++) {
    gotoxy(0, i);
    printf("%s", buffer[i]);
}
```

- 使用gotoxy移动光标位置
- 一次性打印整行数据,提高效率

整个函数的设计思路是:

1. 先在内存中准备好所有要显示的数据(构建缓冲区)
2. 把游戏逻辑状态转换成显示字符
3. 最后一次性绘制到屏幕上

这种设计有两个主要优点:

1. 减少闪烁 - 因为是一次性绘制
2. 提高效率 - 减少了频繁的屏幕IO操作

### 碰撞检测

**游戏抽象起来就是：一个小的表示方块的二维数组在一个大的表示游戏区域的二维数组中移动，那么如何来判断是否碰撞？逻辑上如何实现小二维数组在大二维数组中移动？抽象能力不行**

你理解得很正确，整个游戏可以抽象为一个小的二维数组（方块）在一个大二维数组（游戏区域）中移动。为了检测碰撞，`checkCollision`函数遍历了方块数组中的每个有效元素（非零部分），并将它们的坐标映射到游戏区域的坐标系中。

具体来说，函数的逻辑流程如下：

1. **坐标映射**：对方块中的每个元素 `(i, j)`，将其位置转换成游戏区域的坐标 `(board_y, board_x)`，计算公式是：

   ```c
   board_y=current_block.y+i\text{board\_y} = \text{current\_block.y} + iboard_y=current_block.y+i
   
   board_x=current_block.x+j\text{board\_x} = \text{current\_block.x} + jboard_x=current_block.x+j
   ```

2. **边界检查**：然后检查转换后的坐标是否越界。对于 `board_x`，检查是否在 `0` 和 `GAME_WIDTH - 1` 之间；对 `board_y`，检查是否在 `0` 和 `GAME_HEIGHT - 1` 之内。如果超出这些边界，表示碰撞。

3. **内容检查**：在转换后的 `(board_y, board_x)` 坐标位置，判断游戏区域中的 `board` 数组中是否有障碍物（即非零元素）。如果有，也视为碰撞。

当任何一个方块的映射坐标越界或与游戏区域中的障碍物重叠时，即视为碰撞并返回 `1`。

#### 映射关系的依据

**游戏区域的坐标是全局的，但是方块已经不是居中了吗？完全可以逐一对应啊？ * `current_block.x = GAME_WIDTH / 2 - 2`：方块水平居中，起始位置是游戏区域宽度的一半（中心点）向左偏移 2 个单位，使方块中心对齐。 * `current_block.y = 0`：将方块起始高度设置为 `0`，即顶部。**

**加上光标偏移量后才是一 一对应。后续方块的全局坐标也是如此换算。**

啊，现在我明白你的问题了！让我解释这个坐标映射关系：

```c
// 在绘制或碰撞检测时的坐标映射
int board_y = game->current_block.y + i;  // i 是在方块4x4网格中的行索引
int board_x = game->current_block.x + j;  // j 是在方块4x4网格中的列索引
```

这个映射关系是为了将方块的局部坐标(4x4网格中的位置)转换为游戏区域的全局坐标：

**1.方块位置已经确定了全局起点：**

**这是生成方块的游戏区域居中光标坐标**

```c
current_block.x = GAME_WIDTH / 2 - 2;  // 水平居中的起始点
current_block.y = 0;                   // 顶部起始点
```

**2.需要遍历方块的每个部分：**

```c
for(int i = 0; i < 4; i++) {
		for(int j = 0; j < 4; j++) {
			if(game->current_block.shape[i][j]) {
				int board_y = game->current_block.y + i;
				int board_x = game->current_block.x + j;
				
                  //转换为大二维数组后，就开始判断这个位置是否有1？有的话就返回1，回退操作交给其他人
				if(board_x < 0 || board_x >= GAME_WIDTH ||
					board_y >= GAME_HEIGHT ||
					game->board[board_y][board_x]) {
					return 1;
				}
			}
		}
	}
```

**3.坐标转换的必要性：**

- 每个方块都是在4x4网格中定义的(局部坐标系)
- 但需要在游戏区域中显示(全局坐标系)
- 通过 current_block.(x/y) + (i/j) 实现从局部到全局的转换

**4.比如对于某个方块片段：**

```c
// 假设方块起始位置是(4,0)
current_block.x = 4
current_block.y = 0

// 对于方块中的点(1,1)
board_y = 0 + 1 = 1  // 全局y坐标
board_x = 4 + 1 = 5  // 全局x坐标
```

这个映射是必要的，因为：

1. 方块定义是在固定大小的网格中(局部坐标)
2. 需要将每个方块片段放到正确的游戏位置(全局坐标)
3. **通过起始点+偏移实现这个转换**
   1. 方块在shape[i] [j]中的坐标是从0开始的，并不逐一对应大的游戏区域二维数组
   2. 加上光标偏移量后才对应游戏区域的二维数组
   3. 因为方块在游戏区域中的坐标是加上光标偏移量后

所以这不是简单的"逐一对应"，而是一个坐标系统的转换过程。

### 合并方块

**简单来说就是把方块的非零部分坐标转换为游戏区域的坐标，与大的二维数组进行判断，首先判断方块坐标是否超出顶部边界，再就是查看大的二维数组中是否已经有方块了，已经有方块了应该是1，那怎么合并方块呢？**

合并方块的过程实际上是将方块的内容"固定"到游戏区域的二维数组（即 `board`）中。实现的关键在于把当前活动方块的每个“非零”单元的位置，在 `board` 上**对应地标记为 `1`**，表示这些位置被占据了。**这个操作通常在方块“落地”或“碰撞”后执行，确保方块不会再移动。**

逻辑步骤如下：

1. **遍历方块数组**：遍历 `current_block.shape` 的所有单元格。

2. **判断非零部分**：只对值非零的单元格进行操作（`shape[i][j] != 0`）。

3. **计算位置**：将方块的相对坐标 `(i, j)` 转换为 `board` 上的绝对坐标 `(board_y, board_x)`，即

   1. ```c
      int board_y = game->current_block.y + i;
      int board_x = game->current_block.x + j;
      ```

4. **更新 board**：在 `board` 中对应位置 `board[board_y][board_x]` 赋值为 `1`。

5. ```c
   void mergeBlockToBoard(GameState *game) {
       for (int i = 0; i < 4; i++) {
           for (int j = 0; j < 4; j++) {
               if (game->current_block.shape[i][j]) {
                   int board_y = game->current_block.y + i;
                   int board_x = game->current_block.x + j;
                   game->board[board_y][board_x] = 1;
               }
           }
       }
   }
   ```

   这样，活动方块就会“锁定”在 `board` 上，从而成为游戏区域固定的一部分。

**方块的坐标映射到游戏区域二维数组坐标的依据呢？ 我以为直接可以逐一对应呢？**

方块的坐标需要映射到游戏区域二维数组的依据在于，方块的坐标在 `current_block.shape` 中是**相对的**，而游戏区域中的坐标是**全局的**。因此，为了将方块的局部坐标准确放置到游戏区域中，我们需要通过加上方块的当前位置 `(x, y)` 来实现这一转换。

具体而言：

1. **方块相对位置**：`current_block.shape[i][j]` 中的 `(i, j)` 是方块形状的**局部坐标**，即在方块的4x4区域中，它们从 `(0, 0)` 开始。
2. **游戏区域中的绝对位置**：方块在整个游戏区域的**全局坐标**取决于 `current_block` 的 `x` 和 `y` 位置。
3. 映射计算：
   - `int board_y = game->current_block.y + i;`：`board_y` 是方块在游戏区域中的垂直坐标，等于方块的 `y`（即方块左上角在游戏区域中的纵坐标）加上局部坐标 `i`。
   - `int board_x = game->current_block.x + j;`：`board_x` 是方块在游戏区域中的水平坐标，等于方块的 `x` 加上局部坐标 `j`。

通过这种映射，可以把方块的相对坐标精确地转换成游戏区域的全局坐标，以便检查碰撞或进行合并。

#### 合并逻辑

**碰撞后，方块在小二维数组中的有效1和游戏区域大二维数组的有效1（有可能是边界或者是已经存在的方块），重叠之后，转换后的方块坐标是怎么存入大二维数组的？碰撞后是要在大二维数组坐标位置上移一个位置进行存放吗？**

**方块在碰撞前的操作**：

- 方块通过 `autoFall` 函数自动下落。
- 每次调用时，`game->current_block.y++`，方块的纵坐标加1，模拟自然下落的过程。
- 紧接着调用 `checkCollision(game)` 检查是否发生碰撞。

**碰撞后的回退**：

- 如果检测到碰撞（返回值为1），说明当前方块的下一个位置与游戏区域的边界或已有方块重叠。
- 为了避免方块直接穿过其他方块或超出边界，`game->current_block.y--` 将方块位置上移回碰撞前的位置。

**合并方块到游戏区域**：

- 调用 `mergeBlock(game)`，将当前方块在 **小二维数组（`shape`）** 中的有效部分（即非零部分）转换为 **大二维数组（`board`）** 的对应位置。
- 在这个过程中，不需要再上移一个位置存放，因为 `checkCollision` 的作用确保了 `mergeBlock` 总是在**安全位置**执行。

**为什么不需要额外上移？**

- 方块本身已经在 `autoFall` 中尝试移动到 `(x, y+1)`。
- 如果此时发生碰撞，`checkCollision` 会立即检测到，说明 `y+1` 无效。
- 将 `y` 还原到碰撞前的位置 `(y)` 后，`mergeBlock` 直接将非零部分“写入”当前有效位置，而不需要再移动。

**总结**

- **碰撞检测**负责确保 `mergeBlock` 总是在**有效区域**操作。
- **方块存放**在碰撞位置的上一层游戏区域（通过 `game->current_block.y--` 还原），逻辑合理且无需额外调整坐标。

### 下落过程中的综合逻辑

```c
// 自动下落
void autoFall(GameState *game) {
	game->current_block.y++;
	if(checkCollision(game)) {
		game->current_block.y--;
		mergeBlock(game);
		generateNewBlock(game);
	}
}
```

纵轴每下落一个位置，就要检测碰撞没有（包括落地和碰撞到已经存在的方块情况），如果碰撞了，方块就要回退一个位置，并开始合并方块，搞定之后就可以重新生成新的方块了

## 初始项目架构（稍后）

为了让项目更容易维护，我们可以按照功能模块来组织文件结构。

```c
// 项目结构：
/*
tetris/
│
├── include/                    // 头文件目录
│   ├── game.h                 // 游戏核心数据结构和函数声明
│   ├── console.h              // 控制台相关函数声明
│   ├── block.h                // 方块相关定义和函数声明
│   └── config.h               // 游戏配置和常量定义
│
├── src/                       // 源文件目录
│   ├── main.c                 // 主程序入口
│   ├── game.c                 // 游戏核心逻辑实现
│   ├── console.c              // 控制台操作实现
│   └── block.c                // 方块操作实现
│
└── Makefile                   // 项目编译配置
*/

// 1. config.h - 游戏配置和常量定义
#ifndef TETRIS_CONFIG_H
#define TETRIS_CONFIG_H

// 游戏区域大小
#define GAME_HEIGHT 20
#define GAME_WIDTH 12

// 游戏速度配置
#define FALL_SPEED 20
#define GAME_DELAY 50

// 方块类型
#define BLOCK_TYPES 3

// 游戏显示字符
#define EMPTY_CELL "  "
#define WALL_CELL "□"
#define BLOCK_CELL "■"

#endif // TETRIS_CONFIG_H

// 2. block.h - 方块相关定义
#ifndef TETRIS_BLOCK_H
#define TETRIS_BLOCK_H

// 方块结构体定义
typedef struct {
    int shape[4][4];
    int x, y;
} Block;

// 方块操作函数声明
void initializeShapes(void);
void generateNewBlock(Block *block);
const int (*getBlockShapes(void))[4][4];

#endif // TETRIS_BLOCK_H

// 3. console.h - 控制台操作
#ifndef TETRIS_CONSOLE_H
#define TETRIS_CONSOLE_H

#include <windows.h>

// 控制台操作函数声明
void initConsole(void);
void gotoxy(int x, int y);
void hideCursor(void);
void setConsoleSize(void);

// 控制台句柄和坐标声明
extern HANDLE hConsole;
extern COORD cursorPos;

#endif // TETRIS_CONSOLE_H

// 4. game.h - 游戏核心逻辑
#ifndef TETRIS_GAME_H
#define TETRIS_GAME_H

#include "block.h"

// 游戏状态结构体
typedef struct {
    int board[GAME_HEIGHT][GAME_WIDTH];
    int score;
    Block current_block;
    int game_over;
} GameState;

// 游戏操作函数声明
void initGame(GameState *game);
void drawGame(const GameState *game);
int checkCollision(const GameState *game);
void mergeBlock(GameState *game);
void moveBlock(GameState *game, int dx);
void rotateBlock(GameState *game);
void handleInput(GameState *game, char key);
void updateGame(GameState *game);

#endif // TETRIS_GAME_H

// 5. main.c - 主程序入口
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "game.h"
#include "console.h"
#include "config.h"

int main() {
    GameState game;
    char key;
    
    // 初始化
    srand((unsigned int)time(NULL));
    initConsole();
    initGame(&game);
    
    // 游戏主循环
    while(!game.game_over) {
        // 绘制游戏界面
        drawGame(&game);
        
        // 处理输入
        if(_kbhit()) {
            key = _getch();
            handleInput(&game, key);
        }
        
        // 更新游戏状态
        updateGame(&game);
        
        Sleep(GAME_DELAY);
    }
    
    // 游戏结束处理
    gotoxy(GAME_WIDTH*2 + 2, 2);
    printf("Game Over!");
    gotoxy(0, GAME_HEIGHT + 1);
    
    return 0;
}

// 6. Makefile - 项目编译配置
CC = gcc
CFLAGS = -Wall -I./include
SRCDIR = src
OBJDIR = obj

SOURCES = $(wildcard $(SRCDIR)/*.c)
OBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)

tetris: $(OBJECTS)
	$(CC) $(OBJECTS) -o tetris

$(OBJDIR)/%.o: $(SRCDIR)/%.c
	@mkdir -p $(OBJDIR)
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -rf $(OBJDIR) tetris.exe
```

这样组织代码的好处：

1. 模块化：
   - 每个模块负责特定的功能
   - 代码更容易理解和维护
   - 便于多人协作开发
2. 封装性：
   - 通过头文件定义接口
   - 实现细节在源文件中隐藏
   - 降低模块间的耦合度
3. 可扩展性：
   - 容易添加新功能
   - 方便修改现有功能
   - 便于添加新的方块类型或游戏模式
4. 配置集中：
   - 游戏参数集中在 config.h
   - 便于调整游戏难度和显示效果
   - 方便本地化和定制化

要开发新功能，你可以：

1. 在相应的头文件中声明新函数
2. 在对应的源文件中实现功能
3. 如果是全新的模块，创建新的头文件和源文件对

例如，如果你想添加分数系统：

1. 在 game.h 中添加分数相关函数声明
2. 在 game.c 中实现这些函数
3. 在 config.h 中添加分数配置
