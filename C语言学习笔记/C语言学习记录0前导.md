# C语言学习记录0前导

## 学习建议

- 掌握概念的正确性
- 具备动手能力
- 阅读优秀的程序段
- 大量的练习，面试题

## C 语言程序的执行过程

C源文件—>预处理—>编译—>汇编—>链接—>可执行文件

C 语言程序的执行过程可以分为几个主要阶段：从源代码到最终生成可执行文件，涉及到**预处理**、**编译**、**汇编**和**链接**。

### **C 源文件（`.c` 文件）**

这是你编写的 C 语言代码。通常保存为 `.c` 文件，它是 GCC 处理的起点。

### **预处理（Preprocessing）**

**命令：** `gcc -E myprogram.c -o myprogram.i`

**文件后缀：** `.i`

**过程：**

- 预处理器会处理所有以 `#` 开头的预处理指令，例如 `#include`、`#define`、`#ifdef` 等。
- 它会将 `#include` 头文件展开，把这些头文件的内容插入到源文件中。
- 它还会处理宏替换（`#define` 定义的宏）和条件编译指令（如 `#ifdef`）。
- 生成的文件是纯粹的 C 代码，没有预处理指令，通常后缀为 `.i`。

**输出：** 预处理后的源文件，扩展名为 `.i`。

### **编译（Compilation）**

**命令：** `gcc -S myprogram.i -o myprogram.s`

**文件后缀：** `.s`

**过程：**

- 编译器将预处理后的 C 代码（`.i` 文件）翻译成汇编代码。汇编代码是针对具体架构的低级指令，如 x86 或 ARM 的汇编指令。
- 这一步生成的是汇编语言的源代码文件，通常以 `.s` 为后缀。

**输出：** 汇编代码文件，扩展名为 `.s`。

### **汇编（Assembly）**

**命令：** `gcc -c myprogram.s -o myprogram.o`

**文件后缀：** `.o`

**过程：**

- 汇编器将汇编代码转换成目标代码（机器代码），即计算机可以理解的二进制指令。生成的目标文件是二进制格式，通常以 `.o` 为后缀。
- 每个 C 源文件都会编译成一个对应的目标文件。

**输出：** 目标文件，扩展名为 `.o`。

### **链接（Linking）**

**命令：** `gcc myprogram.o -o myprogram`

**文件后缀：** （无扩展名或 `.exe`）

**过程：**

- 链接器将多个目标文件（以及库文件）合并，生成一个完整的可执行文件。目标文件可能包含多个引用的外部函数和变量，链接器负责将这些符号解析为具体的地址。
- 如果你的程序依赖于外部库（如标准 C 库），链接器还会将这些库文件连接进来。
- 最终的输出是一个可以运行的可执行文件。

**输出：** 可执行文件，通常没有扩展名（Linux 下），或者在 Windows 下是 `.exe` 文件。

### 总结：

1. **源文件**（`.c`） → **预处理** → **预处理文件**（`.i`）
2. **预处理文件**（`.i`） → **编译** → **汇编文件**（`.s`）
3. **汇编文件**（`.s`） → **汇编** → **目标文件**（`.o`）
4. **目标文件**（`.o`） → **链接** → **可执行文件**（无扩展名或 `.exe`）

### GCC 的各个阶段总结

- **`gcc -E`**：只进行预处理，输出预处理文件（`.i`）。
- **`gcc -S`**：进行编译（到汇编），输出汇编文件（`.s`）。
- **`gcc -c`**：进行汇编（生成目标文件），输出目标文件（`.o`）。
- **`gcc`**：默认进行预处理、编译、汇编和链接，最终生成可执行文件。

## 条件编译

条件编译是C语言的一种预处理机制，主要用于根据特定条件选择性地编译代码。它的产生背景可以归结为以下几个方面：

1. **跨平台开发**
   在C语言流行的早期，程序通常需要在**不同的硬件平台和操作系统之间移植**。不同平台可能提供不同的库函数或硬件支持，需要对同一代码做平台相关的调整。
2. **代码优化与维护**
   有时需要根据运行环境或需求**屏蔽掉不必要的代码（如调试代码、测试代码）**，以减少生成的二进制文件大小或提高运行效率。
3. **版本控制**
   软件通常有多个版本（如免费版与专业版），需要用条件编译来区分功能，避免维护多套代码。
4. **硬件或功能支持差异**
   嵌入式开发中，硬件资源有限且可能差异很大，条件编译允许程序适配不同的硬件配置或功能模块。

### **应用场景**

1. **跨平台支持**
   在不同的操作系统上运行相同的程序，需要针对特定平台编译特定代码。例如：

```c
#ifdef _WIN32
    printf("Running on Windows\n");
#elif __linux__
    printf("Running on Linux\n");
#else
    printf("Unknown platform\n");
#endif
```

2. **调试和发布版本切换**
   在开发阶段需要保留调试信息，而发布版本则不需要：

```c
#ifdef DEBUG
    printf("Debug mode enabled\n");
#endif
```

3. **功能模块选择**
   不同的产品版本可能支持不同的功能：

```c
#ifdef FEATURE_X
    enable_feature_x();
#endif
```

4. **硬件适配**
   嵌入式开发中，根据不同的硬件配置选择编译的代码：

```c
#ifdef USE_LCD
    initialize_lcd();
#endif
```

5. **避免重复包含头文件**
   使用条件编译实现头文件的**“防护机制”**：

```c
#ifndef HEADER_FILE_H
#define HEADER_FILE_H
// Header file content
#endif
```

### **条件编译的常用指令**

- `#ifdef` / `#ifndef`：检测宏是否被定义
- `#if` / `#elif` / `#else`：判断表达式是否满足条件
- `#endif`：结束条件编译块
- `#define` / `#undef`：定义和取消宏

------

### **优点与局限性**

- **优点**：
  - 提高代码的灵活性和可移植性。
  - 方便维护不同功能或版本的代码。
- **局限性**：
  - 滥用条件编译会导致代码难以阅读和维护。
  - 依赖宏定义可能隐藏潜在的问题（如宏冲突或逻辑复杂化）。

条件编译是一种强大的工具，但应谨慎使用，以避免代码的可读性和可维护性下降。



### 头文件本质与重复包含原理

**在C语言中，#include 只是简单的插入头文件中的内容？ 不加条件编译就会插入多次？这不是正常需求吗？但是当头文件中定义了宏和结构体时，就会被重复定义是吗？**

**`#include`的作用**

`#include` 指令的作用是在[预处理阶段](###**预处理（Preprocessing）**)**将指定的头文件的内容直接插入到当前源文件中**，就像把头文件的内容复制粘贴到 `#include` 的位置一样。**这种操作是简单且机械化的，不会自动检测是否已经包含过该文件**。

#### **重复包含的问题**

如果一个头文件被多次包含，而没有额外的保护机制，就会导致如下问题：

1. **宏定义重复**

```c
// 在头文件a.h中
#define MAX 100
```

如果某个文件多次包含 `a.h`，就会尝试多次定义 `MAX`，虽然多数编译器会忽略重复定义的宏，但这是潜在的隐患。

2. 结构体定义重复

```c
// 在头文件a.h中
typedef struct {
    int id;
    char name[50];
} Student;
```

如果某个文件多次包含 `a.h`，就会报错，因为结构体的定义不能重复。

3. **函数声明重复** 对于普通函数声明，多次声明是可以接受的，但还是可能产生冗余。

#### **如何解决？（条件编译）**

为了防止头文件被多次包含，通常会使用**条件编译**或**头文件保护机制**，主要有两种方式：

**使用传统的宏定义**

在头文件中添加如下代码：

```c
#ifndef A_H
#define A_H

// 头文件内容
#define MAX 100
typedef struct {
    int id;
    char name[50];
} Student;

#endif // A_H
```

**解释：**

- `#ifndef A_H` 检查宏 `A_H` 是否未被定义。
- 如果未定义，则定义 `A_H` 并插入头文件内容。
- 如果已经定义，则跳过头文件内容。

这种方式被称为**头文件的“包含保护”（Include Guard）**。

**使用 `#pragma once`**

更现代化的一种方式是使用编译器支持的 `#pragma once` 指令：

```c
#pragma once

// 头文件内容
#define MAX 100
typedef struct {
    int id;
    char name[50];
} Student;
```

**优点：**

- 不需要手动写宏名称。
- 防止头文件重复包含，且减少了编译器解析时的额外开销。
- 代码更简洁。

**缺点：**

- 并不是所有编译器都支持（但现代主流编译器如 GCC、Clang、MSVC 都支持）。

**总结**

- `#include` 是简单的内容插入，不加保护机制确实会导致重复定义的问题。
- 为了防止重复包含和定义，应该在每个头文件中使用**包含保护**（推荐使用 `#pragma once` 或 `#ifndef` 的方式）。
- 这样可以让代码更可靠、健壮，同时避免潜在的编译错误或重复定义的问题。

**如果使用了包含保护机制的话，头文件第一次被包含，编译阶段GCC就会处理这个头文件，包括定义宏，声明变量，函数等。第二次被包含时就直接把处理的结果插入即可，而不需要再从头再处理一次头文件导致宏和变量以及结构体的重复定义？**

**GCC 如何处理头文件**

当你使用 `#include` 指令时，GCC 在 **预处理阶段** 会展开头文件。这包括：

1. **首次包含时**：
   - 读取头文件的内容。
   - 按照文件中的指令，**处理**宏定义（`#define`）、变量声明、函数声明、结构体定义等。
   - 如果有条件编译指令（如 `#ifndef`），根据条件判断是否需要保留头文件中的内容。
   - 将头文件的内容插入到源文件中。
2. **再次包含时**：
   - 如果头文件中使用了包含保护（如 `#ifndef`），GCC 会根据条件判断跳过整个头文件的内容，**从而避免重复定义。**
   - 如果没有包含保护，GCC 会**重新读取和处理头文件内容，导致重复定义错误。**

**包含保护机制的作用**

**包含保护的本质**是利用条件编译指令，**确保头文件的内容只被处理一次(一次处理多次被包含，而不是被包含一次处理一次)**：

- 第一次包含时：
  - `#ifndef` 判断发现宏未定义，于是定义宏（`#define`），然后保留头文件的内容。
  - 这些内容被插入到源文件中，GCC 继续处理插入的内容。
- 第二次及以后包含时：
  - `#ifndef` 判断发现宏已经定义，直接跳过头文件的内容。
  - **GCC 不会重复处理宏定义、变量声明、结构体定义等。**

**关键点**：

- 包含保护机制的作用是防止重复处理头文件的内容，而不是优化插入的内容。
- 包含保护不会保存或缓存“处理结果”，**只是简单地跳过多余的处理**。

**没有包含保护机制时的问题**

由于 `main.c` 同时包含了 `a.h` 和 `b.h`，而这两个头文件都间接包含了 `c.h`，这将导致 **`c.h` 被包含两次**，从而引发重复定义的错误。

1. 全局变量重复定义：
   - `c.h` 中定义了一个全局变量 `globalVar`，每次 `a.c` 和 `b.c` 包含 `c.h` 时，都会定义这个变量。这样，`a.c` 和 `b.c` 中都出现了 `globalVar` 的定义，在编译时会发生链接错误（重复定义全局变量）。
2. 结构体重复定义：
   - 同样，`c.h` 中定义了 `Person` 结构体，在 `a.c` 和 `b.c` 中分别使用 `#include "c.h"`，导致编译器认为 `Person` 被定义了两次，最终也会导致重复定义错误。

编译器可能会给出类似以下的错误信息：

```
error: redefinition of 'globalVar'
error: redefinition of 'Person'
```

这是因为 `globalVar` 和 `Person` 都被定义了两次。

**使用包含保护机制后的解决方案**

为了防止这种重复定义错误，我们可以在 `c.h` 中添加包含保护，确保头文件内容仅被处理一次。

```c
// c.h
#ifndef C_H
#define C_H

// 全局变量定义
int globalVar = 42;

// 结构体定义
typedef struct {
    int id;
    char name[50];
} Person;

#endif // C_H
```

**编译时的效果**

- 当 `a.c` 和 `b.c` 各自包含 `c.h` 时，编译器只会处理 `c.h` 的内容一次，后续的包含会被忽略。
- 这样就避免了重复定义全局变量和结构体的问题。

**编译过程：**

1. `a.c` 包含 `c.h`，编译器读取并处理 `c.h` 中的内容，定义了 `globalVar` 和 `Person`。
2. `b.c` 包含 `c.h`，编译器发现 `C_H` 已定义，直接跳过 `c.h` 的内容，不再重复定义 `globalVar` 和 `Person`。
3. `main.c` 包含了 `a.h` 和 `b.h`，虽然这两个头文件间接包含了 `c.h`，但是由于包含保护，`c.h` 的内容只会被处理一次，避免了重复定义问题。

**总结**

- **没有包含保护**：`c.h` 被 `a.c` 和 `b.c` 分别包含后，`globalVar` 和 `Person` 会被重复定义，导致编译错误。
- **使用包含保护**：`c.h` 中的内容只会在第一次被包含时处理，后续包含时会被跳过，避免了重复定义的问题。

这就是通过在头文件中使用条件编译保护机制来防止多次包含导致的重复定义错误的原理。

## 链接的作用

进行汇编操作之后已经是计算机可以执行的机器码了，那链接的作用在哪里？只是为了可以双击运行吗？

进行汇编操作后生成的目标文件（`.o` 文件）确实包含了**机器码**，但它仍然不能直接执行，原因在于这些目标文件还没有完成**符号解析**和**依赖库的加载**。因此，**链接**阶段是非常重要的一步，作用远不止是为了双击运行（win）。

### 链接的主要作用

1. **符号解析（Symbol Resolution）**：
   - 在编译每个 `.c` 源文件时，某些函数或变量可能引用了其他文件中的定义，编译器只知道它们的名字（符号），但不知道它们的地址。**比如，一个 `.c` 文件中调用了另一个 `.c` 文件中的函数。**
   - 链接器负责将这些符号（函数和变量的名字）与它们实际所在的位置（内存地址）进行匹配，并将引用替换为实际的内存地址。
   - 如果函数或者变量**没有在任何目标文件中定义**，链接器会抛出**未定义符号**的错误。
2. **合并目标文件**：
   - 一个程序可能由多个源文件组成（**就像Java大型项目一样，拆分成多个.java文件，实现各自的功能**），每个源文件编译后都会生成一个目标文件（`.o`）。这些文件是相互独立的，无法单独运行。
   - 链接器负责**将多个目标文件合并成一个完整的可执行文件**。它不仅仅是把文件拼接在一起，**而是处理每个文件中的符号引用和内存地址分配。**
3. **库的链接**：
   - 很多程序**依赖于外部库**（如 C 标准库、第三方库等）。这些库可能是静态库（`.a` 或 `.lib` 文件）或动态库（`.so` 或 `.dll` 文件）。
   - 链接器负责将目标文件与这些库连接起来。**对于静态库，链接器将库中的代码直接嵌入到最终的可执行文件中；对于动态库，链接器会生成对库的引用，程序在运行时加载动态库。**
4. **地址重定位（Relocation）**：
   - 每个目标文件中，代码和数据的地址是相对的，编译器并不知道它们在最终可执行文件中的绝对地址。链接器会根据各个目标文件的大小和布局，将这些地址进行重定位，确保程序在内存中的地址分配正确。
   - 这包括修改每个函数和全局变量的地址引用，**确保它们在最终生成的可执行文件中指向正确的位置。**
5. **入口点的确定**：
   - 链接器需要确定程序的**入口点**（通常是 `main` 函数），并**设置可执行文件中的程序启动地址**，以便操作系统知道从哪里开始执行。
   - 在 C 语言程序中，链接器会自动寻找 `main` 函数作为程序的入口点，但在更底层的操作系统启动过程中，链接器还要确保系统调用正确设置。

### 为什么汇编后的 `.o` 文件不能直接运行？

汇编生成的 `.o` 文件（目标文件）确实包含了机器码，但仍然**缺少一些必要的信息**，无法独立运行：

- **符号未解析**：目标文件中的外部函数或变量还没有被解析，程序无法知道它们的地址。
- **多个目标文件未合并**：如果程序是由多个源文件编写的，`.o` 文件只是其中的一部分，程序不完整。
- **库未链接**：标准库函数（如 `printf`、`malloc`）等函数尚未被链接进来，程序无法使用这些库。

### 链接的最终作用：

链接器将多个目标文件和库合并成一个**完整的可执行文件**，解决符号解析、地址重定位等问题，使得程序在操作系统上可以直接运行。最终生成的可执行文件包含了：

- 所有机器码（来自你的源文件和库）。
- 已经解决了的符号（函数和变量地址）。
- 必要的启动代码，指示操作系统如何加载和执行程序。

### 结论

**链接器的作用**不仅仅是为了让程序能够双击运行，它还负责解决符号引用、合并目标文件、加载库、重定位地址以及确定程序入口点等关键任务。只有经过链接后的可执行文件才能独立运行，而目标文件只是完整程序的一部分，不能直接执行。

## 基本概念

**写程序思路**

-  头文件一定要按质按量的包含，避免不必要的转换（在IDE中其实不必要担心）。

-  以函数为单位来解决问题（模块化思想）。
-  声明部分+实现部分（先声明后使用）。
-  return 0;是给父进程看的（谁调用谁就是父进程）。不写retrun 0;返回的值不默认是0，看具体情况。

-  多用空格空行
-  适当添加注释

```c
/**
 *前置说明
 *
 */

//单行注释

/*多行注释*/

#if 0

大段注释,预处理不会处理此段代码
    
#endif    
```

**算法**

解决问题的**方法**。（使用流程图，NS图，有限状态机FSM）

**程序**

用某种语言实现算法。

**进程**

防止写越界，防止内存泄露，谁打开谁关闭，谁申请谁释放。