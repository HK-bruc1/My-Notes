# C语言学习记录9之树状存储

**树状存储是另外一种数据存储方式吗？ 区别于顺序存储和链式存储？**

是的，树状存储确实是另一种数据存储方式，它与顺序存储和链式存储有明显区别。

1. **顺序存储**：在这种方式下，数据元素按顺序存储在内存的连续空间中，比如数组。它的优点是可以通过下标直接访问任意位置的元素，缺点是插入和删除操作可能会非常耗时（因为需要移动元素）。
2. **链式存储**：这里的数据元素是通过指针链接在一起的，例如链表。它的优点是插入和删除元素较为高效，只需调整指针即可。缺点是无法直接访问任意位置的元素，通常需要从头节点开始逐一遍历。
3. **树状存储**：在树状存储中，数据结构是树形的，每个节点可能有一个或多个子节点（如二叉树、多叉树等）。它特别适合表示层次关系的数据，比如文件系统或组织架构。树状结构在查找、插入和删除操作中效率较高，尤其是在二叉搜索树中，可以将时间复杂度降到 O(logn) 级别。

综上，树状存储适用于表示分层或递归关系的数据，而顺序和链式存储更适合线性数据。

**那么在C语言中，这种一个节点可能有一个或多个子节点的结构，是不是指针又天然的适合实现这种结构？**

是的，指针在 C 语言中确实非常适合用来实现树状结构。

在树状存储结构中，每个节点通常包含以下几个部分：

1. **数据域**：节点所存储的数据内容。
2. **指针域**：指向子节点或其他相关节点的指针。

由于树结构中的节点数量和关系不固定，指针能够灵活地指向其他节点，从而形成树的分层结构。以下是两种常见的树状结构在 C 中的指针实现方式：

**二叉树**

在二叉树中，每个节点最多有两个子节点（左子节点和右子节点）。一个典型的二叉树节点定义如下：

```c
struct TreeNode {
    int data;                 // 数据域
    struct TreeNode *left;    // 指向左子节点的指针
    struct TreeNode *right;   // 指向右子节点的指针
};
```

在这种结构中，`left` 和 `right` 指针使每个节点可以连接到它的两个子节点，从而形成二叉树的结构。

**多叉树**

多叉树（例如 B 树或通用树）中的每个节点可以有多个子节点。实现多叉树有几种方法：

- **使用指针数组**：可以用一个指针数组（保存多个子节点）来保存指向每个子节点的指针，例如，一个节点最多有 `MAX_CHILDREN` 个子节点：

  - ```c
    #define MAX_CHILDREN 5
    
    struct TreeNode {
        int data;
        struct TreeNode *children[MAX_CHILDREN];  // 子节点指针数组
    };
    ```

- **孩子-兄弟表示法**：用一个指针指向第一个子节点，再用一个指针指向下一个兄弟节点。这种方式适合节点数量不固定的树形结构：

  - ```c
    struct TreeNode {
        int data;
        struct TreeNode *firstChild;   // 第一个子节点
        struct TreeNode *nextSibling;  // 下一个兄弟节点
    };
    ```

  - 在这种表示法中，每个节点只有两个指针（`firstChild` 和 `nextSibling`），但可以通过这两个指针构建出一个任意深度和宽度的多叉树结构。
  
  - 孩子-兄弟表示法(Child-Sibling Representation)是如何用两个指针构建多叉树的。
  
    - ```c
      #include <stdio.h>
      #include <stdlib.h>
      
      // 定义树节点结构
      typedef struct TreeNode {
          int data;                    // 节点数据
          struct TreeNode *firstChild; // 指向第一个子节点
          struct TreeNode *nextSibling;// 指向下一个兄弟节点
      } TreeNode;
      
      // 创建新节点
      TreeNode* createNode(int data) {
          //申请一个TreeNode结构体大小的空间（包含data和两个指针）
          TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
          if (newNode == NULL) {
              printf("内存分配失败！\n");
              exit(1);
          }
          newNode->data = data;
          newNode->firstChild = NULL;
          newNode->nextSibling = NULL;
          return newNode;
      }
      
      // 添加子节点
      void addChild(TreeNode* parent, int data) {
          if (parent == NULL) {
              printf("父节点不能为空！\n");
              return;
          }
          
          //拿到新建子节点的地址
          TreeNode* newNode = createNode(data);
          
          //查看父节点的子节点是否为空
          if (parent->firstChild == NULL) {
              // 如果还没有子节点，直接添加为第一个子节点
              parent->firstChild = newNode;
          } else {
              // 如果已有子节点，找到最后一个兄弟节点
              //从第一个子节点开始遍历找到最后一个兄弟节点，链接到后面
              TreeNode* sibling = parent->firstChild;
              while (sibling->nextSibling != NULL) {
                  sibling = sibling->nextSibling;
              }
              // 添加为最后一个兄弟
              sibling->nextSibling = newNode;
          }
      }
      
      // 打印树结构（使用递归和缩进展示层次关系）
      void printTree(TreeNode* root, int level) {
          if (root == NULL) return;
          
          // 打印当前节点
          for (int i = 0; i < level; i++) printf("  ");
          printf("%d\n", root->data);
          
          // 递归打印所有子节点
          TreeNode* child = root->firstChild;
          while (child != NULL) {
              printTree(child, level + 1);
              child = child->nextSibling;
          }
      }
      
      // 释放树的内存
      void freeTree(TreeNode* root) {
          if (root == NULL) return;
          
          // 先递归释放所有子节点
          TreeNode* child = root->firstChild;
          while (child != NULL) {
              TreeNode* next = child->nextSibling;  // 保存下一个兄弟节点
              freeTree(child);                      // 递归释放子树
              child = next;
          }
          
          // 释放当前节点
          free(root);
      }
      
      int main() {
          // 创建根节点
          TreeNode* root = createNode(1);
          
          // 添加第一层子节点
          addChild(root, 2);
          addChild(root, 3);
          addChild(root, 4);
          
          // 给节点2添加子节点
          addChild(root->firstChild, 5);
          addChild(root->firstChild, 6);
          
          // 给节点3添加子节点
          addChild(root->firstChild->nextSibling, 7);
          
          // 打印树结构
          printf("树结构:\n");
          printTree(root, 0);
          
          // 释放树的内存
          freeTree(root);
          
          return 0;
      }
      ```
  
    - 让我解释这种表示法的关键点：
  
      1. 节点结构：
         - `firstChild`指针指向该节点的第一个子节点
         - `nextSibling`指针指向该节点的下一个兄弟节点
      2. 构建原理：
         - 所有子节点通过`firstChild`链接到父节点
         - 同一父节点的所有子节点之间通过`nextSibling`形成一个链表
      3. 横向扩展：
         - 通过`nextSibling`指针可以无限扩展兄弟节点
         - 相当于在同一层级形成一个单链表
      4. 纵向扩展：
         - 通过`firstChild`指针可以无限扩展子节点
         - 每个节点都可以成为新的父节点，向下扩展
  
    - 这种表示法的优点是：
  
      - 结构简单，每个节点只需要两个指针
      - 空间效率高，不需要预先分配数组空间
      - 可以表示任意深度和宽度的树
  
    - 需要注意的是，虽然这种表示法看起来只有两个指针，但实际上可以通过这两个指针的组合来访问任意节点。例如，要访问某个节点的第三个子节点，需要：
  
      1. 先通过`firstChild`找到第一个子节点
      2. 然后通过`nextSibling`指针遍历两次
  
    - 我提供的代码实现了基本的树操作，你可以运行它来看看实际效果。要添加更多功能（如删除节点、查找节点等），都可以基于这两个指针来实现。
  
  - 创建一个可视化的示意图来说明孩子-兄弟表示法的结构:
  
    - ![image-20241105092036918](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录9之树状存储.assets\image-20241105092036918.png)
  
  - 蓝色箭头表示 `firstChild` 指针：
  
    - 指向节点的第一个子节点
    - 例如：节点1 -> 节点2，节点2 -> 节点5，节点3 -> 节点7
  
  - 红色箭头表示 `nextSibling`指针：
  
    - 连接同层级的兄弟节点
    - 例如：节点2 -> 节点3 -> 节点4，节点5 -> 节点6
  
  这种结构的特点：
  
  - 每个节点只需要两个指针就能表示出完整的树形结构
  - **要访问某个节点的所有子节点，需要先通过 `firstChild` 找到第一个子节点，然后通过 `nextSibling` 遍历其他子节点**
  - 结构简单但灵活，可以表示任意深度和宽度的树

**为什么指针适合树状结构？**

指针使得我们可以动态地分配和链接节点，从而灵活构建树的层次结构。同时，指针使得节点间的连接关系不会受限于固定位置，**符合树结构的非线性特性**。因此，指针是实现树状结构的天然工具，尤其在 C 语言这样没有高级数据结构的语言中尤为重要。

## 不使用指针实现树状结构

**树状结构在C语言中只能借助指针实现了吧？**

在 C 语言中，树状结构确实通常通过指针来实现，因为指针能够灵活地链接不同的节点，创建出复杂的层次关系。不过，还有一些特定情况可以用数组来模拟树状结构，尽管没有指针实现得灵活。以下是两种不用指针的树状结构实现方式，但它们都具有一定的局限性：

### **（动态）数组表示法（适合完全二叉树）**

**组表示完全二叉树的设计理念和实现逻辑：**

![image-20241105094034420](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录9之树状存储.assets\image-20241105094034420.png)

数组表示完全二叉树的核心设计理念是：**利用完全二叉树的结构特性，通过数组下标之间的关系来隐含表示节点之间的父子关系**。

**层序存储**：

- 按照从上到下、从左到右的顺序将节点存储在数组中
- **根节点存储在索引0的位置**

**位置关系**： 对于**数组中索引**为 i 的节点：

- 左子节点的索引：`2i + 1`
- 右子节点的索引：`2i + 2`
- 父节点的索引：`(i - 1) / 2`（整数除法）

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

//树的结构体
//包含存节点的数组，树的节点数量，数组的最大容量
typedef struct {
	int* array;     // 存储树节点的数组
	int size;       // 当前树的节点数量
	int capacity;   // 数组的最大容量
} ArrayTree;

// 初始化树（把数组最大容量传入）
ArrayTree* createArrayTree(int capacity) {
	//先申请树结构体的空间（一个指针，两个int大小）
	ArrayTree* tree = (ArrayTree*)malloc(sizeof(ArrayTree));
	//开始初始化树的成员变量，给两个int类型赋值，给array指向一个地址（这里还需要初始化一个空间，
	//空间的大小有存储的数据类型+容量决定）
	tree->array = (int*)malloc(sizeof(int) * capacity);
	tree->size = 0;
	tree->capacity = capacity;
	return tree;
}

// 获取父节点索引
//传入一个节点在数组的索引
int getParentIndex(int index) {
	return (index - 1) / 2;
}

// 获取左子节点索引
int getLeftChildIndex(int index) {
	return 2 * index + 1;
}

// 获取右子节点索引
int getRightChildIndex(int index) {
	return 2 * index + 2;
}

// 添加节点
void addNode(ArrayTree* tree, int value) {
	//数组用完了
	if (tree->size >= tree->capacity) {
		printf("树已满！\n");
		return;
	}
	//先自增的话，不能当作索引用了，
	//后自增的话，可以当作索引用还可以记录树的节点大小，size和索引都是从0开始的
	tree->array[tree->size++] = value;
}

// 打印树（使用缩进显示层次结构）
void printArrayTree(ArrayTree* tree, int index, int level) {
	if (index >= tree->size) return;
	
	// 打印右子树
	printArrayTree(tree, getRightChildIndex(index), level + 1);
	
	// 打印当前节点
	for (int i = 0; i < level; i++) {
		printf("    ");
	}
	printf("%d\n", tree->array[index]);
	
	// 打印左子树
	printArrayTree(tree, getLeftChildIndex(index), level + 1);
}

// 示例使用
int main() {
	// 创建一个容量为10的树
	ArrayTree* tree = createArrayTree(10);
	
	// 添加节点
	addNode(tree, 1);  // 根节点
	addNode(tree, 2);  // 左子节点
	addNode(tree, 3);  // 右子节点
	addNode(tree, 4);  // 2的左子节点
	addNode(tree, 5);  // 2的右子节点
	addNode(tree, 6);  // 3的左子节点
	addNode(tree, 7);  // 3的右子节点
	
	// 打印树结构
	printf("树的结构：\n");
	printArrayTree(tree, 0, 0);
	
	// 演示节点关系
	printf("\n节点关系演示：\n");
	int index = 1; // 查看索引1（值为2）的节点关系
	printf("节点值：%d\n", tree->array[index]);
	printf("- 父节点：%d\n", tree->array[getParentIndex(index)]);
	printf("- 左子节点：%d\n", tree->array[getLeftChildIndex(index)]);
	printf("- 右子节点：%d\n", tree->array[getRightChildIndex(index)]);
	
	// 释放内存
	free(tree->array);
	free(tree);
	
	return 0;
}
```

**优点**

1. 空间效率高：
   - 不需要存储指针
   - 内存连续，访问效率高
2. 操作简单：
   - 通过简单的数学计算就能获取父子节点
   - 适合完全二叉树的存储和操作
3. 序列化方便：
   - 直接存储数组即可
   - 便于持久化和传输

**局限性**

1. 只适用于完全二叉树：
   - 如果树不是完全二叉树，会浪费空间
   - 删除节点后需要维护完全二叉树的性质
2. 固定大小：
   - 需要预先分配空间
   - 动态扩展需要重新分配内存
   - 相当于动态数组了，需要预先申请空间
3. 节点删除复杂：
   - **删除非叶节点需要重组树结构**
   - **可能需要大量节点移动**

这种表示方法最常用于堆的实现，因为堆本身就要求是完全二叉树，而且堆的操作（上浮、下沉）都很适合用数组来实现。

**删除节点时如何维护完全二叉树的特性。重点是要保持完全二叉树的两个关键特性：1) 除最后一层外都是满的；2) 最后一层的节点从左到右填充。**

删除节点的处理步骤和原理：

1. 基本策略：

   - 用最后一个节点替换要删除的节点

   - 然后删除最后一个节点（减小size）

   - 调整被替换位置的节点以维持树的性质

   - ```
     初始状态：      5
                   / \
                  3   7
                 /|   |\
                2 4   6 8
     
     删除节点3后：   5
                   / \
                  8   7    <- 8（原最后节点）替换了3
                 /|   |
                2 4   6
     ```

2. **调整过程**：

   - 将最后一个节点的值复制到被删除的位置
   - 删除最后一个节点（减小树的大小）
   - 根据需要向上或向下调整节点位置

3. **维护完全性**：

   - 这种删除方法自动维护了完全二叉树的性质
   - 因为总是删除最后一个节点，保证了从左到右的填充特性

4. **这种删除策略的优点是：**

   1. 保持了数组的连续性
   2. 维护了完全二叉树的结构
   3. 操作效率较高

5. **缺点是：**

   1. 可能需要大量节点调整
   2. 不适合需要保持节点相对位置的场景

   这种删除方法在堆（优先队列）这样的数据结构中特别有用，因为它们主要关注节点值的大小关系，而不是节点的具体位置。

#### 总结

在数组表示的完全二叉树中，**节点的值（序号/数据）之间没有必然关系，但节点在数组中的位置（索引）之间存在固定的数学关系**。

这种索引关系的设计使得在不存储任何指针的情况下，就能够完整地表示和遍历二叉树结构，这也是为什么数组表示法在堆这样的完全二叉树结构中应用广泛的原因。

![image-20241105100745208](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录9之树状存储.assets\image-20241105100745208.png)

### **基于父节点索引的数组表示法**（纯数组）

对于一些固定结构的树，比如组织结构树或者静态的层次数据，可以用一个数组记录每个节点的父节点索引。每个节点存储它的数据及其父节点在数组中的索引：

节点之间通过父节点索引链接起来组成一棵树

```c
#define MAX_NODES 100

struct Node {
    int data;       // 节点的数据
    int parentIdx;  // 父节点的索引（-1 表示根节点）
};

struct Node tree[MAX_NODES];
```

在这种表示法中，数组中的每个元素代表一个节点，`parentIdx` 表示它的父节点在数组中的位置。这种方法在遍历父子关系时需要查找 `parentIdx`，效率不如指针，且只能用于树结构相对固定、变化不频繁的场景。

**设计理念**

- 空间效率：使用连续数组存储,避免指针占用额外空间
- 简单性：**通过索引直接访问父节点**,无需复杂的指针操作
- 序列化友好：便于树结构的存储和传输
- 缓存友好：连续内存访问提高缓存命中率

**实现逻辑**

- 每个节点存储两个关键信息:节点值和父节点索引
- 父节点索引为-1表示根节点
- 通过遍历数组可以方便地:
  - 查找特定节点的所有子节点
  - 获取从根到任意节点的完整路径
  - 进行层次遍历等操作

**应用场景**

- 组织架构管理:表示公司/部门层级关系
- 文件系统:实现目录树结构
- 评论系统:处理多级评论的层级关系
- 地理信息:行政区划等层级数据
- 商品分类:电商平台的商品分类体系

**这种实现特别适合以下场景:**

- 需要频繁查询父子关系的应用
- 数据需要序列化传输或存储的系统
- 树的结构相对稳定,插入/删除操作不频繁
- 内存受限的嵌入式系统

![image-20241105105001361](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录9之树状存储.assets\image-20241105105001361.png)

1. 上半部分是树的可视化结构：
   - 每个节点显示值和索引，格式为"值(索引)"
   - A(0)是根节点
   - B(1)和C(2)是A的子节点
   - D(3)和E(4)是B的子节点
   - F(5)是C的子节点
2. 下半部分是对应的数组表示：
   - 每个格子显示该节点的父节点索引
   - 索引0（根节点A）的**父节点索引为-1**
   - 索引1和2（节点B和C）的**父节点索引为0**
   - 索引3和4（节点D和E）的**父节点索引为1**
   - 索引5（节点F）的**父节点索引为2**

通过这种表示方法，我们可以：

1. 快速找到任何节点的父节点（通过查找父节点索引）
2. 找到任何节点的子节点（通过遍历数组，查找父节点索引等于当前节点索引的所有节点）
   1. **数组索引代表各个节点，其值为父节点的数组索引： 所以可以知道每一个节点的父节点， 这一句我不太明白：找到任何节点的子节点（通过遍历数组，查找父节点索引等于当前节点索引的所有节点）？？？ 数组存的是都是父节点索引，如何找子节点呢？**
   2. ![image-20241105141556193](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录9之树状存储.assets\image-20241105141556193.png)
   3. 找某一个目标节点的子节点，遍历所有节点，查看他们的值（父节点索引）是否等于目标节点的索引，如果相等，这一些节点都是目标节点的子节点
3. 构建从根到任何节点的路径（**通过不断查找父节点索引直到达到根节点**）

这种表示方法的优势在于简单直观，并且非常适合需要频繁查找父子关系的场景。

```c
// 使用父节点索引表示法的树结构
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100

// 树节点结构体
typedef struct {
    int value;           // 节点值
    int parent_index;    // 父节点索引
} TreeNode;

// 树结构体
typedef struct {
    TreeNode nodes[MAX_SIZE];  // 存储节点的数组
    int size;                  // 当前节点数量
} ParentIndexTree;

// 初始化树
void initTree(ParentIndexTree* tree) {
    //是纯数组不需要申请空间，直接初始化即可
    tree->size = 0;
}

// 添加节点
int addNode(ParentIndexTree* tree, int value, int parent_index) {
    if (tree->size >= MAX_SIZE) return -1;
    
    // 添加新节点
    //size可以当数组索引了，都是从0开始
    int current_index = tree->size;
    tree->nodes[current_index].value = value;
    tree->nodes[current_index].parent_index = parent_index;
    tree->size++;
    
    return current_index;
}

// 获取节点的所有子节点
//遍历所有节点看他们的父节点索引是否指向目标节点索引
void getChildren(ParentIndexTree* tree, int parent_index) {
    printf("Node %d's children: ", tree->nodes[parent_index].value);
    //数组遍历直接通过下标索引即可
    for (int i = 0; i < tree->size; i++) {
        if (tree->nodes[i].parent_index == parent_index) {
            printf("%d ", tree->nodes[i].value);
        }
    }
    printf("\n");
}

// 获取节点的路径（从根到该节点）
void getPath(ParentIndexTree* tree, int node_index) {
    printf("Path to node %d: ", tree->nodes[node_index].value);
    int current = node_index;
    //用来保存路径的数组
    int path[MAX_SIZE];
    int path_size = 0;
    
    // 收集路径
    //没到根节点之前
    //不断向上找
    while (current != -1) {
        //当前节点
        //后自增，size可以记录路径距离和数组下标索引
        path[path_size++] = tree->nodes[current].value;
        //向上到父节点索引
        current = tree->nodes[current].parent_index;
    }
    
    // 反向打印路径（从根到节点）
    for (int i = path_size - 1; i >= 0; i--) {
        printf("%d ", path[i]);
    }
    printf("\n");
}
```

### 总结

指针仍然是 C 语言中实现树状结构最常用且最灵活的方式，因为它们可以动态构建和修改复杂的树形关系。而数组方法仅适用于某些特定的、结构简单的树状数据。

## 指针实现平衡二叉树(看视频？)

**平衡二叉树的结构特性，C语言的指针实现平衡二叉树的话，指针又是怎么维护这一些特性的？**

**结构特性：**

- 任意节点的左右子树高度（层数相差）差不超过1
- 任意节点的左右子树都是平衡二叉树
- 树的平衡因子(**左子树高度减右子树高度**)只能是-1、0、1
- 在增删节点后可能需要通过旋转操作来维持平衡

**节点高度的定义：**

- 在AVL树中，节点的高度定义为"该节点到其最远叶子节点的路径长度"
- 空节点的高度为0
- 叶子节点的高度为1
- 其他节点的高度 = max(左子树高度, 右子树高度) + 1

**指针如何维护平衡特性：**

- 每个节点存储其高度信息（height字段）
- 插入新节点时，从插入位置向上回溯，更新受影响节点的高度
- 通过计算平衡因子（左子树高度-右子树高度）检测失衡
- 发现失衡时，通过旋转操作重新平衡：
  - 左左情况：右旋
  - 右右情况：左旋
  - 左右情况：先左旋后右旋
  - 右左情况：先右旋后左旋

**关键实现点：**

- 使用递归实现插入操作
- 每次插入后自底向上更新节点高度
- 通过指针重连接实现旋转操作
- 每次旋转后更新受影响节点的高度

### 最佳实践

实现平衡二叉树（如 AVL 树或红黑树）时，C 语言中的最佳实践包括良好的结构设计、清晰的旋转逻辑、细致的内存管理和高效的查找、插入与删除操作。平衡二叉树的核心目标是保持树的高度平衡，从而确保在最坏情况下也能高效地执行操作。以下是 AVL 树的最佳实践实现和常用操作示例：

```c
#include <stdio.h>
#include <stdlib.h>

// AVL树节点结构
typedef struct AVLNode {
    int key;                // 节点值
    int height;            // 节点高度
    struct AVLNode* left;  // 左子节点
    struct AVLNode* right; // 右子节点
} AVLNode;

// 获取节点高度
int getHeight(AVLNode* node) {
    if (node == NULL) return 0;
    return node->height;
}

// 获取平衡因子
int getBalanceFactor(AVLNode* node) {
    if (node == NULL) return 0;
    return getHeight(node->left) - getHeight(node->right);
}

// 更新节点高度
void updateHeight(AVLNode* node) {
    int leftHeight = getHeight(node->left);
    int rightHeight = getHeight(node->right);
    node->height = (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}

// 创建新节点
AVLNode* createNode(int key) {
    AVLNode* node = (AVLNode*)malloc(sizeof(AVLNode));
    node->key = key;
    node->height = 1;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 右旋操作
AVLNode* rightRotate(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;

    x->right = y;
    y->left = T2;

    updateHeight(y);
    updateHeight(x);

    return x;
}

// 左旋操作
AVLNode* leftRotate(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* T2 = y->left;

    y->left = x;
    x->right = T2;

    updateHeight(x);
    updateHeight(y);

    return y;
}

// 插入节点
AVLNode* insert(AVLNode* node, int key) {
    // 标准BST插入
    if (node == NULL) {
        return createNode(key);
    }

    if (key < node->key) {
        node->left = insert(node->left, key);
    } else if (key > node->key) {
        node->right = insert(node->right, key);
    } else {
        return node; // 重复值不插入
    }

    // 更新高度
    updateHeight(node);

    // 获取平衡因子
    int balance = getBalanceFactor(node);

    // 左左情况
    if (balance > 1 && key < node->left->key) {
        return rightRotate(node);
    }

    // 右右情况
    if (balance < -1 && key > node->right->key) {
        return leftRotate(node);
    }

    // 左右情况
    if (balance > 1 && key > node->left->key) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    // 右左情况
    if (balance < -1 && key < node->right->key) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}

// 查找最小值节点
AVLNode* findMin(AVLNode* node) {
    if (node == NULL) return NULL;
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}

// 删除节点
AVLNode* deleteNode(AVLNode* root, int key) {
    if (root == NULL) return NULL;

    // 标准BST删除
    if (key < root->key) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->key) {
        root->right = deleteNode(root->right, key);
    } else {
        // 找到要删除的节点
        if (root->left == NULL || root->right == NULL) {
            AVLNode* temp = root->left ? root->left : root->right;
            if (temp == NULL) {
                temp = root;
                root = NULL;
            } else {
                *root = *temp;
            }
            free(temp);
        } else {
            // 有两个子节点的情况
            AVLNode* temp = findMin(root->right);
            root->key = temp->key;
            root->right = deleteNode(root->right, temp->key);
        }
    }

    if (root == NULL) return NULL;

    // 更新高度
    updateHeight(root);

    // 检查平衡并旋转
    int balance = getBalanceFactor(root);

    // 左左情况
    if (balance > 1 && getBalanceFactor(root->left) >= 0) {
        return rightRotate(root);
    }

    // 左右情况
    if (balance > 1 && getBalanceFactor(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    // 右右情况
    if (balance < -1 && getBalanceFactor(root->right) <= 0) {
        return leftRotate(root);
    }

    // 右左情况
    if (balance < -1 && getBalanceFactor(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

// 中序遍历
void inorderTraversal(AVLNode* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->key);
        inorderTraversal(root->right);
    }
}

// 释放树的内存
void freeTree(AVLNode* root) {
    if (root != NULL) {
        freeTree(root->left);
        freeTree(root->right);
        free(root);
    }
}
```

这个 AVL 树实现包含了以下关键特性：

1.数据结构设计

- 使用结构体 `AVLNode` 表示节点，包含键值、高度和左右子节点指针
- 所有指针操作都有清晰的 NULL 检查

2. 核心操作

- 插入操作 (`insert`)
- 删除操作 (`deleteNode`)
- 左旋和右旋操作用于平衡树
- 查找最小值节点
- 中序遍历

3.辅助函数

- 获取节点高度
- 计算平衡因子
- 更新节点高度
- 创建新节点

4.内存管理

- 适当的内存分配和释放
- 防止内存泄漏的清理函数

5.

```c
int main() {
    AVLNode* root = NULL;
    
    // 插入节点
    root = insert(root, 10);
    root = insert(root, 20);
    root = insert(root, 30);
    
    // 遍历树
    printf("中序遍历结果: ");
    inorderTraversal(root);
    printf("\n");
    
    // 删除节点
    root = deleteNode(root, 20);
    
    // 清理内存
    freeTree(root);
    
    return 0;
}
```

### AVL 树的设计理念和实现思路

**核心设计原则**

- 平衡性维护：

  - 每个节点都维护一个高度值
  - 平衡因子 = 左子树高度 - 右子树高度
  - 通过旋转操作保持平衡因子在 [-1, 1] 范围内

- 数据结构设计：

  - ```c
    typedef struct AVLNode {
        int key;                // 存储节点值
        int height;            // 记录节点高度
        struct AVLNode* left;  // 左子节点指针
        struct AVLNode* right; // 右子节点指针
    } AVLNode;
    ```

**平衡维护策略**

- 平衡检测：

  - 每次修改树（插入/删除）后检查平衡因子

  - 当发现 |平衡因子| > 1 时进行旋转操作

- 四种失衡情况：

  - LL（左左）：右旋

  - RR（右右）：左旋

  - LR（左右）：先左旋后右旋

  - RL（右左）：先右旋后左旋

**关键操作实现思路**

- 插入操作：

  1. 按二叉搜索树规则插入

  1. 自底向上更新节点高度

  1. 检查平衡因子并在需要时旋转

- 删除操作：

  1. 定位要删除的节点

  1. 处理删除后的子树连接

  1. 自底向上更新高度和平衡因子

  1. 需要时进行旋转操作

**性能考虑**

- 时间复杂度：
  - 查找：O(log n)
  - 插入：O(log n)
  - 删除：O(log n)
  - 旋转操作：O(1)
- 空间复杂度：
  - 每个节点额外存储高度信息：O(n)
  - 递归调用栈空间：O(log n)

**内存管理策略**

- 创建节点时动态分配内存
- 删除节点时正确释放内存
- 使用递归时注意栈空间使用

**使用建议**

- 适用场景：
  - 需要频繁查找的场景
  - 数据插入/删除频率适中
  - 对查询性能要求高的场景
- 注意事项：
  - 确保正确维护高度信息
  - 小心处理空指针情况
  - 注意内存释放，避免泄露

## 实例（待学习？）

### 树转存为广义表

学习树转存为广义表是一个非常有趣的例子，它可以帮助你理解指针在树状结构中的应用。通过这个过程，你将能够深入理解树的节点如何用指针连接，以及如何将树的层次结构转化为广义表的嵌套形式。

可以从以下几个步骤来实现这个转化：

1. **定义节点结构**：树的节点通常包含数据和指向孩子和兄弟节点的指针。一个广义表的节点也类似，需要包含数据和指向下一个节点的指针。
2. **递归转化过程**：可以编写一个递归函数，将树的每个节点按顺序插入广义表中，孩子节点被作为嵌套的子列表存储，而兄弟节点则顺序链接。
3. **遍历和打印**：转化后，通过遍历的方式打印广义表，以验证树的结构在广义表中是否正确保留。

可以通过编写代码实现这种转化，来帮助你理解指针在不同节点间的操作，以及递归在树状结构中的应用。

### 搜索树

学习搜索树是个很好的选择！搜索树，特别是二叉搜索树 (BST)，可以帮助你更深入地理解如何使用指针来组织和操作树状结构。BST 的核心概念是每个节点都有两个子节点，且左子节点的值小于父节点，而右子节点的值大于父节点。

通过实现以下操作，你可以掌握搜索树的基本原理：

1. **插入节点**：将新值插入树中，确保树的结构保持排序。
2. **查找节点**：在树中搜索特定值，了解如何遍历节点。
3. **删除节点**：从树中删除一个节点，维护树的结构。
4. **遍历树**：实现前序、中序和后序遍历，理解递归与指针的交互。