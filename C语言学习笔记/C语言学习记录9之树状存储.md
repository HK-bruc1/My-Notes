# C语言学习记录9之树状存储

## 基本概念

### **深度（层数）：从祖辈延申最多到第几代？**

- 从根节点到最远叶子节点的最长路径长度

- 关于计数方式,其实有两种常见的约定:

  1. 从0开始计数:

     - 根节点的深度为0

     - 每向下一层,深度+1

     - 单个节点的树深度为0

  2. 从1开始计数:

     - 根节点的深度为1

     - 每向下一层,深度+1

     - 单个节点的树深度为1

  3. ```c
     A         层级    深度(从0起)    深度(从1起)
         / \         1          0             1
        B   C        2          1             2
       /           3          2             3
      D
     ```

  4. 实际使用中两种方式都可以,关键是要在代码或文档中明确说明采用哪种计数方式,保持一致性。不过在学术界和大多数教材中,更常用从1开始计数的方式。

- 树的层数(level)通常是从1开始计数的

  - 这样计数比较符合直觉,因为说"第0层"听起来不太自然。当我们说"二叉树的第一层最多有1个节点,第二层最多有2个节点,第三层最多有4个节点"这样的性质时,从1开始计数更容易理解。

### **与深度容易混淆的概念：度**

​	一个节点的子节点(孩子节点)的个数。

```
     A         节点    度
    / \        A       2
   B   C       B       1    
  /            C       0
 D             D       0
```

分析一下每个节点的度:

1. 节点A有两个子节点(B和C),所以A的度为2
2. 节点B有一个子节点(D),所以B的度为1
3. 节点C没有子节点,所以C的度为0
4. 节点D没有子节点,所以D的度为0

另外还有几个相关概念:

- 叶子节点: 度为0的节点(上例中C和D是叶子节点)
- 分支节点: 度不为0的节点(上例中A和B是分支节点)
- 树的度: 树中所有节点的度的最大值(上例中树的度为2)



### **树的遍历方式**

```
例如这棵树:     
       1         
      / \        
     2   3       
    / \   \
   4   5   6
```

按行遍历(层序遍历):

- 一层一层,从左到右
- 结果: 1 -> 2,3 -> 4,5,6
- **使用队列实现**（确实先进的是根节点）
- 适合解决层级相关的问题

深度遍历:**（根的位置决定顺序，左总是优于右）**

- 先序(前序): 根-左-右
  - 顺序: 1-2-4-5-3-6
  - 特点: 根节点总是在子树之前
- 中序: 左-根-右
  - 顺序: 4-2-5-1-3-6
  - 特点: 对二叉搜索树得到有序序列
- 后序: 左-右-根
  - 顺序: 4-5-2-6-3-1
  - 特点: 根节点总是在子树之后
  - 常用于释放内存（先释放子节点）

## 一些疑问

**树状存储是另外一种数据存储方式吗？ 区别于顺序存储和链式存储？**

是的，树状存储确实是另一种数据存储方式，它与顺序存储和链式存储有明显区别。

1. **顺序存储**：在这种方式下，数据元素按顺序存储在内存的连续空间中，比如数组。它的优点是可以通过下标直接访问任意位置的元素，缺点是插入和删除操作可能会非常耗时（因为需要移动元素）。
2. **链式存储**：这里的数据元素是通过指针链接在一起的，例如链表。它的优点是插入和删除元素较为高效，只需调整指针即可。缺点是无法直接访问任意位置的元素，通常需要从头节点开始逐一遍历。
3. **树状存储**：在树状存储中，数据结构是树形的，每个节点可能有一个或多个子节点（如二叉树、多叉树等）。它特别适合表示层次关系的数据，比如文件系统或组织架构。树状结构在查找、插入和删除操作中效率较高，尤其是在二叉搜索树中，可以将时间复杂度降到 O(logn) 级别。

综上，树状存储适用于表示分层或递归关系的数据，而顺序和链式存储更适合线性数据。

**那么在C语言中，这种一个节点可能有一个或多个子节点的结构，是不是指针又天然的适合实现这种结构？**

是的，指针在 C 语言中确实非常适合用来实现树状结构。

在树状存储结构中，每个节点通常包含以下几个部分：

1. **数据域**：节点所存储的数据内容。
2. **指针域**：指向子节点或其他相关节点的指针。

由于树结构中的节点数量和关系不固定，指针能够灵活地指向其他节点，从而形成树的分层结构。以下是两种常见的树状结构在 C 中的指针实现方式：

**二叉树**

在二叉树中，每个节点最多有两个子节点（左子节点和右子节点）。一个典型的二叉树节点定义如下：

```c
struct TreeNode {
    int data;                 // 数据域
    struct TreeNode *left;    // 指向左子节点的指针
    struct TreeNode *right;   // 指向右子节点的指针
};
```

在这种结构中，`left` 和 `right` 指针使每个节点可以连接到它的两个子节点，从而形成二叉树的结构。

**多叉树**

多叉树（例如 B 树或通用树）中的每个节点可以有多个子节点。实现多叉树有几种方法：

- **使用指针数组**：可以用一个指针数组（保存多个子节点）来保存指向每个子节点的指针，例如，一个节点最多有 `MAX_CHILDREN` 个子节点：

  - ```c
    #define MAX_CHILDREN 5
    
    struct TreeNode {
        int data;
        struct TreeNode *children[MAX_CHILDREN];  // 子节点指针数组
    };
    ```

- **孩子-兄弟表示法**：用一个指针指向第一个子节点，再用一个指针指向下一个兄弟节点。这种方式适合节点数量不固定的树形结构：

  - ```c
    struct TreeNode {
        int data;
        struct TreeNode *firstChild;   // 第一个子节点
        struct TreeNode *nextSibling;  // 下一个兄弟节点
    };
    ```

  - 在这种表示法中，每个节点只有两个指针（`firstChild` 和 `nextSibling`），但可以通过这两个指针构建出一个任意深度和宽度的多叉树结构。
  
  - 孩子-兄弟表示法(Child-Sibling Representation)是如何用两个指针构建多叉树的。
  
    - ```c
      #include <stdio.h>
      #include <stdlib.h>
      
      // 定义树节点结构
      typedef struct TreeNode {
          int data;                    // 节点数据
          struct TreeNode *firstChild; // 指向第一个子节点
          struct TreeNode *nextSibling;// 指向下一个兄弟节点
      } TreeNode;
      
      // 创建新节点
      TreeNode* createNode(int data) {
          //申请一个TreeNode结构体大小的空间（包含data和两个指针）
          TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
          if (newNode == NULL) {
              printf("内存分配失败！\n");
              exit(1);
          }
          newNode->data = data;
          newNode->firstChild = NULL;
          newNode->nextSibling = NULL;
          return newNode;
      }
      
      // 添加子节点
      void addChild(TreeNode* parent, int data) {
          if (parent == NULL) {
              printf("父节点不能为空！\n");
              return;
          }
          
          //拿到新建子节点的地址
          TreeNode* newNode = createNode(data);
          
          //查看父节点的子节点是否为空
          if (parent->firstChild == NULL) {
              // 如果还没有子节点，直接添加为第一个子节点
              parent->firstChild = newNode;
          } else {
              // 如果已有子节点，找到最后一个兄弟节点
              //从第一个子节点开始遍历找到最后一个兄弟节点，链接到后面
              TreeNode* sibling = parent->firstChild;
              while (sibling->nextSibling != NULL) {
                  sibling = sibling->nextSibling;
              }
              // 添加为最后一个兄弟
              sibling->nextSibling = newNode;
          }
      }
      
      // 打印树结构（使用递归和缩进展示层次关系）
      void printTree(TreeNode* root, int level) {
          if (root == NULL) return;
          
          // 打印当前节点
          for (int i = 0; i < level; i++) printf("  ");
          printf("%d\n", root->data);
          
          // 递归打印所有子节点
          TreeNode* child = root->firstChild;
          while (child != NULL) {
              printTree(child, level + 1);
              child = child->nextSibling;
          }
      }
      
      // 释放树的内存
      void freeTree(TreeNode* root) {
          if (root == NULL) return;
          
          // 先递归释放所有子节点
          TreeNode* child = root->firstChild;
          while (child != NULL) {
              TreeNode* next = child->nextSibling;  // 保存下一个兄弟节点
              freeTree(child);                      // 递归释放子树
              child = next;
          }
          
          // 释放当前节点
          free(root);
      }
      
      int main() {
          // 创建根节点
          TreeNode* root = createNode(1);
          
          // 添加第一层子节点
          addChild(root, 2);
          addChild(root, 3);
          addChild(root, 4);
          
          // 给节点2添加子节点
          addChild(root->firstChild, 5);
          addChild(root->firstChild, 6);
          
          // 给节点3添加子节点
          addChild(root->firstChild->nextSibling, 7);
          
          // 打印树结构
          printf("树结构:\n");
          printTree(root, 0);
          
          // 释放树的内存
          freeTree(root);
          
          return 0;
      }
      ```
  
    - 让我解释这种表示法的关键点：
  
      1. 节点结构：
         - `firstChild`指针指向该节点的第一个子节点
         - `nextSibling`指针指向该节点的下一个兄弟节点
      2. 构建原理：
         - 所有子节点通过`firstChild`链接到父节点
         - 同一父节点的所有子节点之间通过`nextSibling`形成一个链表
      3. 横向扩展：
         - 通过`nextSibling`指针可以无限扩展兄弟节点
         - 相当于在同一层级形成一个单链表
      4. 纵向扩展：
         - 通过`firstChild`指针可以无限扩展子节点
         - 每个节点都可以成为新的父节点，向下扩展
  
    - 这种表示法的优点是：
  
      - 结构简单，每个节点只需要两个指针
      - 空间效率高，不需要预先分配数组空间
      - 可以表示任意深度和宽度的树
  
    - 需要注意的是，虽然这种表示法看起来只有两个指针，但实际上可以通过这两个指针的组合来访问任意节点。例如，要访问某个节点的第三个子节点，需要：
  
      1. 先通过`firstChild`找到第一个子节点
      2. 然后通过`nextSibling`指针遍历两次
  
    - 我提供的代码实现了基本的树操作，你可以运行它来看看实际效果。要添加更多功能（如删除节点、查找节点等），都可以基于这两个指针来实现。
  
  - 创建一个可视化的示意图来说明孩子-兄弟表示法的结构:
  
    - ![image-20241105092036918](.\C语言学习记录9之树状存储.assets\image-20241105092036918.png)
  
  - 蓝色箭头表示 `firstChild` 指针：
  
    - 指向节点的第一个子节点
    - 例如：节点1 -> 节点2，节点2 -> 节点5，节点3 -> 节点7
  
  - 红色箭头表示 `nextSibling`指针：
  
    - 连接同层级的兄弟节点
    - 例如：节点2 -> 节点3 -> 节点4，节点5 -> 节点6
  
  这种结构的特点：
  
  - 每个节点只需要两个指针就能表示出完整的树形结构
  - **要访问某个节点的所有子节点，需要先通过 `firstChild` 找到第一个子节点，然后通过 `nextSibling` 遍历其他子节点**
  - 结构简单但灵活，可以表示任意深度和宽度的树

**为什么指针适合树状结构？**

指针使得我们可以动态地分配和链接节点，从而灵活构建树的层次结构。同时，指针使得节点间的连接关系不会受限于固定位置，**符合树结构的非线性特性**。因此，指针是实现树状结构的天然工具，尤其在 C 语言这样没有高级数据结构的语言中尤为重要。

**我是用数组将一颗二叉树存储了，数组没有完全利用，这也叫顺序存储吗？ 存储方式只跟分配空间是否连续有关是吗？**

顺序存储的定义主要看存储空间是否连续,而不是看空间利用率:

1. 顺序存储的本质:

   - 是指数据元素存储在一片连续的内存空间中

   - 数组就是典型的顺序存储结构

   - 即使有些数组位置空着没使用,也还是顺序存储

2. 相对的是链式存储:

   - 数据元素存储在分散的内存空间中

   - 通过指针链接各个节点
   - 每个节点的位置可以是随机的

## 顺序存储实现数结构

**树状结构在C语言中只能借助指针实现了吧？**

在 C 语言中，树状结构确实通常通过指针来实现，因为指针能够灵活地链接不同的节点，创建出复杂的层次关系。不过，还有一些特定情况可以用数组来模拟树状结构，尽管没有指针实现得灵活。以下是两种不用指针的树状结构实现方式，但它们都具有一定的局限性：

### **（动态）数组表示法（适合完全二叉树）**

**组表示完全二叉树的设计理念和实现逻辑：**

![image-20241105094034420](.\C语言学习记录9之树状存储.assets\image-20241105094034420.png)

数组表示完全二叉树的核心设计理念是：**利用完全二叉树的结构特性，通过数组下标之间的关系来隐含表示节点之间的父子关系**。

**层序存储**：

- 按照从上到下、从左到右的顺序将节点存储在数组中
- **根节点存储在索引0的位置**

**位置关系**： 对于**数组中索引**为 i 的节点：

- 左子节点的索引：`2i + 1`
- 右子节点的索引：`2i + 2`
- 父节点的索引：`(i - 1) / 2`（整数除法）

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

//树的结构体
//包含存节点的数组，树的节点数量，数组的最大容量
typedef struct {
	int* array;     // 存储树节点的数组
	int size;       // 当前树的节点数量
	int capacity;   // 数组的最大容量
} ArrayTree;

// 初始化树（把数组最大容量传入）
ArrayTree* createArrayTree(int capacity) {
	//先申请树结构体的空间（一个指针，两个int大小）
	ArrayTree* tree = (ArrayTree*)malloc(sizeof(ArrayTree));
	//开始初始化树的成员变量，给两个int类型赋值，给array指向一个地址（这里还需要初始化一个空间，
	//空间的大小有存储的数据类型+容量决定）
	tree->array = (int*)malloc(sizeof(int) * capacity);
	tree->size = 0;
	tree->capacity = capacity;
	return tree;
}

// 获取父节点索引
//传入一个节点在数组的索引
int getParentIndex(int index) {
	return (index - 1) / 2;
}

// 获取左子节点索引
int getLeftChildIndex(int index) {
	return 2 * index + 1;
}

// 获取右子节点索引
int getRightChildIndex(int index) {
	return 2 * index + 2;
}

// 添加节点
void addNode(ArrayTree* tree, int value) {
	//数组用完了
	if (tree->size >= tree->capacity) {
		printf("树已满！\n");
		return;
	}
	//先自增的话，不能当作索引用了，
	//后自增的话，可以当作索引用还可以记录树的节点大小，size和索引都是从0开始的
	tree->array[tree->size++] = value;
}

// 打印树（使用缩进显示层次结构）
void printArrayTree(ArrayTree* tree, int index, int level) {
	if (index >= tree->size) return;
	
	// 打印右子树
	printArrayTree(tree, getRightChildIndex(index), level + 1);
	
	// 打印当前节点
	for (int i = 0; i < level; i++) {
		printf("    ");
	}
	printf("%d\n", tree->array[index]);
	
	// 打印左子树
	printArrayTree(tree, getLeftChildIndex(index), level + 1);
}

// 示例使用
int main() {
	// 创建一个容量为10的树
	ArrayTree* tree = createArrayTree(10);
	
	// 添加节点
	addNode(tree, 1);  // 根节点
	addNode(tree, 2);  // 左子节点
	addNode(tree, 3);  // 右子节点
	addNode(tree, 4);  // 2的左子节点
	addNode(tree, 5);  // 2的右子节点
	addNode(tree, 6);  // 3的左子节点
	addNode(tree, 7);  // 3的右子节点
	
	// 打印树结构
	printf("树的结构：\n");
	printArrayTree(tree, 0, 0);
	
	// 演示节点关系
	printf("\n节点关系演示：\n");
	int index = 1; // 查看索引1（值为2）的节点关系
	printf("节点值：%d\n", tree->array[index]);
	printf("- 父节点：%d\n", tree->array[getParentIndex(index)]);
	printf("- 左子节点：%d\n", tree->array[getLeftChildIndex(index)]);
	printf("- 右子节点：%d\n", tree->array[getRightChildIndex(index)]);
	
	// 释放内存
	free(tree->array);
	free(tree);
	
	return 0;
}
```

**优点**

1. 空间效率高：
   - 不需要存储指针
   - 内存连续，访问效率高
2. 操作简单：
   - 通过简单的数学计算就能获取父子节点
   - **适合完全二叉树的存储和操作**
3. 序列化方便：
   - 直接存储数组即可
   - 便于持久化和传输

**局限性**

1. 只适用于完全二叉树：
   - 如果树不是完全二叉树，会浪费空间
   - 删除节点后需要维护完全二叉树的性质
2. 固定大小：
   - 需要预先分配空间
   - 动态扩展需要重新分配内存
   - 相当于动态数组了，需要预先申请空间
3. 节点删除复杂：
   - **删除非叶节点需要重组树结构**
   - **可能需要大量节点移动**

这种表示方法最常用于堆的实现，因为堆本身就要求是完全二叉树，而且堆的操作（上浮、下沉）都很适合用数组来实现。

**删除节点时如何维护完全二叉树的特性。重点是要保持完全二叉树的两个关键特性：1) 除最后一层外都是满的；2) 最后一层的节点从左到右填充。**

删除节点的处理步骤和原理：

1. 基本策略：

   - 用最后一个节点替换要删除的节点

   - 然后删除最后一个节点（减小size）

   - 调整被替换位置的节点以维持树的性质

   - ```
     初始状态：      5
                   / \
                  3   7
                 /|   |\
                2 4   6 8
     
     删除节点3后：   5
                   / \
                  8   7    <- 8（原最后节点）替换了3
                 /|   |
                2 4   6
     ```

2. **调整过程**：

   - 将最后一个节点的值复制到被删除的位置
   - 删除最后一个节点（减小树的大小）
   - 根据需要向上或向下调整节点位置

3. **维护完全性**：

   - 这种删除方法自动维护了完全二叉树的性质
   - 因为总是删除最后一个节点，保证了从左到右的填充特性

4. **这种删除策略的优点是：**

   1. 保持了数组的连续性
   2. 维护了完全二叉树的结构
   3. 操作效率较高

5. **缺点是：**

   1. 可能需要大量节点调整
   2. 不适合需要保持节点相对位置的场景

   这种删除方法在堆（优先队列）这样的数据结构中特别有用，因为它们主要关注节点值的大小关系，而不是节点的具体位置。

#### 总结

在数组表示的完全二叉树中，**节点的值（序号/数据）之间没有必然关系，但节点在数组中的位置（索引）之间存在固定的数学关系**。

这种索引关系的设计使得在不存储任何指针的情况下，就能够完整地表示和遍历二叉树结构，这也是为什么数组表示法在堆这样的完全二叉树结构中应用广泛的原因。

![image-20241105100745208](.\C语言学习记录9之树状存储.assets\image-20241105100745208.png)

### **基于父节点索引的数组表示法**（纯数组）

对于一些固定结构的树，比如组织结构树或者静态的层次数据，可以用一个数组记录每个节点的父节点索引。每个节点存储它的数据及其父节点在数组中的索引：

节点之间通过父节点索引链接起来组成一棵树

```c
#define MAX_NODES 100

struct Node {
    int data;       // 节点的数据
    int parentIdx;  // 父节点的索引（-1 表示根节点）
};

struct Node tree[MAX_NODES];
```

在这种表示法中，数组中的每个元素代表一个节点，`parentIdx` 表示它的父节点在数组中的位置。这种方法在遍历父子关系时需要查找 `parentIdx`，效率不如指针，且只能用于树结构相对固定、变化不频繁的场景。

**设计理念**

- 空间效率：使用连续数组存储,避免指针占用额外空间
- 简单性：**通过索引直接访问父节点**,无需复杂的指针操作
- 序列化友好：便于树结构的存储和传输
- 缓存友好：连续内存访问提高缓存命中率

**实现逻辑**

- 每个节点存储两个关键信息:节点值和父节点索引
- 父节点索引为-1表示根节点
- 通过遍历数组可以方便地:
  - 查找特定节点的所有子节点
  - 获取从根到任意节点的完整路径
  - 进行层次遍历等操作

**应用场景**

- 组织架构管理:表示公司/部门层级关系
- 文件系统:实现目录树结构
- 评论系统:处理多级评论的层级关系
- 地理信息:行政区划等层级数据
- 商品分类:电商平台的商品分类体系

**这种实现特别适合以下场景:**

- 需要频繁查询父子关系的应用
- 数据需要序列化传输或存储的系统
- 树的结构相对稳定,插入/删除操作不频繁
- 内存受限的嵌入式系统

![image-20241105105001361](.\C语言学习记录9之树状存储.assets\image-20241105105001361.png)

1. 上半部分是树的可视化结构：
   - 每个节点显示值和索引，格式为"值(索引)"
   - A(0)是根节点
   - B(1)和C(2)是A的子节点
   - D(3)和E(4)是B的子节点
   - F(5)是C的子节点
2. 下半部分是对应的数组表示：
   - 每个格子显示该节点的父节点索引
   - 索引0（根节点A）的**父节点索引为-1**
   - 索引1和2（节点B和C）的**父节点索引为0**
   - 索引3和4（节点D和E）的**父节点索引为1**
   - 索引5（节点F）的**父节点索引为2**

通过这种表示方法，我们可以：

1. 快速找到任何节点的父节点（通过查找父节点索引）
2. 找到任何节点的子节点（通过遍历数组，查找父节点索引等于当前节点索引的所有节点）
   1. **数组索引代表各个节点，其值为父节点的数组索引： 所以可以知道每一个节点的父节点， 这一句我不太明白：找到任何节点的子节点（通过遍历数组，查找父节点索引等于当前节点索引的所有节点）？？？ 数组存的是都是父节点索引，如何找子节点呢？**
   2. ![image-20241105141556193](.\C语言学习记录9之树状存储.assets\image-20241105141556193.png)
   3. 找某一个目标节点的子节点，遍历所有节点，查看他们的值（父节点索引）是否等于目标节点的索引，如果相等，这一些节点都是目标节点的子节点
3. 构建从根到任何节点的路径（**通过不断查找父节点索引直到达到根节点**）

这种表示方法的优势在于简单直观，并且非常适合需要频繁查找父子关系的场景。

```c
// 使用父节点索引表示法的树结构
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100

// 树节点结构体
typedef struct {
    int value;           // 节点值
    int parent_index;    // 父节点索引
} TreeNode;

// 树结构体
typedef struct {
    TreeNode nodes[MAX_SIZE];  // 存储节点的数组
    int size;                  // 当前节点数量
} ParentIndexTree;

// 初始化树
void initTree(ParentIndexTree* tree) {
    //是纯数组不需要申请空间，直接初始化即可
    tree->size = 0;
}

// 添加节点
int addNode(ParentIndexTree* tree, int value, int parent_index) {
    if (tree->size >= MAX_SIZE) return -1;
    
    // 添加新节点
    //size可以当数组索引了，都是从0开始
    int current_index = tree->size;
    tree->nodes[current_index].value = value;
    tree->nodes[current_index].parent_index = parent_index;
    tree->size++;
    
    return current_index;
}

// 获取节点的所有子节点
//遍历所有节点看他们的父节点索引是否指向目标节点索引
void getChildren(ParentIndexTree* tree, int parent_index) {
    printf("Node %d's children: ", tree->nodes[parent_index].value);
    //数组遍历直接通过下标索引即可
    for (int i = 0; i < tree->size; i++) {
        if (tree->nodes[i].parent_index == parent_index) {
            printf("%d ", tree->nodes[i].value);
        }
    }
    printf("\n");
}

// 获取节点的路径（从根到该节点）
void getPath(ParentIndexTree* tree, int node_index) {
    printf("Path to node %d: ", tree->nodes[node_index].value);
    int current = node_index;
    //用来保存路径的数组
    int path[MAX_SIZE];
    int path_size = 0;
    
    // 收集路径
    //没到根节点之前
    //不断向上找
    while (current != -1) {
        //当前节点
        //后自增，size可以记录路径距离和数组下标索引
        path[path_size++] = tree->nodes[current].value;
        //向上到父节点索引
        current = tree->nodes[current].parent_index;
    }
    
    // 反向打印路径（从根到节点）
    for (int i = path_size - 1; i >= 0; i--) {
        printf("%d ", path[i]);
    }
    printf("\n");
}
```

### 总结

指针仍然是 C 语言中实现树状结构最常用且最灵活的方式，因为它们可以动态构建和修改复杂的树形关系。而数组方法仅适用于某些特定的、结构简单的树状数据。



## 链式存储实现树结构

**使用链式存储树的话，那么一个节点中必要的属性就有三个： 本身存储的数据，分别指向左右孩子的指针？**

对,你说得对。在用链式存储实现二叉树时,每个节点至少需要这三个基本属性。

用C语言的结构体表示可以是这样:

```c
struct TreeNode {
    int data;              // 节点存储的数据
    struct TreeNode *left; // 指向左孩子的指针
    struct TreeNode *right;// 指向右孩子的指针
};
```

有时候根据需求,节点还可能需要存储其他属性:

1. 常见的扩展属性:

   - 指向父节点的指针(parent)
   - 节点高度/深度
   - 平衡因子(比如AVL树)
   - 节点颜色(比如红黑树)

2. 节点结构示意图:

   1. ```c
          |———————————————|
          |     data      |
          |———————————————|
          |  left指针  ———|——→ 左子节点
          |———————————————|
          | right指针  ———|——→ 右子节点
          |———————————————|
      ```

3. 链式存储的优点:

   - 空间利用率高(不会有空闲位置)
   - 插入删除操作方便(修改指针即可)
   - **适合存储一般的树结构**

4. 缺点:

   - 需要额外的指针空间
   - **访问父子节点需要通过指针跳转**

### 插入


```c
#include <stdio.h>
#include <stdlib.h>

#define NAMESIZE 20

//一个学生对象上具有的属性
//使用结构体组织起来，集中管理：好实例化，初始化，访问
struct score_st{
	int id;
	char name[NAMESIZE];
	int math;
	int chinese;
};

//树的一个节点上具有的属性
//一个左右指针，一个信息域（保存学生信息的结构体）
struct node_st{
	struct score_st data;
	struct node_st *l,*r;
	
};


int insert(struct node_st **root,struct score_st *data);


int main(){
	//看具体问题是否需要头节点
	int arr[] = {1,2,3,7,6,5,9,8,4};
    //初始化一个空树（根节点）指针，后续以二级指针传递，即可改变指向
	struct node_st *tree = NULL;
    //临时变量，用于接收函数返回值
	struct score_st temp;
	
	//初始化十个学生信息
	for(int i=0;i<sizeof(arr)/sizeof(*arr);i++){
		//给学生相关结构体中的成员变量赋值
		temp.id = arr[i];
		snprintf(temp.name,NAMESIZE,"stu%d",arr[i]);
		temp.math = rand()%100;
		temp.chinese = rand()%100;
        
        //每生成一个学生信息就立即插入到树中
        //tree本身就是指针，但是为了能改变指向，就使用二级指针了
        //而temp是地址传递，而不是值传递，是为了节省空间？不用复制整个结构体
    	insert(&tree, &temp);
	}
	return 0;
}

int insert(struct node_st **root,struct score_st *data){
	//实例化一个新节点，用于函数内部操作
	struct node_st *node;
	
    //*root是树的地址
    //构建根节点
    //在递归中也是构建新节点的地方
	if(*root == NULL){
		//拿到分配的节点空间地址（struct node_st结构体的地址）
		node = malloc(sizeof(*node));
		//分配不成功
		if(node==NULL){
			return -1;
		}
		//把data信息都赋值node
		node->data = *data;
        //后续在递归中就可以利用上面进行构建新节点了
		node->l = NULL;
		node->r = NULL;
		
		//二级指针存的是外面主函数中*tree指针本身的地址
		//新节点已经赋值好了，但是是临时变量啊，函数结束就没有了！所以要改变指针的指向：体现二级指针的作用了
		//那一块空间地址没有变，里面的内容也没变，只是指向这块地址的指针变了
		*root = node;
		return 0;	
		
	}
	
    //有根节点的情况
	if(data->id <= (*root)->data.id){
		//小于"根节点"就往左走，其他节点都是如此
		//(*root)->l;
		//为了配合形参的二级指针，依旧传递指针本身的地址，后续就可以解引用修改指向即可
        //到叶子节点时他的左右子树节点都是null时，就可以构建新节点了
		return insert(&(*root)->l,data);
	}else {
		//大于"根节点"就往右走
		//(*root)->r;
		return insert(&(*root)->r,data);
	}
}
```

- 为什么使用二级指针：

  - `int insert(struct node_st **root, struct score_st *data)`

  - 使用二级指针的主要原因是**为了能在函数中修改指针的指向**

    如果只用一级指针，函数内部修改指针指向时，只会修改局部变量，不会影响到外部实际的tree指针

    通过二级指针，我们可以修改原始指针变量的值（指向）

- 关于temp的地址传递：

  - `insert(&tree, &temp);`
  - 是的，使用地址传递（指针）而不是值传递确实可以节省空间，尤其是当struct score_st结构体较大时
  - 同时也避免了复制整个结构体的开销
  - 如果使用值传递，每次调用函数都会在栈上创建一个结构体的副本

- 代码中的关键操作：

  - ```c
    if(*root == NULL){
        node = malloc(sizeof(*node));
        ...
        *root = node;  // 修改指针指向
    }
    ```

  - 当找到插入位置时（即遇到NULL指针）

  - malloc分配新节点空间

  - 通过二级指针修改原始指针的指向，使其指向新分配的节点

- 递归调用时的指针传递：

  - ```c
    return insert(&((*root)->l), data);
    // 或
    return insert(&((*root)->r), data);
    ```

  - 传递左子树或右子树**指针的地址**

  - `&(*root)->l` 等价于 "获取左子树指针的地址"

  - 这样递归调用时也能修改子树指针的指向

### 查找

```c
#include <stdio.h>
#include <stdlib.h>

#define NAMESIZE 20

//一个学生对象上具有的属性
//使用结构体组织起来，集中管理：好实例化，初始化，访问
struct score_st{
	int id;
	char name[NAMESIZE];
	int math;
	int chinese;
};

//树的一个节点上具有的属性
//一个左右指针，一个信息域（保存学生信息的结构体）
struct node_st{
	struct score_st data;
	struct node_st *l,*r;
	
};


int insert(struct node_st **root,struct score_st *data);
struct score_st *find(struct node_st *root,int id);
//查找之后的信息打印
void st_printf(struct score_st *d);


int main(){
	//看具体问题是否需要头节点
	int arr[] = {1,2,3,7,6,5,9,8,4};
	//初始化一个空树（根节点）指针，后续以二级指针传递，即可改变指向
	struct node_st *tree = NULL;
	//临时变量，用于接收函数返回值
	struct score_st temp,*datap;
	
	//初始化十个学生信息
	for(int i=0;i<sizeof(arr)/sizeof(*arr);i++){
		//给学生相关结构体中的成员变量赋值
		temp.id = arr[i];
		snprintf(temp.name,NAMESIZE,"stu%d",arr[i]);
		temp.math = rand()%100;
		temp.chinese = rand()%100;
		
		//每生成一个学生信息就立即插入到树中
		//tree本身就是指针，但是为了能改变指向，就使用二级指针了
		//而temp是地址传递，而不是值传递，是为了节省空间？
		insert(&tree, &temp);
	}
	
	//查找
	int tempid = 9;
	//传入树的地址
	datap =  find(tree,tempid);
	if(datap == NULL){
		//返回的结构体地址是空的，没找到
		printf("没有该学生的信息！");
	}else{
		//这里还是传递指针，地址传递。
		st_printf(datap);
	}
	
	return 0;
}

//插入
int insert(struct node_st **root,struct score_st *data){
	//实例化一个新节点，用于函数内部操作
	struct node_st *node;
	
	//*root是树的地址
	//构建根节点
	//在递归中也是构建新节点的地方
	if(*root == NULL){
		//拿到分配的节点空间地址（struct node_st结构体的地址）
		node = malloc(sizeof(*node));
		//分配不成功
		if(node==NULL){
			return -1;
		}
		//把data信息都赋值node
		node->data = *data;
		//后续在递归中就可以利用上面进行构建新节点了
		node->l = NULL;
		node->r = NULL;
		
		//二级指针存的是外面主函数中*tree指针的地址
		//新节点已经赋值好了，但是是临时变量啊，函数结束就没有了！所以要改变指针的指向：体现二级指针的作用了
		//那一块空间地址没有变，里面的内容也没变，只是指向这块地址的指针变了
		*root = node;
		return 0;	
		
	}
	
	//有根节点的情况
	if(data->id <= (*root)->data.id){
		//小于"根节点"就往左走，其他节点都是如此
		//(*root)->l;
		//为了配合形参的二级指针，依旧传递指针本身的地址，后续就可以解引用修改指向即可
		//到叶子节点时他的左右子树节点都是null时，就可以构建新节点了
		return insert(&(*root)->l,data);
	}else {
		//大于"根节点"就往右走
		//(*root)->r;
		return insert(&(*root)->r,data);
	}
}

//查找
struct score_st *find(struct node_st *root,int id){
	//递归出口最后写
	if(root == NULL){
		//找到叶子节点后了
		return NULL;
	}
	
	//拿到就返回包含学生信息的结构体地址
	if(id==root->data.id)
		//返回目标节点中的信息域（学生结构体的地址）
		//指针通过箭头访问结构体成员（data是一个也是一个结构体），再取地址拿到data结构体的地址
		return &(root->data);
    //判断向下的方向
	if(id < root->data.id)
		//左走
		//root->l 此节点的左子节点的地址
		return find(root->l,id);
	else
		//右走
		return find(root->r,id);
}

//打印节点信息
void st_printf(struct score_st *d){
	//把data结构体的地址拿到，然后再通过箭头访问内部成员
	printf("%d %s %d %d\n",d->id,d->name,d->math,d->chinese);
}
```

按照节点的排列规则，不断的向下递归，直到找到目标

### 打印树的结构

```c
#include <stdio.h>
#include <stdlib.h>

#define NAMESIZE 20

//一个学生对象上具有的属性
//使用结构体组织起来，集中管理：好实例化，初始化，访问
struct score_st{
	int id;
	char name[NAMESIZE];
	int math;
	int chinese;
};

//树的一个节点上具有的属性
//一个左右指针，一个信息域（保存学生信息的结构体）
struct node_st{
	struct score_st data;
	struct node_st *l,*r;
	
};


int insert(struct node_st **root,struct score_st *data);
struct score_st *find(struct node_st *root,int id);
//查找之后的信息打印
void st_printf(struct score_st *d);
//画树的结构
void draw(struct node_st *root);


int main(){
	//看具体问题是否需要头节点
	int arr[] = {1,2,3,7,6,5,9,8,4};
	//初始化一个空树（根节点）指针，后续以二级指针传递，即可改变指向
	struct node_st *tree = NULL;
	//临时变量，用于接收函数返回值
	struct score_st temp,*datap;
	
	//初始化十个学生信息
	for(int i=0;i<sizeof(arr)/sizeof(*arr);i++){
		//给学生相关结构体中的成员变量赋值
		temp.id = arr[i];
		snprintf(temp.name,NAMESIZE,"stu%d",arr[i]);
		temp.math = rand()%100;
		temp.chinese = rand()%100;
		
		//每生成一个学生信息就立即插入到树中
		//tree本身就是指针，但是为了能改变指向，就使用二级指针了
		//而temp是地址传递，而不是值传递，是为了节省空间？
		insert(&tree, &temp);
	}
	
//	//查找
//	int tempid = 9;
//	//传入树的地址
//	datap =  find(tree,tempid);
//	if(datap == NULL){
//		//返回的结构体地址是空的，没找到
//		printf("没有该学生的信息！");
//	}else{
//		//这里还是传递指针，地址传递。
//		st_printf(datap);
//	}
	
	//画树的结构
	draw(tree);
	
	return 0;
}

//插入
int insert(struct node_st **root,struct score_st *data){
	//实例化一个新节点，用于函数内部操作
	struct node_st *node;
	
	//*root是树的地址
	//构建根节点
	//在递归中也是构建新节点的地方
	if(*root == NULL){
		//拿到分配的节点空间地址（struct node_st结构体的地址）
		node = malloc(sizeof(*node));
		//分配不成功
		if(node==NULL){
			return -1;
		}
		//把data信息都赋值node
		node->data = *data;
		//后续在递归中就可以利用上面进行构建新节点了
		node->l = NULL;
		node->r = NULL;
		
		//二级指针存的是外面主函数中*tree指针的地址
		//新节点已经赋值好了，但是是临时变量啊，函数结束就没有了！所以要改变指针的指向：体现二级指针的作用了
		//那一块空间地址没有变，里面的内容也没变，只是指向这块地址的指针变了
		*root = node;
		return 0;	
		
	}
	
	//有根节点的情况
	if(data->id <= (*root)->data.id){
		//小于"根节点"就往左走，其他节点都是如此
		//(*root)->l;
		//为了配合形参的二级指针，依旧传递指针本身的地址，后续就可以解引用修改指向即可
		//到叶子节点时他的左右子树节点都是null时，就可以构建新节点了
		return insert(&(*root)->l,data);
	}else {
		//大于"根节点"就往右走
		//(*root)->r;
		return insert(&(*root)->r,data);
	}
}

//查找
struct score_st *find(struct node_st *root,int id){
	//递归出口最后写
	if(root == NULL){
		//找到叶子节点后了
		return NULL;
	}
	
	//拿到就返回包含学生信息的结构体地址
	if(id==root->data.id)
		//返回目标节点中的信息域（学生结构体的地址）
		//指针通过箭头访问结构体成员（data是一个也是一个结构体），再取地址拿到data结构体的地址
		return &(root->data);
	if(id < root->data.id)
		//左走
		//root->l 此节点的左子节点的地址
		return find(root->l,id);
	else
		//右走
		return find(root->r,id);
}

//打印节点信息
void st_printf(struct score_st *d){
	//把data结构体的地址拿到，然后再通过箭头访问内部成员
	printf("%d %s %d %d\n",d->id,d->name,d->math,d->chinese);
}

//打印树的结构
void draw_(struct node_st *root,int level){
	
	if(root == NULL){
		return;
	}
	//root->r
	draw_(root->r,level+1);
    //打印空格显示层级
	for(int i=0;i<level;i++){
		printf("    ");
	}
	//root;
	st_printf(&root->data);
	
	//root->l;
	draw_(root->l,level+1);
}
//打印树的结构
void draw(struct node_st *root){
	draw_(root,0);
}
```

这个打印二叉树结构的函数。这是一个很常用的按层次打印二叉树的方法，会以横向树形方式展示树的结构。

让我解释一下这个算法的工作原理：

1. 打印方向是从上到下、从右到左的，最终树会向左倾斜显示
2. `level` 参数表示当前节点的层级，用来确定缩进的空格数
3. 每一层会缩进4个空格(通过循环打印"    ")
4. 打印顺序是:
   - 先处理右子树
   - 然后打印当前节点
   - 最后处理左子树

例如，假设有这样一棵树:

```
       5
     /   \
    3     7
   / \   / \
  2   4 6   8
```

使用这个函数打印出来会是这样的格式:

```
        8
    7
        6
5
        4
    3
        2
```

读取方法:

1. 最左边的数字是根节点
2. 向右缩进表示是子节点:
   - 缩进一次(4个空格)表示是直接子节点
   - 缩进两次(8个空格)表示是孙节点
3. 相对位置:
   - 在上方的是右子树的节点
   - 在下方的是左子树的节点

要更容易理解打印出来的结果，你可以:

1. 找到最左边的数字，那就是根节点
2. 数一数缩进的空格数来确定层级关系
3. 记住上方的是右子树，下方的是左子树



**打印空格显示层级这个循环对位置有要求吗？**

这个空格打印循环的位置是很重要的：

1. 正确位置：循环应该在打印节点数据之前
   - 先打印对应层级的空格
   - 再打印节点的值
   - 这样可以确保正确的缩进效果
2. 要点说明：
   - **空格循环必须紧跟在递归右子树之后，打印节点数据之前**
   - 这个位置保证了每个节点都能获得正确的缩进级别
   - 缩进量与当前节点的层级(level)直接相关
   - **自己实验一下位置的差异**

```c
                9 stu9 81 27
                    8 stu8 61 91
            7 stu7 78 58
                6 stu6 62 64
                    5 stu5 5 45
                        4 stu4 95 42
        3 stu3 69 24
    2 stu2 34 0
1 stu1 41 67
```

让我帮你解读这个树的结构。这是一个按照前面讨论的方式打印出来的二叉树，每个节点包含学生信息（编号、姓名、两个分数）。

**按照函数定义，先画出来的是右子树，再是根，然后左子树。**

**最左边没有空格的就是根节点。**

让我帮你把它画成传统的树形结构：

```c
                1 stu1 41 67
              /
        2 stu2 34 0
      /
    3 stu3 69 24
      \
        7 stu7 78 58
          /           \
    6 stu6 62 64    9 stu9 81 27
      /               \
5 stu5 5 45        8 stu8 61 91
    \
  4 stu4 95 42
```

解读方法：

1. 缩进关系：
   - 每个缩进（4个空格）表示一个层级
   - 越往右缩进的是越深的层级
2. 位置关系：
   - 如果一个节点在上面，说明它是右子节点
   - 如果一个节点在下面，说明它是左子节点
3. 具体数据：
   - 根节点是：1 stu1 41 67
   - 格式是：学号 姓名 分数1 分数2



### 进化为平衡二叉树

**我在设计平衡函数时，为什么其中有一些函数需要static修饰？有什么说法吗？**

```c
//平衡
//获取以当前节点为根，他的最深深度的
static int get_num(struct node_st *root){
	
}
static turn_left(){
	
}
static turn_right(){
	
}
void balance(struct node_st **root){
	
	//递归出口最后写
	//平衡到叶子节点后了
	if(*root == NULL){
		return ;
	}
	
	while(1){
		//此节点的左子树和右子树的高度只差
		int sub;
		sub = get_num((*root)->l) - get_num((*root)->r);
		//平衡了
		if(sub>=-1 && sub<=1){
			
		}
		//右边重，左旋
		if(sub<-1){
			turn_left();
		}else {
			//左边重，右旋
			turn_right();
		}
	}
	
	//一个节点平衡，他的左右子树节点也需要平衡
	balance(& ( (*root)->l ) );
	balance(& ( (*root)->r ) );
}
```

我来解释为什么在平衡函数的设计中，一些辅助函数需要用static修饰。

**static关键字在这里的作用：**

- 限制函数作用域：**被static修饰的函数只能在当前源文件中使用，不能被其他源文件调用**
- 隐藏实现细节：这些辅助函数是平衡操作的**内部实现细节，不需要暴露给外部使用者**
- 防止命名冲突：**避免与其他源文件中的同名函数发生冲突**

**为什么get_num()、turn_left()、turn_right()需要static：**

- 这些都是balance()**函数的辅助函数，只服务于平衡树的内部实现**
- **外部使用者只需要知道balance()这个接口就够了，不需要直接调用这些辅助函数**
- 这样的设计符合封装原则，把实现细节隐藏起来

**而balance()函数不用static的原因：**

- **balance()是对外的接口函数，需要让其他源文件能够调用**
- **它是树平衡操作的主入口，需要保持对外可见性**

#### 左右子树深度差的计算

**这个递归的巧妙之处在哪里？ 他能取到最深的那么深度吗？**

```c
//获取以当前节点为根，这个实现实际上是在计算节点总数，而不是树的深度
static int get_num(struct node_st *root){
	//到叶子节点后
	if(root == NULL){
		return 0;
	}
	return get_num(root->l) + 1 + get_num(root->r);
}
```

这个实现实际上是在计算节点总数，而不是树的深度。因为它：

- 把左子树的结果 + 1（当前节点）+ 右子树的结果
- 这样得到的是节点的总数

**节点的左右子树的总结点数之差可以作为平衡因子来判断吗？**

使用节点总数作为平衡因子并不是一个好主意

```
     A                  A
    /                    \
   B                      B
    \                    /
     C                  C
      \                /
       D              D
```

正确的平衡因子应该是高度差：

```c
// 正确的获取高度的函数，算的是以此节点为根到叶子节点的最长路径值
static int get_height(struct node_st *root) {
    if(root == NULL) {
        return 0;
    }
    int left_height = get_height(root->l);
    int right_height = get_height(root->r);
    //传递进来就是某个节点的子树节点了，所以当前节点要+1
    return (left_height > right_height ? left_height : right_height) + 1;
}

// 获取平衡因子
static int get_balance_factor(struct node_st *root) {
    if(root == NULL) {
        return 0;
    }
    return get_height(root->l) - get_height(root->r);
}
```

让我们比较两种方式：

```c
例子1：
       A              节点数差: 2-1=1
      / \             高度差: 2-1=1 
     B   D
    /
   C

例子2：
       A              节点数差: 3-1=2
      / \             高度差: 3-1=2
     B   D
    /
   C
  /
 E

例子3：
       A              节点数差: 7-1=6
      / \             高度差: 4-1=3
     B   D
    /
   C
  /
 E
/ \
F  G
```

观察可以发现：

1. 节点数差会随着树的增长而变大

2. 但高度差更稳定，且能更好地反映树的实际平衡状况

3. AVL树就是使用高度差来判断，规定任何节点的左右子树高度差不能超过1

4. 为什么高度差更好：

   - 更准确反映查找性能：树的查找效率主要取决于高度

   - 更稳定的平衡标准：不会随节点数增加而改变

   - 符合AVL树的定义：任一节点左右子树高度差不超过1

   - 旋转操作更可控：基于高度差的旋转能更好地保持平衡

总结：

1. 使用节点数差作为平衡因子不可靠
2. 应该使用高度差作为平衡因子
3. 这样能更好地保证树的平衡性和查找效率
4. 这也是标准AVL树采用的方案



**使用左右子树节点总数之差在某些情况下不影响最终结果，但存在明显的局限性，可能会影响效率和性能。**

**不影响最终结果的场景：**

如果你的目的是**只关心树的结构和最终的存储内容**（即不考虑平衡性优化的情况下），那么：

- **节点数差异确实不会影响最终结果**，树的所有节点依然可以被正确存储和访问。

**影响效率的场景：**

但如果你希望树具有良好的性能（如用于搜索、插入、删除操作时维持较低时间复杂度），那么不使用高度作为平衡因子会导致以下问题：

1. **查找效率下降**：
   - 如果树失衡严重（例如退化成链表），查找操作的时间复杂度可能从 O(log⁡n)O(\log n)O(logn) 降至 O(n)O(n)O(n)。
2. **插入和删除效率下降**：
   - 在插入和删除时，无法通过节点数差判断是否需要重新平衡。
   - 平衡操作变得不可靠，可能导致树的深度越来越大。
3. **维护成本增加**：
   - 使用节点数量差作为平衡因子，无法及时调整树的结构来保持平衡，从而影响整体效率。

**何时确实不影响？**

在以下情况下，你可能不关心性能，因此最终结果可能不受影响：

- 树中节点较少，性能差异不明显。
- 使用场景是一次性构建和访问（如读取配置文件数据）。

**总结**

如果你只关注最终的树结构和存储结果，节点数差确实可以在某些情况下满足要求。但从性能和通用性的角度看，**高度差是更可靠、更有效的平衡因子**，尤其在需要频繁操作（如搜索、插入、删除）的场景下。

#### 具体的平衡实现

```c
#include <stdio.h>
#include <stdlib.h>

#define NAMESIZE 20

//方便操作，具有局部作用的全局变量
static struct node_st *tree = NULL;

//一个学生对象上具有的属性
//使用结构体组织起来，集中管理：好实例化，初始化，访问
struct score_st{
	int id;
	char name[NAMESIZE];
	int math;
	int chinese;
};

//树的一个节点上具有的属性
//一个左右指针，一个信息域（保存学生信息的结构体）
struct node_st{
	struct score_st data;
	struct node_st *l,*r;
	
};


int insert(struct node_st **root,struct score_st *data);
struct score_st *find(struct node_st *root,int id);
//查找之后的信息打印
void st_printf(struct score_st *d);
//画树的结构
void draw(struct node_st *root);
//平衡
void balance(struct node_st **root);


int main(){
	//看具体问题是否需要头节点
	int arr[] = {1,2,3,7,6,5,9,8,4};
	//初始化一个空树（根节点）指针，后续以二级指针传递，即可改变指向
	//struct node_st *tree = NULL;
	//临时变量，用于接收函数返回值
	struct score_st temp,*datap;
	
	//初始化十个学生信息
	for(int i=0;i<sizeof(arr)/sizeof(*arr);i++){
		//给学生相关结构体中的成员变量赋值
		temp.id = arr[i];
		snprintf(temp.name,NAMESIZE,"stu%d",arr[i]);
		temp.math = rand()%100;
		temp.chinese = rand()%100;
		
		//每生成一个学生信息就立即插入到树中
		//tree本身就是指针，但是为了能改变指向，就使用二级指针了
		//而temp是地址传递，而不是值传递，是为了节省空间？
		insert(&tree, &temp);
	}
	
//	//查找
//	int tempid = 9;
//	//传入树的地址
//	datap =  find(tree,tempid);
//	if(datap == NULL){
//		//返回的结构体地址是空的，没找到
//		printf("没有该学生的信息！");
//	}else{
//		//这里还是传递指针，地址传递。
//		st_printf(datap);
//	}
	
	//画树的结构
	draw(tree);
	
	//平衡（树的结构是要发生变化的，即改变指针指向需要二级指针）
	balance(&tree);
	//平衡后的树
	draw(tree);
	
	return 0;
}

//插入
int insert(struct node_st **root,struct score_st *data){
	//实例化一个新节点，用于函数内部操作
	struct node_st *node;
	
	//*root是树的地址
	//构建根节点
	//在递归中也是构建新节点的地方
	if(*root == NULL){
		//拿到分配的节点空间地址（struct node_st结构体的地址）
		node = malloc(sizeof(*node));
		//分配不成功
		if(node==NULL){
			return -1;
		}
		//把data信息都赋值node
		node->data = *data;
		//后续在递归中就可以利用上面进行构建新节点了
		node->l = NULL;
		node->r = NULL;
		
		//二级指针存的是外面主函数中*tree指针的地址
		//新节点已经赋值好了，但是是临时变量啊，函数结束就没有了！所以要改变指针的指向：体现二级指针的作用了
		//那一块空间地址没有变，里面的内容也没变，只是指向这块地址的指针变了
		*root = node;
		return 0;	
		
	}
	
	//有根节点的情况
	if(data->id <= (*root)->data.id){
		//小于"根节点"就往左走，其他节点都是如此
		//(*root)->l;
		//为了配合形参的二级指针，依旧传递指针本身的地址，后续就可以解引用修改指向即可
		//到叶子节点时他的左右子树节点都是null时，就可以构建新节点了
		return insert(&(*root)->l,data);
	}else {
		//大于"根节点"就往右走
		//(*root)->r;
		return insert(&(*root)->r,data);
	}
}

//查找
struct score_st *find(struct node_st *root,int id){
	//递归出口最后写
	if(root == NULL){
		//找到叶子节点后了
		return NULL;
	}
	
	//拿到就返回包含学生信息的结构体地址
	if(id==root->data.id)
		//返回目标节点中的信息域（学生结构体的地址）
		//指针通过箭头访问结构体成员（data是一个也是一个结构体），再取地址拿到data结构体的地址
		return &(root->data);
	if(id < root->data.id)
		//左走
		//root->l 此节点的左子节点的地址
		return find(root->l,id);
	else
		//右走
		return find(root->r,id);
}

//打印节点信息
void st_printf(struct score_st *d){
	//把data结构体的地址拿到，然后再通过箭头访问内部成员
	printf("%d %s %d %d\n",d->id,d->name,d->math,d->chinese);
}

//打印树的结构
void draw_(struct node_st *root,int level){
	
	if(root == NULL){
		return;
	}
	//root->r
	draw_(root->r,level+1);
	//打印空格显示层级
	for(int i=0;i<level;i++){
		printf("    ");
	}
	//root;
	st_printf(&root->data);
	
	//root->l;
	draw_(root->l,level+1);
}
//打印树的结构
void draw(struct node_st *root){
	draw_(root,0);
	printf("\n\n");
	//getchar();
	
}

//平衡
// 正确的获取高度的函数，此节点到叶子节点的最远路径值
static int get_height(struct node_st *root) {
	if(root == NULL) {
		return 0;
	}
	int left_height = get_height(root->l);
	int right_height = get_height(root->r);
	return (left_height > right_height ? left_height : right_height) + 1;
}

//找最小左子树的位置
static struct node_st *find_min(struct node_st *root){
	if(root->l == NULL){
		//找到叶子节点了
		return root;
	}
	return find_min(root->l);
}
//左旋
static void turn_left(struct node_st **root){
	//保存当前的根节点
	struct node_st *cur = *root;
	//新根节点,这是改变指针指向
	*root = cur->r;
	//旧根节点的右孩子置空
	cur->r = NULL;
	//原来旧根节点那一串挂在新根节点的左边（分两种情况，一个是没有左孩子，一个是有左孩子（那就排资格论辈分，先来后到））
	//所以要找左边的情况
	//拿到最左子树的叶子节点，修改叶子节点的左孩子指向
	find_min(*root)->l = cur;
	//draw(tree);每旋转一次打印一次
}

//找最右边子树
static struct node_st *find_max(struct node_st *root){
	if(root->r == NULL){
		//找到叶子节点了
		return root;
	}
	return find_min(root->r);
}
//右旋
static void turn_right(struct node_st **root){
	//相同机制
	struct node_st *cur = *root;
	*root = cur->l;
	cur->l = NULL;
	find_max(*root)->r = cur;
	//draw(tree);每旋转一次打印一次
	
	
}

//具体实现调整平衡
void balance(struct node_st **root){
	
	//递归出口最后写
	//平衡到叶子节点后了
	if(*root == NULL){
		return ;
	}
	
	while(1){
		//这个实现实际上是在计算节点总数，而不是树的深度
		int sub;
		sub = get_height((*root)->l) - get_height((*root)->r);
		//平衡了
		if(sub>=-1 && sub<=1){
			break;
		}
		//右边重，左旋
		if(sub<-1){
			turn_left(root);
		}else {
			//左边重，右旋
			turn_right(root);
		}
	}
	
	//一个节点平衡，他的左右子树节点也需要平衡
	balance(& ( (*root)->l ) );
	balance(& ( (*root)->r ) );
}
```

**struct node_st *tree = NULL;定义在main里面作为临时变量，其他函数调用只能通过传参的方式，要改变tree的结构的话，还有传递二级指针 但是如果我定义在main的外面使用static修饰，作为全局变量。我可以直接在函数定义中使用？**

是的，如果将 `tree` 定义在 `main` 函数外部并使用 `static` 修饰，它将成为文件作用域的**静态全局变量**。在这种情况下，你可以直接在同一个源文件中的其他函数中访问和修改它，而无需通过参数传递。以下是具体说明：

1. **在 `main` 中定义的变量**

如果 `tree` 是在 `main` 函数内部定义的：

```c
int main() {
    struct node_st *tree = NULL;
    // 其他代码...
}
```

这种情况下，`tree` 是一个局部变量，其作用域仅限于 `main` 函数。要在其他函数中访问或修改它，必须通过**参数传递**，并且如果需要修改 `tree` 本身（例如插入新节点），通常需要传递**二级指针**。

2. **将 `tree` 定义为静态全局变量**

如果你将 `tree` 定义在 `main` 外部，并用 `static` 修饰：

```c
#include <stdio.h>

static struct node_st *tree = NULL;

void modify_tree() {
    // 可以直接访问和修改 tree
    tree = some_new_value;  // 假设这是一个有效的操作
}

int main() {
    modify_tree();  // 修改 tree
    return 0;
}

```

**优点**：

- 由于 `tree` 是静态全局变量，它的作用域是**当前源文件**中的所有函数。
- 不需要通过参数传递，函数可以直接访问和修改 `tree`。

**缺点**：

- 函数的隐式依赖：`modify_tree` 等函数依赖 `tree` 的存在和状态，降低了代码的可读性和模块化。
- 静态全局变量只在当前文件内有效。如果多个源文件需要共享 `tree`，`static` 不能满足需求，需要使用 `extern` 来声明全局变量。

 **总结**

- **在 `main` 中定义变量**：通过参数传递，尤其是需要改变指针的指向时，使用二级指针。
- **在 `main` 外用 `static` 定义全局变量**：函数内可以直接访问，但会降低代码的模块化和可维护性。



**递归使用时还是通过传递参数的方式吧，不然以全局变量的方式的话，会被反复覆盖？得不到正确的值？**

是的，在递归中更推荐通过**参数传递**的方式来使用变量，而不是依赖全局变量。以下是两种方法的分析：

是的，在递归中更推荐通过**参数传递**的方式来使用变量，而不是依赖全局变量。以下是两种方法的分析：

------

**1. 通过参数传递**

递归函数通常依赖于参数传递来维护不同递归层次之间的**数据独立性**。每次递归调用都会为函数创建一个新的**栈帧**，其中包含参数的独立副本。这**避免了不同递归层次之间的数据冲突**。

**优点**：

- **每个递归层都有自己的数据上下文**：递归中的参数独立于其他层。
- **更安全，避免意外覆盖数据**：不同层次的数据不会相互干扰。

**2.使用全局变量**

如果你在递归中依赖一个全局变量，每次递归调用都在操作同一个变量。**这可能导致全局变量的值被反复覆盖，无法正确维护递归层次之间的状态。**

**问题**：

- **递归覆盖问题**：全局变量每次递归时都会被重新赋值，导致状态丢失。
- **错误结果**：最终只保留最后一次递归的结果，而无法正确构建二叉树。



**所以如果没有函数直接访问或者这个变量的话，其实是没有必要定义为全局变量的对吗？**

没错！如果一个变量在程序中**只在某个函数及其子函数中使用**，那么**没有必要将它定义为全局变量**。以下是详细说明：

**1. 为什么避免不必要的全局变量？**

- **局部性原则**：变量的作用域应尽可能小，这样更容易理解和维护代码。
- **减少命名冲突**：全局变量在整个文件中可见，容易与其他全局变量或函数发生命名冲突。
- **防止意外修改**：全局变量可以被任何函数修改，增加了程序出错的风险。
- **递归特别注意**：如前所述，递归中使用全局变量可能导致不同递归层之间数据冲突，产生错误结果。

**2. 什么时候定义为局部变量？**

如果变量只在一个函数或递归调用中需要使用，直接定义为**局部变量**是最佳选择。通过**参数传递**在不同函数之间共享和修改变量，而不是使用全局变量。

**3.什么时候需要全局变量？**

只有当变量需要被多个**函数直接访问**时，才考虑定义为全局变量。例如：

- 配置或状态信息需要被整个程序共享。
- 缓存数据，例如程序中的全局资源表。

**总结**

- **局部变量优先**：如果变量只在特定函数或递归调用中使用，定义为局部变量并通过参数传递。
- **全局变量慎用**：只有在变量需要被多个函数共享访问时才定义为全局变量，并注意控制其作用域（如用 `static` 限制在文件内）。

### 平衡后删除节点

```c
//平衡后删除
void st_delete(struct node_st **root,int id){
	//node代替root
	struct node_st **node = root;
	struct node_st *cur;
	
	//查找指定节点
	while(*node != NULL && (*node)->data.id != id){
		//节点有的前提下，一直向下找
		if(id < (*node)->data.id){
			//小于当前节点的id，往左走
			node = &( (*node)->l);
		}else {
			//大于当前节点的id,往右走
			node = &( (*node)->r);
		}
	}
	//跳出来后只有两种情况
	if(*node ==NULL){
		return ;
	}
	
	//拿到要删除的节点，使用临时变量是避免丢失其他节点，以及free方便
	cur = *node;
	
	//谁顶上来？左孩子顶上来作为根节点或者右孩子顶上来作为根节点
	//如果没有左孩子，必然是用右孩子来顶根节点
	if(cur->l == NULL){
		//右孩子顶到原来的位置上，改变其指向即可
		*node = cur->r;
	}else{
		//有左孩子就优先左孩子
		*node = cur->l;
		//左孩子顶上来作为根节点之后，原来的右孩子相当于断链了，需要接在新根节点的右边，具体看是否已经有孩子了，找右边最大的
		//找到新根节点的右子树的叶子节点，拿到叶子节点的右孩子，用原来右孩子挂在这
		find_max(cur->l)->r = cur->r;
	}
	free(cur);
}
```

删除之后无论是左孩子还是右孩子都可以，不过需要做相应的操作调整即可。

### 遍历

```c
//层序遍历
	//利用队列结构特性，进一个节点，出队时把左右节点都进来
	QUEUE *qu;
	struct node_st *cur;
	int ret;
	
	
	//空树也没必要遍历
	if(root == NULL)
		return;
	
	// 创建队列
	//实际生产环境不太合理，可能队列容量不够，入队根节点后，出一个节点都要入队他的左右孩子
	qu = queue_create(sizeof(struct node_st *));
	if(qu == NULL){
		return ;
	}
	
	// 根节点入队
	queue_en(qu,&root);
	/*if error*/
	
	while(1){
		// 出队并获取节点
		ret = queue_de(qu,&cur);
		if(ret == -1)
			break;
		
		// 打印当前节点
		st_printf(&cur->data);
		
		// 左子节点入队
		//->l;
		if(cur->l != NULL){
			queue_en(qu,&cur->l);
		}
		
		// 右子节点入队
		//->r;
		if(cur->r != NULL){
			queue_en(qu,&cur->r);
		}
	}
	
	// 销毁队列
	queue_destroy(qu);
```

## 完整实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>


#define NAMESIZE 20

// 队列节点结构体
struct queue_node {
	void *data;
	struct queue_node *next;
};

// 队列结构体
typedef struct queue {
	struct queue_node *front;    // 队头
	struct queue_node *rear;     // 队尾
	int size;                    // 当前队列大小
	size_t datasize;            // 数据类型大小
} QUEUE;

//一个学生对象上具有的属性
//使用结构体组织起来，集中管理：好实例化，初始化，访问
struct score_st{
	int id;
	char name[NAMESIZE];
	int math;
	int chinese;
};

//树的一个节点上具有的属性
//一个左右指针，一个信息域（保存学生信息的结构体）
struct node_st{
	struct score_st data;
	struct node_st *l,*r;
	
};

//队列相关函数声明
// 创建队列
QUEUE *queue_create(size_t datasize);
// 入队
int queue_en(QUEUE *qu, void *data);
// 出队
int queue_de(QUEUE *qu, void *data);
// 销毁队列
void queue_destroy(QUEUE *qu);


int insert(struct node_st **root,struct score_st *data);
struct score_st *find(struct node_st *root,int id);
//查找之后的信息打印
void st_printf(struct score_st *d);
//画树的结构
void draw(struct node_st *root);
//平衡
void balance(struct node_st **root);
//删除
void st_delete(struct node_st **root,int id);
//遍历
void travel(struct node_st *root);


int main(){
	//看具体问题是否需要头节点
	int arr[] = {1,2,3,7,6,5,9,8,4};
	//初始化一个空树（根节点）指针，后续以二级指针传递，即可改变指向
	struct node_st *tree = NULL;
	//临时变量，用于接收函数返回值
	struct score_st temp,*datap;
	
	//初始化十个学生信息
	for(int i=0;i<sizeof(arr)/sizeof(*arr);i++){
		//给学生相关结构体中的成员变量赋值
		temp.id = arr[i];
		snprintf(temp.name,NAMESIZE,"stu%d",arr[i]);
		temp.math = rand()%100;
		temp.chinese = rand()%100;
		
		//每生成一个学生信息就立即插入到树中
		//tree本身就是指针，但是为了能改变指向，就使用二级指针了
		//而temp是地址传递，而不是值传递，是为了节省空间？
		insert(&tree, &temp);
	}
	
//	//查找
//	int tempid = 9;
//	//传入树的地址
//	datap =  find(tree,tempid);
//	if(datap == NULL){
//		//返回的结构体地址是空的，没找到
//		printf("没有该学生的信息！");
//	}else{
//		//这里还是传递指针，地址传递。
//		st_printf(datap);
//	}
	
	//画树的结构
	draw(tree);
	
	//平衡（树的结构是要发生变化的，即改变指针指向需要二级指针）
	balance(&tree);
	//平衡后的树
	draw(tree);
	
//	//平衡后删除
//	int tempid = 5;
//	st_delete(&tree,tempid);
//	//删除后平衡
//	draw(tree);
	
	//遍历
	travel(tree);
	
	return 0;
}

//插入
int insert(struct node_st **root,struct score_st *data){
	//实例化一个新节点，用于函数内部操作
	struct node_st *node;
	
	//*root是树的地址
	//构建根节点
	//在递归中也是构建新节点的地方
	if(*root == NULL){
		//拿到分配的节点空间地址（struct node_st结构体的地址）
		node = malloc(sizeof(*node));
		//分配不成功
		if(node==NULL){
			return -1;
		}
		//把data信息都赋值node
		node->data = *data;
		//后续在递归中就可以利用上面进行构建新节点了
		node->l = NULL;
		node->r = NULL;
		
		//二级指针存的是外面主函数中*tree指针的地址
		//新节点已经赋值好了，但是是临时变量啊，函数结束就没有了！所以要改变指针的指向：体现二级指针的作用了
		//那一块空间地址没有变，里面的内容也没变，只是指向这块地址的指针变了
		*root = node;
		return 0;	
		
	}
	
	//有根节点的情况
	if(data->id <= (*root)->data.id){
		//小于"根节点"就往左走，其他节点都是如此
		//(*root)->l;
		//为了配合形参的二级指针，依旧传递指针本身的地址，后续就可以解引用修改指向即可
		//到叶子节点时他的左右子树节点都是null时，就可以构建新节点了
		return insert(&(*root)->l,data);
	}else {
		//大于"根节点"就往右走
		//(*root)->r;
		return insert(&(*root)->r,data);
	}
}

//查找
struct score_st *find(struct node_st *root,int id){
	//递归出口最后写
	if(root == NULL){
		//找到叶子节点后了
		return NULL;
	}
	
	//拿到就返回包含学生信息的结构体地址
	if(id==root->data.id)
		//返回目标节点中的信息域（学生结构体的地址）
		//指针通过箭头访问结构体成员（data是一个也是一个结构体），再取地址拿到data结构体的地址
		return &(root->data);
	if(id < root->data.id)
		//左走
		//root->l 此节点的左子节点的地址
		return find(root->l,id);
	else
		//右走
		return find(root->r,id);
}

//打印节点信息
void st_printf(struct score_st *d){
	//把data结构体的地址拿到，然后再通过箭头访问内部成员
	printf("%d %s %d %d\n",d->id,d->name,d->math,d->chinese);
}

//打印树的结构
void draw_(struct node_st *root,int level){
	
	if(root == NULL){
		return;
	}
	//root->r
	draw_(root->r,level+1);
	//打印空格显示层级
	for(int i=0;i<level;i++){
		printf("    ");
	}
	//root;
	st_printf(&root->data);
	
	//root->l;
	draw_(root->l,level+1);
}
//打印树的结构
void draw(struct node_st *root){
	draw_(root,0);
	printf("\n\n");
	//getchar();
	
}

//平衡
// 正确的获取高度的函数，此节点到叶子节点的最远路径值
static int get_height(struct node_st *root) {
	if(root == NULL) {
		return 0;
	}
	int left_height = get_height(root->l);
	int right_height = get_height(root->r);
	return (left_height > right_height ? left_height : right_height) + 1;
}

//找最小左子树的位置
static struct node_st *find_min(struct node_st *root){
	if(root->l == NULL){
		//找到叶子节点了
		return root;
	}
	return find_min(root->l);
}
//左旋
static void turn_left(struct node_st **root){
	//保存当前的根节点
	struct node_st *cur = *root;
	//新根节点,这是改变指针指向
	*root = cur->r;
	//旧根节点的右孩子置空
	cur->r = NULL;
	//原来旧根节点那一串挂在新根节点的左边（分两种情况，一个是没有左孩子，一个是有左孩子（那就排资格论辈分，先来后到））
	//所以要找左边的情况
	//拿到最左子树的叶子节点，修改叶子节点的左孩子指向
	find_min(*root)->l = cur;
	//draw(tree);每旋转一次打印一次
}

//找最右边子树
static struct node_st *find_max(struct node_st *root){
	if(root->r == NULL){
		//找到叶子节点了
		return root;
	}
	return find_min(root->r);
}
//右旋
static void turn_right(struct node_st **root){
	//相同机制
	struct node_st *cur = *root;
	*root = cur->l;
	cur->l = NULL;
	find_max(*root)->r = cur;
	//draw(tree);每旋转一次打印一次
	
	
}

//具体实现调整平衡
void balance(struct node_st **root){
	
	//递归出口最后写
	//平衡到叶子节点后了
	if(*root == NULL){
		return ;
	}
	
	while(1){
		//这个实现实际上是在计算节点总数，而不是树的深度
		int sub;
		sub = get_height((*root)->l) - get_height((*root)->r);
		//平衡了
		if(sub>=-1 && sub<=1){
			break;
		}
		//右边重，左旋
		if(sub<-1){
			turn_left(root);
		}else {
			//左边重，右旋
			turn_right(root);
		}
	}
	
	//一个节点平衡，他的左右子树节点也需要平衡
	balance(& ( (*root)->l ) );
	balance(& ( (*root)->r ) );
}

//平衡后删除
void st_delete(struct node_st **root,int id){
	//node代替root
	struct node_st **node = root;
	struct node_st *cur;
	
	//查找指定节点
	while(*node != NULL && (*node)->data.id != id){
		//节点有的前提下，一直向下找
		if(id < (*node)->data.id){
			//小于当前节点的id，往左走
			node = &( (*node)->l);
		}else {
			//大于当前节点的id,往右走
			node = &( (*node)->r);
		}
	}
	//跳出来后只有两种情况
	if(*node ==NULL){
		return ;
	}
	
	//拿到要删除的节点，使用临时变量是避免丢失其他节点，以及free方便
	cur = *node;
	
	//谁顶上来？左孩子顶上来作为根节点或者右孩子顶上来作为根节点
	//如果没有左孩子，必然是用右孩子来顶根节点
	if(cur->l == NULL){
		//右孩子顶到原来的位置上，改变其指向即可
		*node = cur->r;
	}else{
		//有左孩子就优先左孩子
		*node = cur->l;
		//左孩子顶上来作为根节点之后，原来的右孩子相当于断链了，需要接在新根节点的右边，具体看是否已经有孩子了，找右边最大的
		//找到新根节点的右子树的叶子节点，拿到叶子节点的右孩子，用原来右孩子挂在这
		find_max(cur->l)->r = cur->r;
	}
	free(cur);
}

//遍历
void travel(struct node_st *root){
//	//到叶子节点就不用遍历了
//	if(root == NULL){
//		return ;
//	}
//	//先序遍历
//	//	root->data;
//	st_printf(&root->data);
//	//	root->l;
//	travel(root->l);
//	//	root0>r;
//	travel(root->r);
	
//	//中序
//	travel(root->l);
//	st_printf(&root->data);
//	travel(root->r);
	
	//后序也是如此
	
	//层序遍历
	//利用队列结构特性，进一个节点，出队时把左右节点都进来
	QUEUE *qu;
	struct node_st *cur;
	int ret;
	
	
	//空树也没必要打印
	if(root == NULL)
		return;
	
	// 创建队列
	qu = queue_create(sizeof(struct node_st *));
	if(qu == NULL){
		return ;
	}
	
	// 根节点入队
	queue_en(qu,&root);
	/*if error*/
	
	while(1){
		// 出队并获取节点
		ret = queue_de(qu,&cur);
		if(ret == -1)
			break;
		
		// 打印当前节点
		st_printf(&cur->data);
		
		// 左子节点入队
		//->l;
		if(cur->l != NULL){
			queue_en(qu,&cur->l);
		}
		
		// 右子节点入队
		//->r;
		if(cur->r != NULL){
			queue_en(qu,&cur->r);
		}
	}
	
	// 销毁队列
	queue_destroy(qu);
}

// 创建队列
QUEUE *queue_create(size_t datasize) {
	QUEUE *qu;
	qu = malloc(sizeof(*qu));
	if(qu == NULL)
		return NULL;
	
	qu->front = NULL;
	qu->rear = NULL;
	qu->size = 0;
	qu->datasize = datasize;
	
	return qu;
}

// 入队
int queue_en(QUEUE *qu, void *data) {
	struct queue_node *newnode;
	
	newnode = malloc(sizeof(*newnode));
	if(newnode == NULL)
		return -1;
	
	newnode->data = malloc(qu->datasize);
	if(newnode->data == NULL) {
		free(newnode);
		return -1;
	}
	
	memcpy(newnode->data, data, qu->datasize);
	newnode->next = NULL;
	
	if(qu->front == NULL) {    // 空队列
		qu->front = newnode;
	} else {
		qu->rear->next = newnode;
	}
	qu->rear = newnode;
	qu->size++;
	
	return 0;
}

// 出队
int queue_de(QUEUE *qu, void *data) {
	struct queue_node *tmp;
	
	if(qu->size == 0)
		return -1;
	
	tmp = qu->front;
	memcpy(data, tmp->data, qu->datasize);
	
	qu->front = tmp->next;
	if(qu->front == NULL) {    // 最后一个节点
		qu->rear = NULL;
	}
	
	free(tmp->data);
	free(tmp);
	qu->size--;
	
	return 0;
}

// 销毁队列
void queue_destroy(QUEUE *qu) {
	struct queue_node *cur, *next;
	
	for(cur = qu->front; cur != NULL; cur = next) {
		next = cur->next;
		free(cur->data);
		free(cur);
	}
	
	free(qu);
}
```

