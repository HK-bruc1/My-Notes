# C语言学习记录3之构造类型

## 结构体

### 产生以及意义

结构体是C语言中一种重要的自定义数据类型，,它的产生和意义主要体现在以下几个方面:

1. 组织相关数据: 结构体允许**将不同类型但相互关联的数据项组合在一起,形成一个新的复合数据类型**。这使得程序员可以更好地组织和管理复杂的数据(**方便初始化，调用，相关数据一般是一起初始化和调用的**)。
2. 提高代码可读性: 通过使用结构体,可以将**相关的数据集中在一起**,使代码更加清晰和易于理解。
3. **简化函数参数: 当需要传递多个相关的数据项给函数时,可以将它们封装在一个结构体中,作为单一参数传递,从而简化函数调用。**
4. 实现抽象数据类型: 结构体为创建更复杂的抽象数据类型(如链表、树等)提供了基础。
5. 内存优化: 结构体允许更有效地利用内存,特别是在处理大量相似数据时。
6. 支持面向对象编程思想: 虽然C语言不是面向对象语言,**但结构体的概念为实现类似面向对象的编程提供了基础**。

**[C语言的结构体和Java的对象的区别](##结构体与Java类的相似之处)：**

- **相似点:**

1. 数据组织: 两者都可以将相关的数据组合在一起。
2. 自定义类型: 都允许创建自定义的复合数据类型。
3. 访问成员: 都使用点号(.)来访问成员。

- **主要区别:**

1. 方法/函数:
   - Java对象: 可以包含方法(函数)。对象中可以定义对象的动作（方法(函数)）
   - **C结构体: 本身不能包含函数,只能包含数据。**
2. 封装:
   - Java对象: 支持访问修饰符(public, private等),实现数据封装。
   - C结构体: **默认所有成员都是公开的,不支持封装。**
3. 继承和多态:
   - Java对象: 支持继承和多态,这是面向对象编程的核心特性。
   - C结构体: **不支持继承和多态。**
4. 构造函数和析构函数:
   - Java对象: 有构造函数来初始化对象。
   - C结构体: **没有内置的构造或析构机制。**
5. 内存管理:
   - Java对象: 由垃圾收集器自动管理。
   - C结构体: **需要手动管理内存。**
6. 功能复杂度:
   - Java对象: 可以实现更复杂的功能和行为。
   - C结构体: **主要用于数据存储和组织。**

总结: 虽然C语言的结构体和Java的对象在数据组织方面有相似之处,但Java的对象是一个更强大、更复杂的概念,包含了面向对象编程的许多特性。C语言的结构体更接近于Java中的简单数据对象(POJO，用来传递数据),而不是完整的类（没有方法(函数)）。

### 类型描述

```c
struct 结构体名
{
    数据类型 成员1;
    数据类型 成员2;
    ......
};
```

基本声明方式：

```c
struct TagName {
    // 成员列表
};
```

这里的TagName是结构体的标签名。例如：

```c
struct Person {
    char name[50];
    int age;
};
```

typedef 声明： 使用typedef可以为结构体创建一个新的类型名，简化后续的使用。创建一个类型别名

```c
typedef struct {
    // 成员列表
} TypeName;
```

例如：

```c
typedef struct {
    char name[50];
    int age;
} Person;
```

这样，之后就可以直接使用Person作为类型名。

结合标签名和typedef：

```c
typedef struct TagName {
    int a;
    float b;
} TypeName;

int main() {
    TypeName var1;  // 定义了一个结构体变量 var1，用的是结构体名的别名，省略了struct关键字
    var1.a = 10;
    var1.b = 3.14;

    printf("a: %d, b: %.2f\n", var1.a, var1.b);
    return 0;
}

```

**有没有标签名的区别：**

- 匿名结构体(第一种):

  - ```c
    typedef struct {  // 没有标签名
        char name[50];
        int age;
    } Person;        // Person是类型别名
    
    Person p1;       // 可以直接使用别名
    struct Person p2; // 错误！因为没有标签名，不能用struct
    ```

- 有标签名的结构体(第二种):

  - ```c
    typedef struct TagName {  // TagName是标签名
        int a;
        float b;
    } TypeName;              // TypeName是类型别名
    
    // 以下三种声明方式都可以:
    TypeName t1;             // 使用别名
    struct TagName t2;       // 使用标签名
    // TagName t3;          // 错误！标签名不能直接使用
    ```

- 主要区别:

  - ```c
    // 匿名结构体不能自引用
    typedef struct {
        int data;
        struct ???  *next;  // 错误！没有标签名无法自引用
    } Node1;
    
    // 有标签名的结构体可以自引用
    typedef struct TagNode {
        int data;
        struct TagNode *next;  // 正确！可以使用标签名自引用
    } Node2;
    ```

- 使用场景:

  - 如果结构体需要自引用（比如**链表节点），必须使用带标签名的方式**

  - 如果结构体很简单，**不需要自引用，用匿名结构体更简洁**



嵌套结构体： 结构体可以嵌套在其他结构体中。

虽然C语言和Java（内部类，静态嵌套类，局部类，匿名类）都有方式来表达嵌套的数据结构，但它们的实现方式和底层机制有很大不同。C语言的方式更直接和底层，而Java的方式更加面向对象和灵活。

```c
struct OuterStruct {
    int x;
    
    struct InnerStruct {  // 定义嵌套结构体类型（InnerStruct）
        int y;
    } inner;  // 成员变量名为 inner
};
在这种嵌套定义的情况下，你不能直接在 OuterStruct 之外使用 struct InnerStruct。
例如，以下代码是非法的.但是，你可以通过 OuterStruct 的实例来访问 InnerStruct 的成员
    
这不算别名。在嵌套结构体中，你没有通过 typedef 为结构体类型创建别名。
struct InnerStruct 是嵌套在 OuterStruct 中的类型，作用域仅限于 OuterStruct 内。
你可以通过 outer.inner 访问 struct InnerStruct 的成员，但不能直接在外部声明它的变量。
```

自引用结构体： 用于创建如链表等数据结构。

```c
struct Node {
    int data;
    struct Node* next;
};
```

匿名结构体： 在某些情况下，可以使用没有名称的结构体。

```c
struct {
    int x;
    int y;
} point;
```

**这个匿名结构体定义有问题，别名没有typedef也可以用吗？**

- 不行，匿名结构体如果不使用typedef就不能创建别名，因为没有标签名可以引用。

- 没有typedef的情况:

  - ```c
    // 匿名结构体，没有typedef
    struct {
        char name[50];
        int age;
    } person;  // 这里的person只是一个变量名，不是类型别名！
    
    person p1;  // 错误！person不是类型名
    struct person p2;  // 错误！没有标签名person
    ```

  - 其实这种定义方式也是有用的，但仅限于只需要定义一个变量的情况：

    - 相当于定义了一个普通变量，只能使用一次,不能用它定义新的变量

    - ```c
      // 这种写法是合法的，person是一个结构体变量
      struct {
          char name[50];
          int age;
      } person;  // 定义了一个结构体变量person
      
      // 可以正常使用这个变量
      person.name[0] = 'A';
      person.age = 25;
      
      // 但是不能用它定义新的变量
      person p1;  // 错误！
      struct person p2;  // 错误！
      ```

    - 这种写法主要用在：

      1. 只需要一个结构体变量的场景
      2. 这个结构体不会在其他地方重复使用
      3. 结构体很简单，用一次就够了

    - ```c
      // 在函数中临时使用一个结构体
      void func() {
          struct {
              int x;
              int y;
          } point = {10, 20};  // 定义并初始化一个临时的点结构
          
          printf("%d,%d\n", point.x, point.y);
      }
      ```

  - 但实际开发中这种用法比较少见，因为：

    1. 代码复用性差
    2. 可读性不如有名字的结构体
    3. 不能作为函数参数类型

    所以一般我们会选择：

    - 要么用typedef定义类型别名
    - 要么给结构体加上标签名 这样可以重复使用这个类型。



- 正确使用typedef:

  - ```c
    // 匿名结构体，使用typedef
    typedef struct {
        char name[50];
        int age;
    } Person;  // Person是类型别名
    
    Person p1;  // 正确！Person是类型名
    ```

- 有标签名的情况:

  - ```c
    // 不使用typedef也可以重复使用，因为有标签名
    struct TagPerson {
        char name[50];
        int age;
    };
    
    struct TagPerson p1;  // 正确！可以用标签名
    ```

- 有标签名且使用typedef:

  - ```c
    typedef struct TagPerson {
        char name[50];
        int age;
    } Person;
    
    // 以下都正确
    Person p1;
    struct TagPerson p2;
    ```

- 所以关键是:

  - 匿名结构体必须使用typedef才能创建可重用的类型名
  - 有标签名的结构体不强制要求使用typedef，因为可以通过struct 标签名来使用



使用结构体时，可以这样声明变量：

```c
struct Person p1;  // 使用struct关键字
Person p2;         // 如果使用了typedef,struct关键字就可以省略
```

### 结构体定义位置

**全局定义（文件开头）**

- **位置**：定义在所有函数之外，通常在文件开头。
- **用途**：该结构体可以在**整个文件内**被所有函数访问，适合需要在**多个函数中共享的结构体**。

```c
#include <stdio.h>

struct Student {
    int id;
    char name[20];
};

void printStudent(struct Student s);

int main() {
    struct Student s1 = {1, "Alice"};
    printStudent(s1);
    return 0;
}

void printStudent(struct Student s) {
    printf("ID: %d, Name: %s\n", s.id, s.name);
}
```

**函数内部定义（局部定义）**

- **位置**：结构体定义在某个函数的内部。
- **用途**：**只在该函数内有效，不会影响其他函数。**

```c
#include <stdio.h>

int main() {
    struct Point {
        int x;
        int y;
    };

    struct Point p = {10, 20};
    printf("x: %d, y: %d\n", p.x, p.y);

    return 0;
}
```

**头文件中定义** (源文件之间共享，只要包含头文件即可)

- **位置**：结构体定义在头文件（`.h` 文件）中。
- **用途**：方便在多个 `.c` 文件中共享结构体定义。

student.h

```c
#ifndef STUDENT_H
#define STUDENT_H

struct Student {
    int id;
    char name[20];
};

#endif
```

main.c

```c
#include <stdio.h>
#include "student.h"

int main() {
    struct Student s = {1, "Bob"};
    printf("ID: %d, Name: %s\n", s.id, s.name);
    return 0;
}
```

### 嵌套定义

```c
struct birthday{
	int year;
	int month;
	int day;
};
struct Student {
    int id;
    char name[20];//防止名字太长装不下，所以一个学生的姓名空间的数组大小就有二十个
    struct birthday birth;
    int math;
    int chinese;
};
```

你需要写 `struct birthday birth`，因为 `birthday` 是一个**结构体类型**，而 `birth` 是这个类型的**变量名**。`struct birthday` 表示使用名为 `birthday` 的结构体类型。`birth` 是 `struct Student` 中的成员变量，表示每个学生对象都包含一个 `birthday` 类型的成员。

这种形式的嵌套**确实更直观**，因为你把 `struct birthday` **定义在外部**，然后在 `struct Student` 中**作为成员类型引用**，**而不是在内部嵌套定义（birthday结构体可以被其他结构体复用）**。这种方式常见于实践，结构清晰、可读性高。

**结构体类型独立**：`struct birthday` 是一个独立的结构体类型，可以在任何地方使用，而不仅限于 `struct Student` 中。

**重用性更高**：因为 `struct birthday` 独立定义，你可以在其他结构体或函数中直接使用它，而无需重复定义。

### 定义变量（变量，数组，指针），初始化及成员引用

C 语言和 Java 在引用结构体或对象时，都遵循类似的规则：**结构体（或类）本身只是一个类型，要使用它时必须声明一个变量来实例化具体的对象。**

在 C 中，定义结构体时你只是在创建一种**数据类型**，但要使用它时，必须声明一个变量。

```c
struct birthday {
    int year;
    int month;
    int day;
};

struct Student {
    int id;
    char name[20];
    struct birthday birth;  // 嵌套结构体，成员变量为 birth
    int math;
    int chinese;
};
```

使用结构体时：

```c
int main() {
    "先实例化，再初始化"
    struct Student s1;  // 创建一个 Student 类型的变量 s1
    s1.id = 1;
    s1.math = 90;
    s1.birth.year = 2000;  // 通过嵌套结构体访问成员
    s1.birth.month = 5;
    s1.birth.day = 10;

    printf("ID: %d, Birthday: %d-%02d-%02d\n", 
            s1.id, s1.birth.year, s1.birth.month, s1.birth.day);

    return 0;
}
```

- `struct Student` 是结构体类型。

- `s1` 是 `struct Student` 的实例（即变量），用于实际操作。

- 如果不声明变量（如 `s1`），你无法访问结构体的成员。

**综合示例**：

```c
#include <stdio.h>

// 定义外层结构体 OuterStruct
struct OuterStruct {
	int x;
	
	// 嵌套结构体 InnerStruct
	struct InnerStruct {
		int y;
	} inner;  // 内部结构体成员变量,上面的嵌套类型写法好理解一点
};

int main() {
	// 1. 定义单个结构体变量并初始化
	struct OuterStruct var1 = {10, {20}};
	
	// 2. 定义结构体数组并初始化
	struct OuterStruct array[2] = {
		{30, {40}}, 
		{50, {60}}
	};
	
	// 3. 定义结构体指针并初始化
	//在 C 语言中，当你初始化一个结构体变量时，它会被分配在内存中的某个地址上。因此，使用 &（取地址符号）可以获得这个结构体变量的地址。
    //结构体名啥也不是跟数组名区分开来
	struct OuterStruct *ptr = &var1;
	struct OuterStruct *ptr2 = array;
	
	// 访问结构体成员
//	printf("var1.x: %d, var1.inner.y: %d\n", var1.x, var1.inner.y);
	
	// 访问结构体数组成员
//	printf("array[0].x: %d, array[0].inner.y: %d\n", array[0].x, array[0].inner.y);
//	printf("array[1].x: %d, array[1].inner.y: %d\n", array[1].x, array[1].inner.y);
	
	// 使用指针访问结构体成员（重点）
	printf("ptr->x: %d, ptr->inner.y: %d\n", ptr->x, ptr->inner.y);
	//就按数组名那一套使用
	printf("ptr2->x: %d, ptr2->inner.y: %d\n", ptr2->x, ptr2->inner.y);
	printf("ptr2->x: %d, ptr2->inner.y: %d\n", (ptr2+1)->x, (ptr2+1)->inner.y);
	
	
	// 修改指针指向的结构体成员
	ptr->x = 100;
	ptr->inner.y = 200;
	(ptr2+1)->x = 150;
	(ptr2+1)->inner.y  = 250;
	
	// 查看修改后的结果
	printf("After modification: var1.x: %d, var1.inner.y: %d\n", var1.x, var1.inner.y);
	printf("ptr2+1->x: %d, ptr2+1->inner.y: %d\n", (ptr2+1)->x, (ptr2+1)->inner.y);
    //.的优先级比*要高！！！
    printf("ptr2+1->x: %d, ptr2+1->inner.y: %d\n", (*(ptr2+1)).x, (*(ptr2+1)).inner.y);
	
	return 0;
}
```

**成员访问与修改：**

- 使用点号（`.`）访问结构体成员。

- [使用箭头符号（`->`）通过指针访问结构体成员](###结构体指针偏移和数组指针偏移的区别)。

  - **结构体成员在内存中是连续存储的,就像数组一样。通过指针偏移来访问成员正是箭头运算符(->)的工作原理。**

  - ```c
    struct Student {
        char name[20];  // 假设从地址1000开始
        int age;        // 从地址1020开始(1000 + 20)
        float score;    // 从地址1024开始(1020 + 4)
    };
    
    struct Student *p = &stu;  // p存储的是结构体的起始地址1000
    
    // 这两种写法是等价的:
    p->age;      // 自动计算偏移量访问age
    (*p).age;    // 先解引用得到结构体,再用点运算符
    ```

  - 编译器在编译时会:

    1. 计算每个成员的大小和偏移量
    2. **考虑内存对齐的要求**
       1. **因为考虑到成员对齐的情况，所以真实的情况应该不是地址这么准确吧？ 只是为了好理解而已**
    3. 当使用 p->age 时,会自动计算 age 相对于结构体起始位置的偏移量
    4. 然后用: 起始地址 + 偏移量 来访问对应成员

  - ```c
    // p->age 实际上等价于:
    *(int *)((char *)p + offsetof(struct Student, age))
    ```

  - 这里:

    - (char *)p 是为了以字节为单位移动指针
    - offsetof 是编译器计算的成员偏移量
    - (int *) 把偏移后的地址转为 int 指针
    - 最后解引用得到值

- 使用结构体变量（点号 . ）： 当您有一个结构体变量时，使用结构体变量名+点号(.)来访问其成员。

  使用结构体指针（箭头 -> ）： 当您有一个**指向结构体的指针时，使用箭头**(->)来访问其成员。

- 修改指针指向的结构体成员，直接影响 `var1` 的值。

  - **通过指针访问结构体成员并修改值**，会直接改变**原始结构体变量的数据**，而不是修改一个副本。这是因为**指针指向的是结构体变量的内存地址**，所以所有对该地址的操作都会反映在原始数据上。

### 占用内存空间大小

- 结构体成员的存储确实是有顺序的，但并不总是严格按照声明顺序连续存放的。

基本顺序： 成员通常按照它们在结构体中声明的顺序排列。

内存对齐： 编译器会进行内存对齐，这可能导致成员之间出现间隙（称为填充）。

对齐规则：

- 每个成员都有自己的对齐要求，通常是其自身大小的倍数。
- 整个结构体的大小通常是其最大成员对齐要求的倍数。

填充： 为了满足对齐要求，编译器可能在成员之间或结构体末尾添加填充字节。

[详解传送门](####对齐规则)



**结构体会占用内存空间**，但只有在**实例化（创建结构体变量）时**才会分配内存空间。

- **结构体的定义阶段**

当你**定义一个结构体类型**时（使用 `struct` 关键字），**不会分配内存**。
定义只是告诉编译器这个结构体类型有哪些成员，以及它们的排列方式。

```c
struct Example {
    int a;
    float b;
    char c;
};
```

上面代码只是定义了一个 **`Example`** 结构体类型，它不会立即占用内存。

只有当你**实例化结构体变量**时，才会分配内存。

- 实例化阶段：内存分配发生在这里

```c
struct Example var1;  // 实例化结构体变量
```

**`var1`** 是一个结构体变量，它在创建时会**占用内存**。

每个成员的大小会按其类型占用对应的内存空间。

**结构体的大小**通常等于所有成员大小的**总和**，**但由于内存对齐的要求，可能会略大。编译器会对结构体进行对齐，以提高访问速度。**

- 初始化阶段

初始化结构体变量时，只是给成员赋初值，不会额外占用新的内存。

```c
struct Example var1 = {10, 3.14, 'A'};  // 初始化结构体变量
```

**内存大小在实例化时已经确定**。

**初始化只是填充这块内存**，不会额外增加空间。

### 作为函数参数传递的应用

```c
#include <stdio.h>

// 定义表示矩形的结构体
struct Rectangle {
    float length;
    float width;
};

// 函数原型，接受结构体作为参数，这属于声明
float calculateArea(struct Rectangle rect);//关键字+数据类型+变量名

int main() {
    // 创建一个 Rectangle 结构体实例，内存会分配空间
    struct Rectangle myRect = {5.0, 3.0};
    
    // 调用函数，传递结构体作为参数
    float area = calculateArea(myRect);
    
    printf("矩形的面积是: %.2f\n", area);
    
    return 0;
}

// 函数定义，计算矩形面积
float calculateArea(struct Rectangle rect) {
    return rect.length * rect.width;
}
```

结构体定义：我们定义了一个`Rectangle`结构体，包含长度和宽度。

函数参数：`calculateArea`函数接受一个`Rectangle`结构体作为参数。

值传递：**在C语言中，结构体默认是通过值传递的。这意味着函数接收的是结构体的一个副本。**

结构体使用：我们在`main`函数中创建了一个`Rectangle`实例，并将其传递给`calculateArea`函数。

访问结构体成员：在`calculateArea`函数中，我们使用点号(.)来访问结构体的成员（**因为传递的是结构体副本**）。



**当结构体较大时，直接传递结构体作为参数可能会导致较大的开销，因为这涉及到整个结构体的复制。使用指针传递可以显著减少这种开销。**

```c
#include <stdio.h>
#include <string.h>

// 定义一个较大的结构体,有数组
struct Employee {
    int id;
    char name[100];
    char department[50];
    float salary;
};

// 函数原型，使用指针作为参数，声明
void printEmployee(const struct Employee* emp);
void giveRaise(struct Employee* emp, float percentage);

int main() {
    //结构体实例化
    struct Employee emp1 = {1001, "John Doe", "IT", 50000.0};
    
    // 传递结构体的地址，要加取地址符号，结构体名不能代表是什么
    printEmployee(&emp1);
    
    // 修改结构体内容
    giveRaise(&emp1, 10.0);
    
    printf("After raise:\n");
    printEmployee(&emp1);
    
    return 0;
}

// 函数定义，使用指针访问结构体成员，const表示只能读不能修改
//数据类型 + 变量名 = 值 
void printEmployee(const struct Employee* emp) {
    printf("ID: %d\n", emp->id);
    printf("Name: %s\n", emp->name);
    printf("Department: %s\n", emp->department);
    printf("Salary: %.2f\n", emp->salary);
}

// 函数定义，修改结构体内容
void giveRaise(struct Employee* emp, float percentage) {
    emp->salary += emp->salary * (percentage / 100);
}
```

1. 指针参数：函数 `printEmployee` 和 `giveRaise` 接受 `struct Employee*` 类型的参数，即结构体指针。指针接收时类型必须要对应，不然取值时找不到正确的数据。
2. 箭头操作符：使用 `->` 来通过指针访问结构体成员，如 `emp->id`。
3. const 关键字：在 `printEmployee` 函数中使用 `const` 表明该函数不会修改结构体的内容。
4. 传递地址：在 `main` 函数中，我们使用 `&` 操作符传递结构体的地址。
5. 直接修改：在 `giveRaise` 函数中，我们可以直接修改原结构体的内容。

使用指针传递结构体的优点：

1. 效率高：不需要复制整个结构体，只传递一个地址。
2. 节省内存：特别是对于大型结构体，可以显著减少栈空间的使用。
3. 允许修改：**可以直接修改原结构体的内容**（除非使用 `const`）。

需要注意的是：

- 使用指针时要小心，确保指针指向有效的内存地址。
- 如果不希望函数修改原结构体，可以使用 `const` 限定符。
- 在多线程环境中使用指针时需要考虑同步问题。



**在C语言中，函数传递数组时是可以影响原数组的，那么结构体也可以嘛？**

在C语言中，**函数传递数组**时传递的是数组的指针（即数组的首地址），退化为指针。因此在函数内对数组元素的修改会直接影响到原数组。

对于**结构体**，C语言中有两种传递方式：

1. **值传递**（默认方式）
   当你将一个结构体变量作为参数传递给函数时，实际上传递的是这个结构体的一个**副本**。在函数内部对结构体的修改**不会影响**原结构体。
2. **指针传递**
   如果你希望函数修改结构体的原始值，需要传递结构体的指针。

### 结构体的本质

**突然看到了结构体的本质，它确实是一种新的数据类型了，通过这么定义，新结构体类型的数组，那么我一个数组索引下标就可以存多个数据了？**

```c
// 树节点结构体
typedef struct {
    int value;           // 节点值
    int parent_index;    // 父节点索引
} TreeNode;
// 树结构体
typedef struct {
    TreeNode nodes[MAX_SIZE];  // 存储节点的数组
    int size;                  // 当前节点数量
} ParentIndexTree;

// 添加节点
int addNode(ParentIndexTree* tree, int value, int parent_index) {
    if (tree->size >= MAX_SIZE) return -1;
    
    // 添加新节点
    //size可以当数组索引了，都是从0开始
    int current_index = tree->size;
    tree->nodes[current_index].value = value;
    tree->nodes[current_index].parent_index = parent_index;
    tree->size++;
    
    return current_index;
}
```

![image-20241105143315874](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录3之构造类型.assets\image-20241105143315874.png)

结构体确实体现了几个重要的编程概念：

- 数据封装

  - ```c
    // 一个位置可以存储多个相关的数据项
    TreeNode node = {
        .value = 10,          // 节点值
        .parent_index = -1    // 父节点索引
    };
    ```

- 数组索引的扩展功能

  - ```c
    // 通过一个索引可以访问多个数据
    TreeNode nodes[100];   // 数组
    nodes[0].value = 10;        // 访问第0个节点的值
    nodes[0].parent_index = -1; // 访问第0个节点的父索引
    ```

- 数据组织

  - ```c
    ParentIndexTree tree;
    // 一次性访问一个节点的所有信息
    TreeNode current_node = tree.nodes[5];  // 获取完整的节点信息
    ```

- 内存效率

  - ```c
    // 连续内存布局，访问效率高
    sizeof(TreeNode);    // 8字节 (int + int)
    sizeof(TreeNode) * MAX_SIZE;  // 整个数组的大小
    ```

- 抽象能力

  - ```c
    // 可以定义更复杂的数据结构
    typedef struct {
        TreeNode node;       // 嵌套结构体
        int children_count;  // 额外信息
        int depth;          // 更多相关数据
    } EnhancedNode;
    ```

这种设计让我们可以：

- 把相关的数据组织在一起
- 用单个索引管理多个相关数据
- 创建更复杂的数据结构
- 提高内存访问效率

结构体实际上创造了一种新的"组合类型"，就像搭建积木一样，可以把基本类型组合成更复杂和实用的数据结构。这是C语言中面向对象思想的基础。

### 嵌套结构体的大小

**那么结构体ParentIndexTree占用空间大小怎么算？这应该算嵌套了？ int size+TreeNode nodes[MAX_SIZE]也就是： int size+(int value int int parent_index;)*MAX_SIZE再对齐之后的大小吗？**

![image-20241105145118759](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录3之构造类型.assets\image-20241105145118759.png)

是的,你的思路很对! 让我详细解释一下结构体的内存大小计算,包括对齐规则。

- **TreeNode结构体大小**：

  - ```c
    sizeof(TreeNode) = 8字节
    - int value        (4字节)
    - int parent_index (4字节)
    - 对齐要求：4字节对齐
    ```

- **ParentIndexTree结构体大小**：

  - ```c
    sizeof(ParentIndexTree) = 804字节
    - TreeNode nodes[100] (8字节 × 100 = 800字节)
    - int size           (4字节)
    - 对齐要求：4字节对齐
    ```

- 内存对齐规则：

  1. 基本对齐规则：

     - 结构体变量的首地址必须是其最大基本类型成员的整数倍
     - 每个成员相对于结构体首地址的偏移量必须是该成员大小的整数倍
     - 结构体的总大小必须是最大对齐数的整数倍

  2. **具体到这个例子**：

     1. ```c
        struct TreeNode {
            int value;        // 偏移量0，满足4字节对齐
            int parent_index; // 偏移量4，满足4字节对齐
        };                    // 总大小8，满足4字节对齐
        
        struct ParentIndexTree {
            TreeNode nodes[100]; // 偏移量0，满足8字节对齐
            int size;           // 偏移量800，满足4字节对齐
        };                      // 总大小804，满足4字节对齐
        ```

- 关键注意点：

  1. 结构体嵌套会导致内存对齐要求的传递
  2. 数组元素会连续存储，每个元素都遵守对齐规则
  3. 最终大小会因编译器和平台的不同而可能略有差异
  4. 可以使用 `#pragma pack` 来修改对齐规则

  这种内存布局的优点是：

  - 访问效率高（对齐的内存访问更快）
  - 内存布局清晰
  - 便于数组索引计算

  缺点是：

  - 可能会有一些内存浪费（因为对齐）
  - 在不同平台上大小可能不同

#### 对齐规则

在C语言中，**内存对齐规则**主要是为了提高访问速度和硬件效率。对齐规则与成员的**定义顺序**密切相关，下面我们详细讨论对齐规则以及它如何影响结构体的内存布局。

1.**基本对齐规则**

- **对齐原则**：**每个成员的起始地址必须是其类型大小的整数倍（也就是成员的对齐要求）。**
- **填充规则**：如果某个成员的起始地址不满足其对齐要求，就需要在前一个成员之后插入填充字节（padding），以使当前成员的起始地址满足对齐要求。
- **结构体对齐**：结构体的总大小必须是其最大成员对齐要求的整数倍。

2.**成员定义顺序的影响**

不同的成员定义顺序会导致不同的内存布局，从而影响填充字节的分布。

案例1：先定义8字节成员，再定义4字节成员

```c
struct Example1 {
    double a;  // 8字节类型，偏移量0，地址为8的倍数
    int b;     // 4字节类型，需要4字节对齐
};
```

- `a`（`double`）的起始地址是偏移量0，满足8字节对齐。

- `b`（`int`）的起始地址需要是4字节对齐。此时：

  - `a`占用了偏移量0~7。

  - `b`的起始地址是偏移量8，已经是4的倍数，不需要填充。

3.**结构体总大小：**

- `b`占用偏移量8~11。
- 由于结构体的最大对齐要求是8（由`double`决定），所以总大小需要是8的倍数。因此，`b`之后还需要填充4个字节，结构体大小为**16字节**。



案例2：先定义4字节成员，再定义8字节成员

```c
struct Example2 {
    int b;      // 4字节类型，需要4字节对齐
    double a;   // 8字节类型，需要8字节对齐
};
```

- `b`（`int`）的起始地址是偏移量0，满足4字节对齐。

- `a`（`double`）的起始地址需要是8字节对齐。此时：

  - `b`占用了偏移量0~3。

  - 偏移量4~7被填充，`a`从偏移量8开始。

- **结构体总大小：**

  - `a`占用偏移量8~15。
  - 最大对齐要求为8字节，结构体大小已经是8的倍数，因此不需要额外填充。
  - **总大小为16字节**。

**总结**

- **填充发生的位置**取决于成员的定义顺序和每个成员的对齐需求。
- 如果**小字节成员**（如`int`）在**大字节成员**（如`double`）之前定义，则需要在两者之间填充字节，以满足后续成员的对齐需求。
- 如果**大字节成员**在前，通常不会导致中间填充，但可能会导致结构体尾部填充。
- 在C语言中结构体对齐遵循的规则：
  1. 第一个成员的偏移量为0
  2. 每个成员相对于结构体**起始位置的偏移量必须是对齐值的整数倍（对齐值通常是成员的大小）**
  3. 结构体的**总大小**必须是所有成员中最大对齐值的整数倍

实例：

```c
typedef struct
{
    long i;    // 4字节
    int k[6];  // int为4字节，数组共24字节
    char c;    // 1字节
}DATA;
```

让我重新分析：

1. long i：占4字节，0-3
2. int k[6]：占24字节，4-27
3. char c：占1字节，**从28开始到29才到1字节**
4. 由于最大对齐要求是4字节，结构体总大小必须是4的倍数
5. 28+1=29不是4的倍数
6. 需要填充到32（最近的4的倍数）

所以确实需要填充3个字节，最终大小应该是32字节，而不是28字节。

**画内存分布图**

```
0    4           28  29      32
    |----|-----------|-|--|
    | i  |    k[6]   |c|pad|
    |----|-----------|-|--|
     4      24        1  3
```



**所以一般建议大字节成员定义在前面，小字节成员定义在后面，可以节约空间？ 如果大字节成员在前的话，偏移量较大，可以满足后面的倍数需求，但是小字节就不行？**

是的，在设计结构体时，**将大字节成员放在前面，小字节成员放在后面**通常可以减少填充字节，从而更节约空间。让我们详细分析这一点。

- **大字节成员的对齐需求较高**

大字节成员（如`double`，8字节）对齐要求高，如果定义在较靠后的位置，需要确保它的起始地址是8的倍数。这可能会导致在小字节成员之后插入填充字节。

- **小字节成员的对齐需求较低**

小字节成员（如`char`、`int`）对齐要求较低。如果它们放在大字节成员后面，大字节成员的偏移量通常已经满足它们的对齐要求，因此通常不会再插入额外的填充字节。

- 是按照对齐需求来而不是大小：

  - ```c
    struct Student {
        double score;   // 8字节对齐
        int age;        // 4字节对齐
        char name[20];  // 1字节对齐
    };
    name 结束于偏移量 31。
    由于结构体的最大对齐要求是 8（由 double 决定），因此结构体总大小需对齐到 8 的倍数。填充 0 字节，总大小为 32 字节。
    ```

  - ```c
    struct Student {
        char name[20];  // 占用 20 字节
        double score;   // 占用 8 字节，8字节对齐
        int age;        // 占用 4 字节，4字节对齐
    };
    age 结束于偏移量 35。
    由于结构体的最大对齐要求是 8，结构体大小需对齐到 8 的倍数，最后填充 4 字节，总大小为 40 字节。
    ```

    

**如果结构体定义在前面的是char 1个字节，接着后面定义的是int 4字节，那么为了对齐，中间的空间会扩大对齐到4字节，这样的话内存就可以减少读取时间了？可以的话给我画一个示意图**

![image-20241105150227387](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录3之构造类型.assets\image-20241105150227387.png)

解释一下这个内存对齐过程：

```c
struct Example {
    char c;    // 1字节
    int i;     // 4字节
}; // 理论上需要5字节
```

- char占用第1个字节，偏移0~1
- int从第2个字节开始，不是4的倍数，对齐到4，偏移4~7

**对齐后**：

```c
struct Example {
    char c;    // 1字节
    // 编译器自动插入3字节padding
    int i;     // 4字节，从地址0x04开始
}; // 实际占用8字节
```

- char仍占用第1个字节
- 插入3字节填充
- int从第4字节开始（4字节对齐）
- CPU可以一次性读取int值

对齐的好处：

1. 性能提升：
   - CPU可以一次性读取完整的int
   - 避免了跨边界访问带来的额外开销
2. 硬件兼容性：
   - 某些处理器要求特定类型的数据必须对齐
   - 不对齐可能导致硬件异常
3. 内存访问效率：
   - 对齐的内存访问通常更快
   - 减少了CPU的读取次数

需要注意：

1. 填充（padding）是编译器自动完成的
2. 虽然会占用更多内存，但这是用空间换取时间的经典案例
3. 不同编译器可能有不同的对齐策略
4. 可以通过特定指令控制对齐方式（如#pragma pack）

这就是为什么有时候结构体的大小会大于其成员大小之和的原因。这种设计是处理器架构、内存访问效率和硬件限制共同作用的结果。

#### CPU读取大小

让我详细解释一下CPU的内存访问特点。

**CPU的内存访问特性**：

```c
// 32位CPU示例
struct Example {
    char c;     // 1字节
    int i;      // 4字节
};
```

CPU一次内存访问的自然对齐大小：

- 32位CPU通常是4字节
- **64位CPU通常是8字节**
- 这个值称为"字长"

**对齐访问的过程**：

```c
// 对齐后的内存布局
struct Example {
    char c;     // 地址0x00
    char pad[3]; // 填充：地址0x01-0x03
    int i;      // 地址0x04-0x07（对齐到4字节边界）
};
```

- CPU可以一次完整读取int值

- 不需要额外的处理操作

**未对齐访问的问题**：

```c
// 未对齐的情况
struct BadExample {
    char c;     // 地址0x00
    int i;      // 地址0x01-0x04（跨越了4字节边界！）
};
```

CPU需要：

1. 读取第一个4字节块
2. 读取第二个4字节块
3. 进行位移操作
4. 组合得到最终数据

**性能影响**：

```c
// 性能对比
aligned_read():    // 1个CPU周期
unaligned_read():  // 2-10个CPU周期（取决于架构）
```

所以，内存对齐的必要性来自：

1. 硬件层面：
   - CPU的内存访问单元设计
   - 内存总线宽度
   - 缓存线（cache line）对齐
2. 性能考虑：
   - 减少内存访问次数
   - 避免额外的位操作
   - 提高缓存效率
3. 兼容性：
   - 确保代码在不同平台上可靠运行
   - 避免某些处理器的硬件异常

这就是为什么结构体会自动进行内存对齐，虽然可能会浪费一些空间，但这种空间换时间的做法在大多数情况下是值得的。

![image-20241105150950158](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录3之构造类型.assets\image-20241105150950158.png)

**对齐访问的优势**

对齐访问指的是数据存储在**符合其对齐要求的地址上**。比如：

- **8字节的`double`\**存储在\**8的倍数**的地址上。
- **4字节的`int`\**存储在\**4的倍数**的地址上。

**对齐访问的特点：**

- **单次内存访问完成读取**：CPU可以通过一次内存总线操作直接读取目标数据，因为数据在对齐的地址上，可以整块加载。
- **高效读取**：由于64位CPU一次可以读取8字节，对齐的数据能让CPU充分利用内存总线的宽度，减少额外操作。
- **硬件优化**：大部分现代CPU对对齐访问进行了优化，读取效率更高。

**不对齐访问的劣势**

不对齐访问指的是数据存储在**不符合其对齐要求的地址上**。比如：

- **8字节的`double`\**存储在\**非8的倍数**的地址上（如0x1001）。

**不对齐访问的特点：**

- **跨越两次内存访问**：由于数据没有对齐，读取数据可能跨越多个内存块，导致需要**两次内存访问**。
- **额外开销**：CPU需要对读取的多个内存块进行额外的处理（合并、拆分等），从而增加延迟。
- **性能下降**：这种额外操作会导致显著的性能损失，尤其是在大量连续不对齐访问的情况下。

**例子：不对齐访问`double`**

如果`double`存储在地址0x1001：

1. CPU需要从0x1000读取**前半部分**。
2. 再从0x1008读取**后半部分**。
3. **然后将两部分数据拼接起来。**

这导致额外的**两次内存读取**和**数据拼接操作**。

**例子：对齐访问`double`**

如果`double`存储在对齐地址（如0x1000），读取可以通过**一次内存访问**直接完成。

### 结构体与数组的相似之处

C语言中结构体和数组的异同点:

**相似之处:**

1. 都是复合数据类型，可以存储多个数据项
2. 都在内存中占用连续的空间
3. 都可以通过指针来访问
4. 两者都可以作为函数参数传递

**主要差异:**

1. 数据类型:

   - 数组只能存储相同类型的数据

   - 结构体可以存储不同类型的数据成员

2. 访问方式:
   - 数组通过下标访问: array[0], array[1]
   - 结构体通过成员名访问: student.name, student.age
     - 当指针指向结构体时，可以直接使用箭头访问成员变量

3. 内存分配: 这里需要纠正一个误解 - 结构体在定义变量时也会立即分配内存空间，和数组一样。例如:

   1. ```c
      struct Student {
          char name[20];
          int age;
      }; // 这里只是定义了类型，不占用空间
      
      struct Student s1; // 这里会分配内存空间
      int arr[10];      // 这里也会分配内存空间
      ```

4. 大小计算:

   - 数组大小 = 元素类型大小 × 元素个数

   - 结构体大小 = 所有成员大小之和 + 可能的内存对齐填充

**他们的作用是不一样的，结构体是把相关的数据集中管理，便于理解，定义，初始化，作为参数传递也很方便，只需要给一个指针就可以通过箭头直接访问**

**组织目的不同:**

- 结构体是为了将逻辑相关的数据组织在一起，提高代码的可读性和可维护性
- 数组主要是为了存储和处理同类数据集合

```c
// 结构体很适合表达现实世界的实体
struct Student {
    char name[50];
    int id;
    float gpa;
    char major[30];
};

// 数组适合存储同类数据集合
int scores[100];  // 存储100个成绩
```

**参数传递的便利性:**

```c
// 结构体传递 - 只需要一个指针
void updateStudent(struct Student *s) {
    s->gpa = 3.9;  // 通过箭头运算符直接访问
}

// 数组传递
void updateScores(int scores[], int size) {
    // 需要同时传递数组和大小
    for(int i = 0; i < size; i++) {
        // 处理数组
    }
}
```

**初始化方式:**

```c
// 结构体可以清晰地按成员初始化
struct Student s1 = {
    .name = "张三",
    .id = 101,
    .gpa = 3.8,
    .major = "Computer Science"
};

// 数组初始化相对简单
int scores[] = {98, 87, 93, 95};
```

这就是为什么在设计程序时:

- 当需要表达一个实体的多个属性时，我们使用结构体
- 当需要处理同类数据的集合时，我们使用数组

### 结构体与Java类的相似之处

**结构体其实跟Java的对象差不多，对象中也是包含了各种类型的相关数据**

相似之处:

1. 数据组织:

```c
// C结构体
struct Person {
    char name[50];
    int age;
    float height;
};
```

```java
// Java类
class Person {
    String name;
    int age;
    float height;
}
```

**访问方式相似:**

```c
// C结构体访问
struct Person p;
p.age = 25;
// 指针访问
struct Person *ptr = &p;
ptr->age = 25;
```

```java
// Java对象访问
Person p = new Person();
p.age = 25;
```

主要区别:

1. 方法/函数:

- Java对象可以包含方法，实现数据和行为的封装
- C结构体只能包含数据成员，相关函数需要在外部定义

封装特性:

```Java
// Java支持访问控制
class Person {
    private String name;  // 私有成员
    public void setName(String name) {
        this.name = name;
    }
}
```

```c
// C结构体没有访问控制
struct Person {
    char name[50];  // 默认都是公开的
};
```

**内存管理:**

- Java对象由垃圾回收器管理

- C结构体需要手动管理内存（特别是当结构体包含指针成员时）

  - 普通的结构体变量是自动管理的:

    - ```c
      struct Person {
          char name[50];
          int age;
      };
      
      void func() {
          struct Person p;  // 在栈上分配，函数返回时自动释放
          p.age = 25;
      }  // 不需要手动释放
      ```

  - 只有使用动态内存的情况才需要手动管理:

    - ```c
      struct Person {
          char *name;  // 指针成员
          int age;
      };
      
      struct Person *p = malloc(sizeof(struct Person));
      p->name = malloc(50);  // 动态分配name的空间
      strcpy(p->name, "张三");
      
      // 使用完需要手动释放
      free(p->name);  // 先释放指针成员
      free(p);        // 再释放结构体本身
      ```

  - 数组成员不需要手动管理:

    - ```c
      struct Student {
          char name[50];    // 数组是结构体的一部分，不需要手动管理
          int scores[10];
      };
      
      struct Student s;  // 自动管理内存
      ```

### 结构体指针偏移和数组指针偏移的区别

**指针指向一个结构体后，可以通过箭头访问其中的成员，这和指针指向数组，知道地址使用解引用一个原理，都是指针偏移？**

让我来解释指针访问结构体成员和数组元素的区别：

虽然两者都涉及内存寻址，但原理上有所不同：

- 数组指针的偏移：

  - ```c
    int arr[5] = {1, 2, 3, 4, 5};
    int *p = arr;
    // p + 1 会向后偏移一个 int 的大小(比如4字节)
    printf("%d", *(p + 1)); // 输出2
    ```

- 结构体指针访问成员：

  - ```c
    #include <stdio.h>
    
    struct Person {
    	int age;     // 假设从地址0开始
    	char name[20]; // 从地址4开始
    };
    
    int main(){
    	struct Person p = {17,"wangfuxing"};
    	printf("%d\t%s\n",p.age,p.name);
    	//结构体名跟数组名区分开来，结构体名啥也不是
    	struct Person *ptr = &p;
    	printf("%d\t%s\n",ptr->age,ptr->name);
    	
    	return 0;
    
    }
    ```

- 主要区别：

  1. 数组指针偏移是均匀的，每次加1都偏移相同的字节数(元素大小)

  2. 结构体成员访问：

     - 箭头运算符(->)是语法糖，`p->age` 等价于 `(*p).age`
       - **.的优先级比*要高，括号必须有**

     - **编译器会根据结构体的内存布局，自动计算每个成员相对于结构体起始地址的偏移量**

     - **成员之间可能存在内存对齐，偏移量不一定连续**

     - 不同成员的类型可能不同，占用空间也不同
     - 所以结构体成员访问更复杂，需要编译器处理内存布局和对齐，而不是简单的指针算术运算。

  3. 数组名vs结构体名的本质区别:

     1. ```c
        int arr[5] = {1,2,3,4,5}; 
        int *p1 = arr;  // 数组名arr直接表示数组首地址
                        // 不需要取地址符&
        
        struct Person {
            int age;
            char name[20];
        } person;
        struct Person *p2 = &person; // 结构体名person只是个标识符
                                    // 必须用&取地址
        ```

  4. 结构体指针的箭头访问本质:

     1. ```c
        struct Person persons[3] = {{18,"Tom"}, {20,"Jerry"}, {22,"Mike"}};
        struct Person *p = persons; // persons是数组名,直接得到首地址
        
        // 以下两种写法等价:
        p->age;        // 语法糖
        (*p).age;      // 实际操作:先解引用得到结构体,再用.访问成员
        
        // 访问第二个结构体的写法:
        (p+1)->age;    // 先偏移一个结构体大小,再通过箭头访问
        (*(p+1)).age;  // 拆解:先偏移,再解引用得到结构体,再用.访问
        ```

- 关于`(*p)`:

  - 是的,`(*p)`确实是在解引用得到完整的结构体

  - 然后才能用点号`.`访问其成员

  - 这就是为什么`(*p).age`和`p->age`等价

  - 箭头运算符确实隐藏了复杂的指针运算,它帮我们完成了:

    1. 计算结构体大小的偏移(如果需要)

    2. 解引用得到结构体

    3. 访问特定成员

  - 这样的设计让代码更简洁易读,而不必每次都写出完整的解引用和成员访问操作。



**只能通过结构体的语法去访问成员了，因为这不像数组，结构体开空间时会内部对齐操作，所以只能拿到结构体使用.成员名访问或者使用指针+箭头访问？**

是的,你理解得很准确。让我详细解释一下为什么必须通过特定语法访问结构体成员:

- 结构体的内存布局特点:

```c
struct Student {
    char name[20];  // 从偏移量0开始
    int age;        // 可能有填充以对齐
    double score;   // 可能有填充以对齐
};

struct Student stu = {"Tom", 18, 98.5};
```

内存示意:

```c
|name[20]       |填充|age(4字节)|填充|score(8字节)|
|---------------|---|----------|---|------------|
```

不能像数组那样直接用指针算术:

```c
// 数组可以这样
int arr[5] = {1,2,3,4,5};
int *p = arr;
*(p + 1);  // 可以,因为元素大小固定,偏移量明确

// 结构体不能这样
struct Student *p = &stu;
*(p + 1);  // 错误!不能直接进行指针偏移访问成员
p->age;    // 正确,让编译器处理偏移和对齐
(*p).age //只能使用特定语法访问结构体
```

**必须使用专门的语法访问的原因:**

- 结构体成员可能有不同的数据类型（**单纯的加减偏移已经找不到正确地址了**）
- 存在内存对齐要求
- 成员之间可能有填充字节
- **偏移量需要编译器根据具体平台计算**

所以只能用两种方式访问:

1. 结构体变量`.`成员名
2. 结构体指针`->`成员名

这样编译器才能:

- 正确计算每个成员的偏移量
- 处理内存对齐
- 知道应该读取多少字节
- 按正确的类型解释内存内容

### 结构体数组与指针

```c
#include <stdio.h>

#define book_size 100

typedef struct{
	char id;
	char book_name[20];
	char book_author[20];
	char book_type[20];
	double book_price;
	int book_count;
	int book_star;
}Book;


void test(Book *books,Book books2[book_size]);

int main (){
	Book books[book_size] = {{0,"红楼梦","曹雪芹","古风",99.99,2,9},
		{1,"红楼","曹雪","风",99.9,1,5}
	};
	test(books,books);
	return 0;
}
void test(Book *books,Book books2[book_size]){
	//根据数组的特性，无论传递指针还是数组都会自动退化为指针
	//传递结构体数组副本
	printf("%s\t%d",books2[0].book_name,books2[0].id);
	//传递结构体数组指针
	//数组名也是数组起始地址也是首元素地址（第一个结构体的起始地址）
	printf("%s\t%d",books->book_name,books->id);
	//偏移也和数组一样的原理
	//数组中存的都是结构体，结构体内都是连续地址。
	//+1是偏移一个结构体大小的地址，books+1为第二个结构体的首元素地址即指向结构体的指针我可以直接只用箭头访问
	printf("%s\t%d",(books+1)->book_name,(books+1)->id);
}
```

- **函数参数声明方式的等价性：**

  - ```c
    void test(Book *books, Book books2[book_size])
    ```

  - 这两种声明方式在函数内部实际上是完全等价的，因为数组作为参数总是会衰退为指针。我们甚至可以写成：

  - ```c
    void test(Book *books, Book books2[])  // size可以省略
    ```

- **内存布局的补充说明：**

  - 结构体数组在内存中是连续存放的

  - 每个结构体元素之间可能会有字节对齐
    - 但是每个结构体在数组中的占用空间是相同的（都会字节对齐，所以个体之间相差不大）

  - 可以用 sizeof(Book) 获取单个结构体的大小

- **访问方式的补充：**

  - ```c
    // 以下三种访问方式是等价的
    books[i].book_name    // 数组形式
    (books + i)->book_name  // 指针偏移形式
    (*(books + i)).book_name  // 解引用形式,只能解引用到结构体为止，不能再往下解引用，因为内部进行了字节对齐
    ```

- 指针算术运算的补充：

  - ```c
    books + 1  // 偏移量是 sizeof(Book)，而不是1个字节
    ```

- 传参时的注意事项：

  - ```c
    // 如果想修改原数组内容,传递地址会影响原数组
    void modify_book(Book *books) {
        books[0].book_price = 88.88;  // 会影响原数组
    }
    
    // 如果不想修改原数组
    void read_book(const Book *books) {
        // books[0].book_price = 88.88;  // 编译错误
        printf("%lf", books[0].book_price);  // 只读访问
    }
    ```

#### 普通数组与指针

**这与普通数组不一样，拿到元素地址还是需要解引用来获取里面的值：我知道了，之所以拿到结构体数组元素地址后就可以直接使用箭头访问了，这是结构体指针的单独特性对吗？你要拿到里面的值也行，(*(books + i)).book_name拿到结构体使用.符号访问？**

- 对于普通数组:

  - ```c
    int arr[10] = {1,2,3,4,5,6,7,8,9};
    int *p = arr;
    printf("%d", *p);       // 需要解引用才能获取值
    printf("%d", *(p + 1)); // 偏移后也需要解引用
    ```

- 对于结构体数组:

  - ```c
    Book books[10];
    Book *p = books;
    
    // 以下三种访问方式等价:
    p->book_name           // 箭头运算符直接访问
    (*p).book_name        // 解引用后用点运算符
    (*(books + 1)).book_name  // 偏移后解引用再用点运算符
    ```

- 这种区别的原因是:

  1. 普通数组存储的是直接的值(如整数、字符等)

  2. 结构体数组存储的是一个包含多个成员的复合类型

  3. 箭头运算符 `->` 是专门为结构体指针设计的语法糖,**它自动完成了解引用操作**

  4. 我们可以这样理解:

     1. ```c
        // 这两个表达式完全等价
        p->member
        (*p).member
        ```

  5. ```c
     typedef struct {
         int x;
         int y;
     } Point;
     
     int main() {
         // 普通数组
         int nums[3] = {1, 2, 3};
         int *np = nums;
         printf("%d", *np);        // 必须解引用
         
         // 结构体数组
         Point points[3] = {{1,2}, {3,4}, {5,6}};
         Point *pp = points;
         printf("%d", pp->x);      // 可以直接用箭头访问，是专门为结构体指针设计的语法糖,它自动完成了解引用操作
         printf("%d", (*pp).x);    // 也可以解引用拿到结构体后用点语法访问
         
         // 数组偏移访问
         printf("%d", (pp+1)->x);  // 直接用箭头
         printf("%d", (*(pp+1)).x);// 解引用后用点
         
         return 0;
     }
     ```

### 结构体的输入

```c
// 1. 普通变量 - 需要取地址(&)
int num;
scanf("%d", &num);         // 整数
double price;
scanf("%lf", &price);      // 浮点数
char ch;
scanf("%c", &ch);          // 单个字符

// 2. 普通数组 - 不需要取地址(数组名就是地址)
char str[50];
scanf("%s", str);          // 字符数组
int numbers[5];
scanf("%d", numbers);      // 整型数组首元素
scanf("%d", &numbers[1]);  // 数组其他元素需要&

// 3. 结构体变量 - 成员根据其类型决定
struct Book {
    char name[50];         // 字符数组成员
    int count;             // 整型成员
    double price;          // 浮点数成员
    char type[20];         // 字符数组成员
};
Book book;
scanf("%s", book.name);    // 字符数组成员不需要&
scanf("%d", &book.count);  // 普通变量成员需要&
scanf("%lf", &book.price); // 普通变量成员需要&
scanf("%s", book.type);    // 字符数组成员不需要&

// 4. 结构体数组 - 结合数组和结构体的规则
Book books[100];
scanf("%s", books[0].name);    // 字符数组成员不需要&
scanf("%d", &books[0].count);  // 普通变量成员需要&
scanf("%s", books[1].name);    // 第二本书
scanf("%d", &books[1].count);  // 第二本书
```

简单记忆规则：

1. 如果是指向字符串的变量（字符数组）：不需要&
   - 包括普通字符数组
   - 包括结构体中的字符数组成员
   - 包括结构体数组中的字符数组成员
2. 如果是普通变量：需要&
   - 包括int、double、char等基本类型
   - 包括结构体中的基本类型成员
   - 包括结构体数组中的基本类型成员
3. 复合情况：
   - 结构体变量：按照成员的类型判断是否需要&
   - 结构体数组：按照成员的类型判断是否需要&，同时需要指定数组下标

## **共用体**

### 产生以及意义

共用体（Union）是C语言中的一种特殊数据类型，它的产生背景和意义与特定的编程需求和内存管理效率密切相关。

共用体的产生背景：

1. 内存优化需求： 在早期计算机系统中，内存资源非常宝贵。程序员需要一种方法来有效地利用有限的内存空间。
2. 硬件交互： 在嵌入式系统和底层编程中，**经常需要以不同的方式解释同一块内存区域，以便与硬件寄存器或特定数据格式交互。**
3. 数据复用： 在某些情况下，**一个数据结构可能需要在不同时间表示不同类型的数据，但不会同时使用这些不同类型。**

共用体的意义和用途：

1. 内存节省： **共用体允许多个不同类型的变量共享同一内存空间，从而节省内存。**
2. 数据转换： **可以用于在不同数据类型之间进行快速转换，而无需显式的类型转换操作。**
3. 硬件交互： 在嵌入式系统中，共用体常用于访问硬件寄存器，允许按位、字节或字来访问同一内存位置。
4. 多种数据表示： 允许一个变量在不同情况下有不同的数据表示，适用于需要灵活数据结构的场景。

**通俗一点就是：**

共用体就像一个多选项的单选题：

- 单一选择： 在任何给定时刻，只有一个"选项"（成员）是有效的或有意义的。

- 共享空间： 就像一张答题卡上只有一个位置用来标记答案，共用体中所有成员共享同一块内存空间。

- 互斥性： 选择一个选项会自动使其他选项无效，就像在共用体中给一个成员赋值会覆盖其他成员的值。

- 灵活性： 你可以随时改变你的选择，就像你可以随时改变使用共用体中的哪个成员。

```c
#include <stdio.h>

union SingleChoice {
    int integer_choice;
    float float_choice;
    char char_choice;
};

int main() {
    union SingleChoice choice;//共用体实例化

    // 选择整数选项
    choice.integer_choice = 10;//选中一个成员变量进行初始化
    printf("Integer choice: %d\n", choice.integer_choice);

    // 切换到浮点数选项
    choice.float_choice = 3.14;//选中另外一个成员变量进行初始化，原来那一个内存空间就会被顶替掉
    printf("Float choice: %f\n", choice.float_choice);
    // 此时整数选项已经无效
    printf("Integer choice is now invalid: %d\n", choice.integer_choice);

    // 切换到字符选项
    choice.char_choice = 'A';
    printf("Char choice: %c\n", choice.char_choice);
    // 此时浮点数选项已经无效
    printf("Float choice is now invalid: %f\n", choice.float_choice);

    printf("Size of union: %zu\n", sizeof(choice));

    return 0;
}
```

### 类型描述

```c
union 共用体名
{
数据类型  成员名1;

数据类型 成员名2;
……
}
```

### 嵌套定义

在共用体内直接定义另一个共用体:

```c
union outer {
    int x;
    union inner {
        float y;
        char z;
    } in;// 这里的 in 是外层共用体的成员变量
};

union outer o;
o.x = 10;        // 访问外部共用体的成员
o.in.y = 3.14f;  // 访问内部共用体的成员
o.in.z = 'A';    // 访问内部共用体的另一个成员
```

在共用体内使用之前定义的共用体类型:

```c
union inner {
    float y;
    char z;
};

union outer {
    int x;
    union inner in;// 这里的 in 是外层共用体的成员变量
};

union outer o;
o.x = 10;    // 访问外部共用体的成员
o.in.y = 3.14f;  // 访问内部共用体的成员
o.in.z = 'A';    // 访问内部共用体的另一个成员
```

使用typedef定义共用体类型,然后在另一个共用体中使用:

```c
typedef union {
    float y;
    char z;
} Inner;//共用体类型别名

union outer {
    int x;
    Inner in;//可以省略关键字,// 这里的 in 是外层共用体的成员变量
};

union outer o;
o.x = 10;    // 访问外部共用体的成员
o.in.y = 3.14f;  // 访问内部共用体的成员
o.in.z = 'A';    // 访问内部共用体的另一个成员
```

在共用体内使用匿名共用体:

```c
union outer {
    int x;
    union {
        float y;
        char z;
    };
};

union outer o;
o.x = 10;    // 访问外部共用体的成员
o.y = 3.14f;  // 直接访问内部匿名共用体的成员
o.z = 'A';    // 直接访问内部匿名共用体的另一个成员
```

**在这种情况下，内层共用体是匿名的，没有显式的成员变量名。内层共用体的成员（`y` 和 `z`）会被视为直接属于外层共用体 `outer`。**



#### 结构体与共用体的结合使用

假设我们正在开发一个简单的网络协议解析器，需要**处理不同类型**的网络数据包。

```c
#include <stdio.h>
#include <string.h>

#define MAX_PAYLOAD 1024 //预处理会被替换为1024

// 数据包类型枚举
enum PacketType {
    TCP,
    UDP,
    ICMP
};

// TCP包结构
struct TCPPacket {
    unsigned short src_port;
    unsigned short dest_port;
    unsigned int sequence;
    char payload[MAX_PAYLOAD];
};

// UDP包结构
struct UDPPacket {
    unsigned short src_port;
    unsigned short dest_port;
    unsigned short length;
    char payload[MAX_PAYLOAD];
};

// ICMP包结构
struct ICMPPacket {
    unsigned char type;
    unsigned char code;
    unsigned short checksum;
    char payload[MAX_PAYLOAD];
};

// 通用数据包结构，嵌套使用
struct Packet {
    enum PacketType type;
    union {//数据包只会是其中一种协议
        struct TCPPacket tcp;
        struct UDPPacket udp;
        struct ICMPPacket icmp;
    } data;
};

// 解析数据包函数
void parse_packet(struct Packet *packet) {
    switch(packet->type) {//指针使用箭头访问成员变量
        case TCP:
            printf("TCP Packet:\n");
            printf("  Source Port: %d\n", packet->data.tcp.src_port);
            printf("  Destination Port: %d\n", packet->data.tcp.dest_port);
            printf("  Sequence Number: %u\n", packet->data.tcp.sequence);
            printf("  Payload: %s\n", packet->data.tcp.payload);
            break;
        case UDP:
            printf("UDP Packet:\n");
            printf("  Source Port: %d\n", packet->data.udp.src_port);
            printf("  Destination Port: %d\n", packet->data.udp.dest_port);
            printf("  Length: %d\n", packet->data.udp.length);
            printf("  Payload: %s\n", packet->data.udp.payload);
            break;
        case ICMP:
            printf("ICMP Packet:\n");
            printf("  Type: %d\n", packet->data.icmp.type);
            printf("  Code: %d\n", packet->data.icmp.code);
            printf("  Checksum: %d\n", packet->data.icmp.checksum);
            printf("  Payload: %s\n", packet->data.icmp.payload);
            break;
        default:
            printf("Unknown packet type\n");
    }
}

int main() {
    struct Packet packet;

    // 模拟TCP包
    packet.type = TCP;
    packet.data.tcp.src_port = 12345;
    packet.data.tcp.dest_port = 80;
    packet.data.tcp.sequence = 1000;
    strcpy(packet.data.tcp.payload, "Hello, TCP!");

    parse_packet(&packet);

    // 模拟UDP包
    packet.type = UDP;
    packet.data.udp.src_port = 54321;
    packet.data.udp.dest_port = 53;
    packet.data.udp.length = 100;
    strcpy(packet.data.udp.payload, "Hello, UDP!");

    parse_packet(&packet);

    return 0;
}
```

1. 我们定义了一个枚举 `PacketType` 来表示不同类型的数据包。
2. 为每种数据包类型（TCP、UDP、ICMP）定义了单独的结构体，包含该类型特有的字段。
3. 创建了一个通用的 Packet 结构体，它包含：
   - 一个 `type` 字段，用于指示包的类型。
   - 一个共用体 `data`，可以存储任何一种特定类型的数据包。
4. 共用体允许我们在同一内存位置存储不同类型的数据包，节省内存并提供灵活性。
5. `parse_packet` 函数演示了如何根据包类型解析不同的数据包结构。
6. `struct Packet *packet` 是函数的参数。具体来说：
   - `struct Packet` 表示这是一个 Packet 结构体类型。
   - `*packet` 表示这是一个指向 Packet 结构体的指针。

这种设计的优点是：

- 内存效率：**无论哪种类型的包，都只占用最大包类型的内存空间。**
- 灵活性：可以轻松添加新的包类型，只需扩展枚举和共用体。
- 类型安全：通过 `type` 字段，我们可以安全地访问正确的数据结构。
- 效率：传递指针比传递整个结构体更高效，特别是当结构体较大时。
- 修改能力：通过指针，函数可以直接修改传入的 Packet 结构体的内容。如果传递的是结构体的副本，那么函数内的修改不会影响原始数据。
- 一致性：在C语言中，处理复杂数据结构时常用指针，这保持了代码风格的一致性。

### 定义变量（变量，数组，指针），初始化以及成员引用

举一反三，用法类似。

### 占用内存大小

共用体的大小原则： 共用体的大小通常等于其最大成员的大小。这确保了共用体有足够的空间来容纳任何一个成员。

最大成员决定： 共用体的大小至少要能容纳其最大的成员。

对齐考虑： 实际大小可能会因为内存对齐的要求而略大于最大成员的大小。

编译器差异： 不同的编译器可能有轻微的差异在处理共用体大小的方式上。

### 位域

**产生背景**

- 在C语言中，有时候需要用一个变量存储多个**标志位**或**状态信息**，而每个状态可能只需要1~2位即可。
- 如果每个状态都用一个`int`或`char`变量来存储，浪费了大量内存。因此，**位域（Bit Fields）被引入，用于在结构体中以位为单位**来高效管理数据。

**位域的意义**

- **节省内存**：能有效减少小数据结构的内存占用，比如标志位、状态标记等。
- **增强数据管理的灵活性**：**可以让多个状态共存于一个变量中，更加紧凑。**
  - 状态标记，有一些情况下有很多状态，但是只会有一种状态呈现。

- **提高数据访问效率**：比直接使用数组或多个变量管理标志更直观。

在**嵌入式系统**或**协议解析**中，常需要通过寄存器或数据包的多个字段来控制硬件或解析数据。这时，**结构体和共用体结合使用位域**能帮助**高效管理这些字段**。

**示例：嵌入式设备的寄存器控制**

假设我们有一个嵌入式设备的控制寄存器，它由8位组成，**各个位具有不同的功能**。我们可以通过**共用体**和**结构体的位域**来定义并访问这些位，既能按位操作，也能整体读取寄存器的值。

```c
#include <stdio.h>

// 定义8位寄存器的位域结构体
struct ControlRegister {
    unsigned int enable    : 1;  // 第0位：设备使能标志
    unsigned int mode      : 2;  // 第1-2位：工作模式（0-3）
    unsigned int reserved  : 1;  // 第3位：保留位
    unsigned int interrupt : 1;  // 第4位：中断标志
    unsigned int error     : 1;  // 第5位：错误标志
    unsigned int power     : 2;  // 第6-7位：电源状态（0-3）
};

// 使用共用体来管理寄存器，可以按位或整体操作
union Register {
    struct ControlRegister bits;  // 按位访问
    unsigned char byte;           // 整体访问
};

int main() {
    union Register reg;  // 定义一个寄存器变量

    // 初始化寄存器（整体赋值）
    reg.byte = 0x00;  // 全部置0
    printf("Initial byte: 0x%02X\n", reg.byte);

    // 设置位域：启用设备，使能工作模式1，电源状态为2
    reg.bits.enable = 1;
    reg.bits.mode = 1;
    reg.bits.power = 2;

    // 查看修改后的寄存器值（整体访问）
    printf("Modified byte: 0x%02X\n", reg.byte);

    // 按位访问各个字段
    printf("Enable: %d, Mode: %d, Power: %d\n",
           reg.bits.enable, reg.bits.mode, reg.bits.power);

    return 0;
}
```

1. **结构体位域**：`ControlRegister` 将寄存器的各个位定义为不同的字段，方便按位操作。

   - `enable`：第0位
   - `mode`：第1-2位（两位表示模式）
   - `power`：第6-7位（两位表示电源状态）

2. **共用体**：`Register` 允许使用相同的内存空间，以两种方式访问寄存器：

   - **按位访问**：通过 `bits` 结构体访问寄存器的各个位域字段。
   - **整体访问**：通过 `byte` 访问整个寄存器的8位值。

3. **功能展示**：

   - 初始化寄存器为全0：`reg.byte = 0x00;`
     - 这一步通过**共用体的整体访问方式**，将寄存器的所有 8 位数据全部置为 `0`
     - 确保寄存器的初始状态为全零（无标志位被置位），方便后续的按位设置和操作。
   - 修改位域的值，并查看对应的整体字节值：`0x45`。

4. 为什么能通过共用体将寄存器全部置 0？

   1. 这是因为 **共用体（union）** 允许**所有成员共享同一段内存空间**，无论是按位域访问，还是通过整体字节访问，它们都映射到相同的内存区域。所以，当你将共用体的 `byte` 成员赋值为 `0x00` 时，整个共用体内的所有数据，包括嵌套的结构体位域，都会自动初始化为 0。

   2. ```c
      共用体 Register 内存（8位）：
      ┌────────────────────────────┐
      │   byte = 0x00 (0000 0000)  │
      └────────────────────────────┘
      
      对应的位域结构体映射：
      ┌─────────┬──────────┬──────────┬──────────┐
      │ enable  │  mode    │ reserved │  power   │
      │   0     │   00     │    0     │   00     │
      └─────────┴──────────┴──────────┴──────────┘
      ```

   3. **为什么这样做有意义？**

      - 通过将 `reg.byte` 设为 `0x00`，你可以**快速清除所有标志位**，相当于对所有控制字段进行初始化。
      - 在实际开发中，这种做法很常见，因为它**简化了初始化操作**，不用逐个位域手动赋值。

5. **总结**

   - **共用体整体置 0**：通过 `reg.byte = 0x00;` 将寄存器所有位初始化为 0。
   - **按位访问与设置**：通过 `reg.bits` 结构体逐个位域访问，实现灵活控制。
   - **共用体的优势**：按位域管理寄存器字段的同时，还可以通过共用体直接操作整个寄存器。

   这种模式在**嵌入式开发**中非常常见，比如：

   - 控制 MCU 的 I/O 端口
   - 操作硬件寄存器的标志位
   - 网络协议头字段的解析与操作

### **共用体 vs. 结构体**

| **特性**     | **共用体（union）**    | **结构体（struct）**   |
| ------------ | ---------------------- | ---------------------- |
| **内存分配** | 所有成员共享同一块内存 | 每个成员有独立的内存   |
| **大小**     | 等于最大成员的大小     | 等于所有成员大小之和   |
| **成员使用** | 同时只能使用一个成员   | 所有成员都可同时使用   |
| **用途**     | 节省内存               | 存储多种不同类型的数据 |

## 枚举类型

枚举是C语言中一种用户定义的数据类型，用于定义一组命名的**整型常量**。

**枚举类型**的核心目的正是**通过常量名代替整数值**，让代码更加**清晰可读**，避免记忆和混淆多个相似的数值。

- **枚举的优势：减少混淆，提高可读性**

如果直接使用整数值（如 `0, 1, 2`）表示状态或选项，**含义不直观**，尤其在常量多的时候容易搞混。

使用**枚举常量名**能清晰地表达每个值的含义。例如：

```c
// 没有枚举时的写法
int status = 1;  // 1 表示成功吗？错误吗？

// 使用枚举后的写法
enum Status { SUCCESS = 0, ERROR = 1 };
int status = SUCCESS;  // 代码更直观明了
```

- **编译器处理：常量名替换为整数值**

  - 在**编译阶段**，所有的枚举常量名（如 `SUCCESS`、`ERROR`）都会被**替换成对应的整数值**。也就是说，枚举类型只是帮助开发者理解，最终程序运行时处理的还是整数。

  - ```c
    enum Color {
        RED = 10,
        GREEN = 20,
        BLUE = 30
    };
    
    int main() {
        enum Color c = GREEN;  // 编译器会将 GREEN 替换为 20
        printf("%d\n", c);     // 输出: 20
        return 0;
    }
    ```

    在这段代码中，`GREEN` 实际上在编译后等同于整数 `20`。

- 避免硬编码数值，防止出错

  - 如果直接在代码中**硬编码多个整数**，稍有不慎就会造成逻辑错误。而使用**枚举常量名**不仅减少出错几率，还能让代码在需要时**更容易维护和修改**。

  - ```c
    // 修改状态码，直接改变枚举值即可
    enum Status { SUCCESS = 200, ERROR = 404 };
    相比在代码中多处硬编码数值的情况，使用枚举更容易管理和修改。
    ```

- **总结**

  1. **枚举类型的意义**在于让代码更加清晰可读，避免记忆和使用生硬的整数值。
  2. **编译器处理时**会将枚举常量名替换为整数值，**运行时**依然是使用整数。
  3. **避免硬编码和逻辑混淆**，枚举让程序更易于维护和理解。

  这就是为什么在开发中，特别是**状态管理或多选项的场景**，推荐使用枚举类型。

### **定义枚举类型**

```c
enum DaysOfWeek {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
};
```

在这个定义中：

- `enum` 是关键字，表示这是一个枚举类型。
- `DaysOfWeek` 是枚举类型的名称。
- 大括号内的标识符是枚举常量。

1. 枚举常量的值：

   - **默认情况下，第一个枚举常量的值为0，后续常量的值依次递增。**

   - 你也可以显式地为枚举常量赋值：

   - ```
     enum Colors {
         RED = 1,
         GREEN = 3,
         BLUE = 5
     };
     ```

### 使用枚举类型

```c
enum DaysOfWeek today;//实例化一个DaysOfWeek枚举类型的变量：today
today = WEDNESDAY;//初始化

if (today == WEDNESDAY) {
    printf("It's Wednesday!\n");
}
```

枚举类型的变量可以接受任何整数值，不仅限于定义的常量：

```c
enum DaysOfWeek someDay = 10; // 这是合法的，尽管10不在定义的常量中
```

可以使用 typedef 简化枚举类型的使用：

```c
typedef enum {
    APPLE,
    BANANA,
    ORANGE
} Fruit;

Fruit myFruit = BANANA;
```

在 switch 语句中使用枚举：

```c
Fruit myFruit = APPLE;

switch (myFruit) {
    case APPLE:
        printf("It's an apple\n");
        break;
    case BANANA:
        printf("It's a banana\n");
        break;
    case ORANGE:
        printf("It's an orange\n");
        break;
}
```

使用枚举的优点：

1. 提高代码可读性：**使用命名常量比使用魔法数字更清晰。**
2. 类型安全：编译器可以检查枚举类型的使用是否正确。
3. 便于维护：如果需要修改常量值，只需在枚举定义中修改一处。

枚举在很多场景下都很有用，比如定义状态、选项或类别等。在我们之前讨论的网络包解析器例子中，`PacketType` 就是一个枚举类型，用于区分不同类型的网络包。

### 枚举类型的常量：整数值还是常量名？

在 **C语言** 中，枚举类型 (`enum`) 的常量在**定义时绑定的是整数值**，但在代码中我们通常用**常量名**来访问它们。这些常量名实际上是**符号化的整数常量**，也就是说：

- **枚举名 = 整数值**
- **枚举常量名**只是对应整数值的一个**别名**，**方便代码的可读性。实际上编译器在处理枚举时会把它们转换成对应的整数。**
- 可以直接使用这些枚举常量名作为整数参与运算或比较。
- 在 **`switch` 语句中**，比较的确是通过枚举常量名绑定的整型值进行的。即使你在代码中使用枚举常量名进行比较，编译器实际上比较的是它们对应的整数。

```c
#include <stdio.h>

enum Color {
    RED = 0,
    YELLOW = 1,
    GREEN = 2
};

void checkColor(enum Color color) {
    switch (color) {
        case RED:
            printf("The color is RED\n");
            break;
        case YELLOW:
            printf("The color is YELLOW\n");
            break;
        case GREEN:
            printf("The color is GREEN\n");
            break;
        default:
            printf("Unknown color\n");
    }
}

int main() {
    enum Color c = GREEN;  // 使用常量名赋值
    printf("Color value: %d\n", c);  // 打印整数值
    
    checkColor(c);  // 使用switch语句
    return 0;
}

Color value: 2
The color is GREEN
```

### 作为函数返回值类型

枚举类型也可以作为**函数的返回值类型**。虽然函数返回的本质是一个整数类型，但你**应该用枚举常量名**来表示函数的返回值，以保持代码的可读性和逻辑一致性。

```c
enum Status {
    SUCCESS = 0,
    ERROR = 1
};

enum Status getStatus() {
    // 假设一些逻辑处理
    return SUCCESS;
}

int main() {
    if (getStatus() == SUCCESS) {
        printf("Operation succeeded.\n");
    } else {
        printf("Operation failed.\n");
    }
    return 0;
}
```

尽管 `getStatus()` 返回的是整数 `0` 或 `1`，但我们用枚举常量名 `SUCCESS` 和 `ERROR` 来处理，代码更具可读性。这也是枚举类型设计的初衷。因为你用数字很难理解意思，特别是个数非常多时，用常量名就非常方便了。

### 枚举类型与宏定义的区别

假设我们正在开发一个简单的交通信号灯控制系统。我们可以用枚举来表示信号灯的状态，并与之前使用宏定义或全局常量的方法进行比较。

```c
#include <stdio.h>
#include <time.h>

// 使用宏定义的方式，预处理时会替换为宏体
#define RED_LIGHT 0 //红灯
#define YELLOW_LIGHT 1 //黄灯
#define GREEN_LIGHT 2 //绿灯

// 使用枚举的方式，默认有一个递增值
enum TrafficLight {
    RED,
    YELLOW,
    GREEN
};

// 使用宏定义的函数
void control_traffic_macro(int light) {//你这里是需要传入数字的
    switch(light) {
        case RED_LIGHT://运行时会被替换为0
            printf("Stop! Red light.\n");
            break;
        case YELLOW_LIGHT://运行时会被替换为1
            printf("Caution! Yellow light.\n");
            break;
        case GREEN_LIGHT://运行时会被替换为2
            printf("Go! Green light.\n");
            break;
        default:
            printf("Invalid light state!\n");
    }
}

// 使用枚举的函数
void control_traffic_enum(enum TrafficLight light) {
    switch(light) {
        case RED:
            printf("Stop! Red light.\n");
            break;
        case YELLOW:
            printf("Caution! Yellow light.\n");
            break;
        case GREEN:
            printf("Go! Green light.\n");
            break;
        default:
            printf("Invalid light state!\n");
    }
}

// 性能测试函数
void performance_test() {
    clock_t start, end;
    double cpu_time_used;
    int i;
    const int iterations = 10000000;

    // 测试宏定义方式
    start = clock();
    for (i = 0; i < iterations; i++) {
        control_traffic_macro(i % 3);
    }
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("Time taken using macros: %f seconds\n", cpu_time_used);

    // 测试枚举方式
    start = clock();
    for (i = 0; i < iterations; i++) {
        control_traffic_enum(i % 3);
    }
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("Time taken using enums: %f seconds\n", cpu_time_used);
}

int main() {
    // 使用宏定义
    control_traffic_macro(RED_LIGHT);
    
    // 使用枚举
    control_traffic_enum(RED);

    // 运行性能测试
    performance_test();

    return 0;
}
```

这个例子展示了使用枚举和宏定义两种方式来实现交通信号灯控制系统。让我解释一下为什么在这种情况下枚举可能更高效：

类型安全：

- 使用枚举时，`control_traffic_enum` 函数只接受 `enum TrafficLight` 类型的参数。

  - 枚举类型的变量可以接受任何整数值，不仅限于定义的常量？enum DaysOfWeek someDay = 10; // 这是合法的，尽管10不在定义的常量中？？？

  - 让我来解释一下这个看似矛盾的情况：

    - 类型检查的严格程度：

      - 在函数声明和定义时，使用 `enum TrafficLight` 作为参数类型确实提供了一定程度的类型安全。
      - 编译器会对传入的参数进行类型检查，优先匹配 `enum TrafficLight` 类型的值。

    - 枚举的底层实现：

      - 在 C 语言中，枚举在底层实际上是以整数类型存储的（通常是 int）。
      - 这就是为什么 `enum DaysOfWeek someDay = 10;` 是合法的。

    - 编译器警告：

      - 尽管可以将任意整数赋值给枚举变量，但许多现代编译器会对这种做法发出警告。
      - 这些警告提醒程序员可能存在的类型不匹配问题。

    - 函数参数的行为：

      - **当你声明一个函数的形式参数为特定的枚举类型时**，如 `void control_traffic_enum(enum TrafficLight light)`，**编译器会进行更严格的类型检查。**
      - 如果你尝试传递一个明显不是 `enum TrafficLight` 类型的值（比如一个字符串或浮点数），编译器通常会报错。
      - 但是，由于枚举的整数本质，传递整数值仍然是可能的，尽管可能会触发警告。

    - 类型安全的相对性：

      - 相比于使用 `#define` 宏定义的常量，枚举提供了更好的类型检查。

      - 但这种类型安全并不是绝对的，正如你指出的那样。

      - ```c
        enum TrafficLight {
            RED,   //默认0
            YELLOW,//1
            GREEN//2
        };
        
        void control_traffic_enum(enum TrafficLight light) {
            // 函数实现...
        }
        
        int main() {
            control_traffic_enum(RED);  // 完全正确
            control_traffic_enum(3);    // 合法，但可能触发编译器警告
            control_traffic_enum(3.14); // 可能导致编译错误或严重警告
            
            enum TrafficLight light = 10; // 合法，但可能触发编译器警告
            
            return 0;
        }
        ```

        

- 而 `control_traffic_macro` 函数接受任何整数，这可能导致运行时错误。

调试和可读性：

- 在调试时，枚举值会显示其符号名（如 RED, YELLOW, GREEN），而不是数字。
- 这大大提高了代码的可读性和可维护性。

命名空间管理：

- 枚举常量存在于枚举类型的命名空间中，减少了全局命名空间的污染。
- **宏定义是全局的，可能与其他标识符冲突。**

编译器优化：

- 现代编译器可以对枚举进行优化，特别是在 switch 语句中。
- **编译器可能会将枚举 switch 优化为跳转表，这在某些情况下比使用宏的 if-else 链更高效。**

性能测试：

- 运行 `performance_test()` 函数可以比较两种方法的性能。
- 通常，你会发现两种方法的性能差异很小，甚至可能枚举版本略快。

### 枚举类型的校验效果

使用枚举确实提供了一定程度的参数校验效果，而使用宏定义则通常需要程序员自己进行更多的参数校验（**没有语法检查**）。

使用枚举：

1. 编译时检查：
   - 编译器会对传入的参数进行基本的类型检查。
   - 如果传入的参数明显不是枚举类型（例如，传入一个字符串），编译器会报错。
2. 警告机制：
   - 对于不在枚举定义范围内的整数值，许多现代编译器会发出警告。
   - 这有助于在编译阶段捕获潜在的错误。
3. 代码清晰度：
   - 函数声明明确表明了预期的参数类型，增加了代码的自文档性。
4. 有限的运行时保护：
   - 虽然可以传入枚举范围外的整数，但至少参数类型（整数）是正确的。

使用宏定义：

1. 无编译时类型检查：
   - **宏定义本质上只是文本替换**，**不提供任何类型检查**。
2. 需要手动参数校验：
   - 程序员通常需要在函数内部添加额外的代码来检查参数的有效性。
3. 潜在的类型不匹配风险：
   - 可能会无意中传入完全错误类型的参数，而编译器不会发出警告。
4. 更多的运行时检查负担：
   - 为了确保安全，可能需要在运行时进行更多的参数检查。

```c
#include <stdio.h>

// 使用枚举
enum TrafficLight {
    RED,
    YELLOW,
    GREEN
};

void control_traffic_enum(enum TrafficLight light) {
    switch(light) {
        case RED:
            printf("Stop! Red light.\n");
            break;
        case YELLOW:
            printf("Caution! Yellow light.\n");
            break;
        case GREEN:
            printf("Go! Green light.\n");
            break;
        default:
            printf("Invalid light state (enum)!\n");
    }
}

// 使用宏定义,预处理时会替换为宏体
#define LIGHT_RED 0
#define LIGHT_YELLOW 1
#define LIGHT_GREEN 2

void control_traffic_macro(int light) {
    // 需要手动进行参数校验
    if (light < LIGHT_RED || light > LIGHT_GREEN) {
        printf("Invalid light state (macro)!\n");
        return;
    }

    switch(light) {
        case LIGHT_RED:
            printf("Stop! Red light.\n");
            break;
        case LIGHT_YELLOW:
            printf("Caution! Yellow light.\n");
            break;
        case LIGHT_GREEN:
            printf("Go! Green light.\n");
            break;
    }
}

int main() {
    // 使用枚举
    control_traffic_enum(RED);       // 正确，赋值为枚举类型中的常量
    control_traffic_enum(3);         // 编译器可能警告，运行时会进入 default 分支
    
    // 使用宏定义
    control_traffic_macro(LIGHT_RED);  // 正确，预处理时会替换为宏体即数字
    control_traffic_macro(3);          // 编译通过，但运行时会被判定为无效状态
    
    return 0;
}
```

**枚举类型是不是和宏定义一样？在预处理阶段会替换？**

**宏定义：**

宏定义使用 **`#define`** 来定义符号常量或简单的代码替换。在预处理阶段，**宏**会被替换为它们的具体值或代码。

**特点：**

- 宏在预处理阶段被直接替换。
- 宏没有类型检查，可能会导致一些隐藏的错误（如括号使用不当）。

**枚举类型：**

枚举（`enum`）是C语言中的一种**用户自定义类型**，用于定义一组具有相关性的整型常量。它提供了一个更安全、更结构化的方法来表示常量，而不是使用宏。

**特点：**

- **枚举是编译器在编译阶段处理的，它不会在预处理阶段被替换。**
- 枚举提供了类型检查（枚举变量有明确的类型）。
- 每个枚举常量实际上是一个**整型常量**（默认从 0 开始递增，或者可以手动赋值）。

## 小总结

结构体和共用体因为是定义变量成员，所以用分号

枚举是定义常量列表，所以用逗号

## 函数传参（值传递，指针传递）

在C语言中，无论是**结构体**、**共用体**、还是**枚举类型**，作为参数传递时，选择**值传递**还是**指针传递**主要取决于数据的大小、性能要求和用途。

### **结构体（struct）**

- **值传递**：将结构体的每个字段**复制**一份传递给函数。

  - **优点**：**函数内修改结构体的值不会影响原始结构体（安全性高）。**

  - **缺点**：如果结构体很大，复制会耗费大量内存和CPU时间。

  - ```c
    struct Student {
        char name[20];
        int age;
    };
    
    // 值传递，形参是结构体变量
    void printStudent(struct Student stu) {
        printf("%s, %d\n", stu.name, stu.age);//传递整个结构体的副本，用.访问成员变量
    }
    
    // 调用时：
    struct Student s = {"Tom", 18};
    printStudent(s);    // 直接写变量名
    ```

- **指针传递**：**将结构体的地址传递给函数，而不是复制内容。**

  - **优点**：节省内存和CPU时间，特别适合大型结构体。

  - **缺点**：函数内的修改会影响原始结构体（小心数据污染）。

  - ```c
    // 地址传递，形参是结构体指针
    void printStudent(struct Student *stu) {
        printf("%s, %d\n", stu->name, stu->age);  // 注意这里用箭头->
    }
    
    // 调用时：
    struct Student s = {"Tom", 18};
    printStudent(&s);   // 要加&取地址符号
    ```

- **推荐**：对于大型结构体，使用**指针传递**；对于小型结构体或需要避免数据污染时，使用**值传递**。

  - **当我有一个指向结构体的指针时，我是用解引用时，可以得到结构体吗？就可以使用.成员名访问？**

  - 当你有一个指向结构体的指针时，有两种方式可以访问结构体的成员：

    - 使用解引用 + 点号：括号必须要有，因为点号有优先级

    - ```c
      struct Person {
          int age;
          char name[20];
      };
      
      struct Person *p = &person;
      // 解引用后得到结构体，可以用.访问
      (*p).age = 25;
      (*p).name[0] = 'A';
      ```

    - 使用箭头运算符 ->（更常用）：

    - ```c
      // 箭头运算符是解引用和点号的简化写法
      p->age = 25;    // 等价于 (*p).age
      p->name[0] = 'A';  // 等价于 (*p).name[0]
      ```

    - **解引用的优先级低于点号，所以需要括号：**

    - ```c
      (*p).age;  // 正确
      *p.age;    // 错误！相当于 *(p.age)
      ```

    - 多级指针时也是类似：

    - ```c
      struct node_st **root;  // 二级指针
      
      // 要获取数据需要解引用两次
      (**root).data.id
      // 或先解引用一次，再用箭头
      (*root)->data.id
      ```

  - 小结：

    - 指针解引用后确实可以得到结构体本身，此时可以用点号(.)访问成员
    - 但更常用的是箭头运算符(->)，它是解引用和点号的组合简写
    - 记住解引用的优先级，需要时加括号


### **共用体（union）**

- **共用体的特点**：所有字段共用一段内存，因此大小取决于最大的字段。

- **值传递**：类似结构体，复制一份共用体传递给函数。

  - **适用场景**：当共用体较小时，可以直接值传递。

  - ```c
    union Data {
        int i;
        float f;
    };
    
    void printData(union Data d) {
        printf("int: %d, float: %f\n", d.i, d.f);
    }
    ```

- **指针传递**：将共用体的地址传递给函数。

  - **适用场景**：适用于大型共用体，避免性能开销。

  - ```c
    void printDataByRef(union Data* d) {
        printf("int: %d, float: %f\n", d->i, d->f);
    }
    ```

### **枚举类型（enum）**

- **枚举类型的特点**：枚举本质上是一个**整数**类型，所以值传递和普通整数一样。

- **值传递**：直接传递枚举值，不需要指针传递。

- ```c
  enum Color { RED, GREEN, BLUE };
  
  void printColor(enum Color c) {
      printf("Color: %d\n", c);
  }
  ```

- **指针传递**：很少使用，因为枚举值是一个简单类型，指针传递没有明显优势。**但如果需要修改枚举值，可以使用指针：**

  ```c
  void changeColor(enum Color* c) {
      *c = GREEN;
  }
  ```

  - ```c
    #include <stdio.h>
    
    enum Color { RED, GREEN, BLUE };  // 枚举类型定义
    
    void changeColor(enum Color* c) {
        *c = GREEN;  // 修改指针指向的枚举变量的值
    }
    
    int main() {
        enum Color myColor = RED;  // 定义一个枚举变量，并赋值为 RED
        printf("Before: %d\n", myColor);  // 打印初始值
    
        changeColor(&myColor);  // 传入枚举变量的地址，进行修改,无论传入什么颜色都修改为GREEN
        printf("After: %d\n", myColor);  // 打印修改后的值
    
        return 0;
    }
    ```

    

### **总结**

- **结构体**：小型结构体可以值传递，大型结构体推荐指针传递。
- **共用体**：同结构体处理方式一致，视大小选择值传递或指针传递。
- **枚举类型**：通常使用**值传递**，但在需要修改时可以使用指针传递。

**推荐策略**：

- **小数据结构**：值传递，避免指针的复杂性。
- **大数据结构**：指针传递，节省内存和提高效率。

