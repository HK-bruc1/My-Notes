# C语言三座大山

既然你已经有了Java和Python的基础，学习C语言时可以重点关注以下几个方面，因为它们和之前的语言有较大不同，并且是C语言的核心特性：

**指针和内存管理**：这是C语言最显著的特性之一。C语言允许直接操作内存，通过指针来访问变量的地址。这是与Java和Python最大的不同，后两者有自动内存管理，**而C需要你手动分配和释放内存**。

- 学习 `malloc`、`free`、指针运算和指针数组的用法。

**结构体（structs）**：C语言通过 `struct` 来实现用户定义的数据类型，这一点与Java中的类不同，它更加轻量，没有对象方法等复杂的面向对象概念。

**预处理器和宏定义**：C语言中的预处理器指令（如 `#define`、`#include`）和宏定义提供了一种不同的编程方式，用于常量定义、条件编译等。学习这些能帮助你更好理解C语言的编译过程。

**低级硬件控制**：如果你对嵌入式开发感兴趣，C语言广泛用于直接操控硬件资源，学习如何与硬件寄存器和内存映射设备交互非常重要。

**标准库和文件操作**：虽然Java和Python都有标准库，C语言的标准库函数更贴近底层，特别是 `stdio.h` 和 `stdlib.h` 中的函数，如 `fopen`、`fwrite`、`fread` 等文件操作函数，了解如何处理文件输入输出。

**多线程和并发**：虽然在C语言中多线程编程不像在Java中通过 `Thread` 类那样简单，但可以通过 `pthread` 库实现多线程，这对需要高性能的系统编程很重要。

## 三座大山（数组，指针，函数）

C语言的**数组**、**指针**和**函数**确实被称为“三座大山”，它们不仅是C语言的核心部分，也是理解C语言编程的关键。

###  **数组**

- **数组的基础**：C语言中的数组是一个固定大小的连续内存块，所有元素必须是相同类型。不同于Java和Python的动态数组（如Java的`ArrayList`和Python的`list`），C中的数组大小是固定的，并且必须在声明时指定。
- **内存布局**：数组在内存中的存储是连续的，这与指针紧密相关。你需要理解一维数组和多维数组的内存布局，以及如何通过指针访问数组元素。
- **字符串**：在C中，字符串本质上是字符数组，因此掌握数组的用法也是理解C语言字符串操作的基础。

### **指针**

- **指针的概念**：指针是C语言中最强大但也最难理解的部分。指针存储的是变量的内存地址，这允许程序员直接操作内存。你需要理解指针和数组之间的关系、指针运算、指针的类型（如指向数组的指针、指向函数的指针等）。
- **指针的使用场景**：指针用于动态内存分配、函数参数传递、返回多个值等。在深入理解C语言时，指针几乎无处不在，尤其是在处理复杂数据结构（如链表、树）时，指针是关键工具。

### **函数**

- **函数定义和调用**：C语言的函数类似于Java和Python中的函数，但C中函数的参数传递可以通过值传递或指针（地址）传递。这在处理大数据结构时非常重要，**因为通过指针传递可以避免大量的内存复制**。
- **函数指针**：C语言允许使用函数指针，这种特性非常强大但也比较复杂。它可以用来实现回调函数、动态函数调用和函数表等高级编程技巧。
- **递归和函数栈**：C语言中的递归和函数调用栈机制非常重要，理解递归的执行过程和栈帧管理对于编写高效代码非常有帮助。

### 如何学习这“三座大山”：

- **数组**：从一维数组开始，逐步深入多维数组，理解它们与内存的关系。掌握常用操作，如排序、查找、数组传递给函数等。
- **指针**：先从基础指针语法开始，理解指针与变量、指针与数组的关系，再逐步学习复杂的指针运算（如指向指针的指针、函数指针）。
- **函数**：理解C语言函数的基本用法和递归的原理，尤其是如何通过指针返回多个结果或修改函数外部的变量。然后探索函数指针的应用。

## 数组

### 一维数组

**定义**：

【存储类型】 数据类型  标识符  【下标】 

```c
int arr[M];
```

**初始化**：

​	数组可以不进行初始化，全部初始化，部分初始化,使用static修饰会被全部自动初始化为0

​	按照数组的存放顺序来赋值的：int arr[M] = {1，2，3};

​	除开定义时初始化，

​	数据连续存放：

```c
#include <stdio.h>
#include <stdlib.h>
#define  M   3

int main()
{
	int arr[M];
	for(int i = 0; i < M; i++){
		printf("%p--->%d\n",&arr[i],arr[i]);
	}
	exit(0);
}
结果：一个int占用4个字节，aotu类型不赋值，这一块空间也不会清0或者赋成特殊值
000000c2785ff870--->860033944
000000c2785ff874--->538
000000c2785ff878--->860033936
```



**元素引用**：

​	数组名【下标】

**数组名**：

​	数组名是表示地址的常量，也是数组的起始位置。

**数组越界**：

​	**数组越界**是指访问数组中未分配的内存区域。这种行为在C语言中不会被自动检查，因此可能导致未定义的行为，程序运行时也不会提示错误。这种情况需要程序员自己格外小心。

​	在C语言中，数组元素是通过指针偏移来访问的。当你声明一个数组时，C语言只是分配连续的内存空间，并通过数组的首地址（即数组名）和偏移量来访问具体的元素。例如，`array[i]` 实际上等价于 `*(array + i)`，这意味着在内存中偏移 `i` 个位置。

​	C语言没有自动进行数组边界检查的原因是为了提高效率。执行边界检查需要额外的代码和计算，会降低程序运行速度。而C语言是设计为高效的低级语言，常用于系统编程和嵌入式开发，开发者通常希望能够控制底层内存操作，不希望有额外的开销。

### 二维数组

**定义，初始化**：

​	【存储类型】  数据类型  标识符 【行下标】【列下标】

​	（两行三列）int a[M] [N] = {{1,2,3},{4,5,6}};  按行（存储顺序）来赋值。包括位置。

​	  int a[M] [N] = {{1,3},{4}};部分赋值的话，其他会自动赋值为0或者为空值

```c
1 3 0
4 0 0
int a[M][N] = {1,3,4,6,7}//还是按照行（存储顺序）来
1 3 4
6 7 0
    
//在列数确定的情况下，行号可以省略，因为可以区分开
int a[] [N] = {1,3,4,6,7};
```

**元素引用**：

​	数组名【行标】【列标】

**存储形式**：

​	**是线性顺序存储，先存放行数据再存放列数据，数组名依旧是存放位置的起始位置**

**深入理解二维数组**

​	通过**一维数组**和**二维数组**的指针运算来深入理解它们在内存中的存储和访问方式。

​	对于一维数组来说，数组名是数组第一个元素的地址，`a` 就是指向一维数组第一个元素的指针（地址）。

```c
int a[3] = {1, 2, 3};
printf("%p\n", a);      // 打印数组 a 的起始地址
printf("%p\n", a + 1);  // 打印数组第二个元素的地址
printf("%d\n", *(a + 1));  // 打印数组第二个元素的值 (2)
//在 C 语言中，*(a + 1) 是一个指针解引用运算符，它用于获取某个地址所指向的值.
//直接获取数组的地址不会得到存储在该地址中的值。地址只是一个内存位置的引用，必须通过解引用运算符 * 才能访问该地址存储的数据。
```

**解释**：

- `a` 是数组 `a` 的起始地址，也就是 `&a[0]`。
- `a + 1` 是数组第二个元素的地址（即 `&a[1]`）。
- `*(a + 1)` 则是取出第二个元素的值（即 `2`）。

二维数组可以看成是“**数组的数组**”。二维数组的数组名也是数组起始地址，但它指向的是二维数组的**第一行**。

```c
int b[2][3] = { {1, 2, 3}, {4, 5, 6} };
printf("%p\n", b);      // 打印二维数组的起始地址
printf("%p\n", b + 1);  // 打印第二行的起始地址
printf("%d\n", *(*(b + 1)));  // 取出第二行第一个元素的值 (4)
```

`int b[2][3]` 可以看作是一个大小为 2 的一维数组，而这个数组的每个元素又是一个大小为 3 的一维数组。具体来说：

- `b[0]` 是一个包含 3 个 `int` 元素的一维数组，对应 `{1, 2, 3}`。
- `b[1]` 是另一个包含 3 个 `int` 元素的一维数组，对应 `{4, 5, 6}`。

从这种角度看，`b` 是一个一维数组，存储了两个大小为 3 的一维数组的地址。

**访问方式**:

1. `b[0]` 和 `b[1]` 分别是指向两个一维数组的指针，因此 `b + 1` 是指向**第二个一维数组存放的地址**。
2. `*(b + 1)` 解引用后，是**第二个一维数组的起始地址**（相当于 `b[1]`），即 `{4, 5, 6}` 的地址。
3. `*(*(b + 1))` 解引用后，才是第二个一维数组的第一个元素 `4`。

**内存结构**：看作是一个大小为 2 的一维数组，而这个数组的每个元素又是一个大小为 3 的一维数组

```c
b[0][0]  b[0][1]  b[0][2]  b[1][0]  b[1][1]  b[1][2]
  1        2        3        4        5        6
  b                         b+1  
```

因此，二维数组中的 `b + 1` 是指向**下一行的起始位置**，所以称为“行指针”。

**总结：**

- **一维数组**的数组名 `a` 是第一个元素的指针，`a + 1` 是下一个元素的地址。
- **二维数组**的数组名 `b` 是第一行的指针，`b + 1` 是下一行的地址，也就是行指针。

### 字符数组

#### **定义，初始化，存储特点**

​	字符数组是用于存储一组字符的数组，通常用于表示字符串。

```c
#include <stdio.h>

int main() {
    char str1[6] = {'H', 'e', 'l', 'l', 'o', '\0'};  // 手动定义字符数组并添加结束符
    char str2[] = "Hello";  // 使用字符串字面量定义，自动添加结束符 '\0'，
    
    // 单个字符输出
    for (int i = 0; i < 5; i++) {
        printf("%c", str[i]);  // 正常输出 "Hello"
    }

    printf("str1: %s\n", str1);  // 输出字符串,效果是一样的
    printf("str2: %s\n", str2);// 输出字符串,效果是一样的

    return 0;
}
```

**解释：**

- `char str1[6]` 定义了一个长度为 6 的字符数组，其中第 6 个字符是字符串结束符 `\0`。
- `char str2[]` 使用字符串字面量 `"Hello"` 初始化数组，编译器会自动在末尾加上 `\0`。
- **存储特点**：字符数组是以字符为单位存储的，并且在使用字符串字面量时，系统会自动在结尾加上 `\0` 作为字符串结束标志。
- 在 C 语言中，字符串的处理函数（如 `printf`、`strlen` 等）都是通过**检测 `\0` 来确定字符串的结束**。如果没有这个 `\0`，函数将无法知道字符串在哪里结束，可能会访问数组之外的内存区域，导致**不可预期的行为**或**内存错误**。**必须添加 `\0`**：如果没有 `\0`，字符数组不会被当作字符串处理，导致程序行为不可预期。
- **关键区别**:
  - **字符串输出**：需要 `\0` 结束符，因为字符串处理函数依赖 `\0` 确定字符串结束位置。
  - **单个字符输出**：不需要 `\0` 结束符，单个字符独立输出，只要能读取到字符就能输出，不涉及字符串结束的问题。

#### **输入输出**

字符数组可以通过多种方式进行输入和输出，如 `scanf`、`gets`（不推荐使用）以及 `fgets`。

```c
#include <stdio.h>

int main() {
    char str[50];  // 定义长度为 50 的字符数组

    printf("请输入一个字符串: ");
    // scanf("%s", str);  // 使用 scanf 输入字符数组（不能输入包含空格的字符串）
    fgets(str, sizeof(str), stdin);  // 使用 fgets 安全输入字符数组，可以输入空格
    
    printf("你输入的字符串是: %s", str);  // 输出字符串

    return 0;
}
```

`scanf("%s", str)`：只能读取**不包含空格**的字符串，读取到空格时会停止。

`fgets(str, sizeof(str), stdin)`：**推荐使用 `fgets`**，可以读取**包含空格**的字符串，并且可以防止数组溢出问题。这里指定了最大读取长度 `sizeof(str)`。

输出时，使用 `%s` 格式符打印字符数组。

#### **常用的字符数组操作函数**

字符数组（字符串）的常用函数一般来自 `<string.h>` 头文件，比如 `strlen`、`strcpy`、`strcmp`、`strcat` 等。

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str1[] = "Hello";
    char str2[] = "World";
    char str3[50];  // 定义一个足够大的字符数组

    // 1. strlen: 获取字符串长度
    printf("str1 的长度: %lu\n", strlen(str1));

    // 2. strcpy: 复制字符串
    strcpy(str3, str1);
    printf("str3 复制 str1 的内容: %s\n", str3);

    // 3. strcat: 字符串拼接
    strcat(str3, str2);
    printf("str3 拼接 str2 后的内容: %s\n", str3);

    // 4. strcmp: 字符串比较
    if (strcmp(str1, str2) == 0) {
        printf("str1 和 str2 相等\n");
    } else {
        printf("str1 和 str2 不相等\n");
    }

    return 0;
}
```

- `strlen(str1)`：获取字符串 `str1` 的长度（不包括 `\0`）。
- `strcpy(str3, str1)`：将字符串 `str1` 复制到 `str3` 中。
- `strcat(str3, str2)`：将 `str2` 追加到 `str3` 的末尾。
- `strcmp(str1, str2)`：比较 `str1` 和 `str2` 字符串，返回 0 表示相等，不等则返回负数或正数。

#### 一维字符数组与二维字符数组的形式区别

定义：`char op_names[4] = {'加', '减', '乘', '除'};` [他的另一种写法](####**定义，初始化，存储特点**)

含义：

- 这是一个**一维数组**，里面的每个元素都是一个**字符（char 类型）**。
- 每个元素只能存储一个**单个字符**，而不是字符串。

内存布局：

```c
op_names[0] = '加'
op_names[1] = '减'
op_names[2] = '乘'
op_names[3] = '除'
```

但这里有个问题：在 C 语言中，`'加'`（或其他汉字）**不是合法的单个字符**。C 中的 `char` 只能存储 **ASCII** 字符或 UTF-8 编码中的一部分，**汉字的存储需要多个字节**（[通常用 `wchar_t` 或 `char*` 处理字符串](####函数指针)）。使用字符串字面量初始化字符指针数组    `char *op_names[4] = {"加", "减", "乘", "除"};`

定义：`char op_names[4] [4] = {"加", "减", "乘", "除"};` 使用了字符串字面量会自动补尾0

不使用字符串字面量的定义：

```c
char op_names[4][4] = {
    {'a', '\0', '\0', '\0'},
    {'b', '\0', '\0', '\0'},
    {'c', '\0', '\0', '\0'},
    {'d', '\0', '\0', '\0'}
};
```

含义：

- 这是一个**二维数组**，每一行是一个字符串，且每行最多存储 4 个字符（包括字符串的终止符 `\0`）。
- 用这种形式可以存储多行字符串。

内存布局：

```c
op_names[0] = {'加', '\0', '\0', '\0'}
op_names[1] = {'减', '\0', '\0', '\0'}
op_names[2] = {'乘', '\0', '\0', '\0'}
op_names[3] = {'除', '\0', '\0', '\0'}
```

每一行存储一个字符串，并且用 `\0` 作为字符串的结束标志。

### 多维数组

对于三维数组，`int c[2][3][4]` 表示一个**三维数组**，它包含 2 个二维数组，每个二维数组有 3 行，每行有 4 个元素。

你可以把 `c[2][3][4]` 看成是一个包含 2 个元素的**一维数组**，而其中的每个元素都是一个包含 3 行、每行 4 个 `int` 元素的二维数组。

- `c[0]` 和 `c[1]` 各自是一个包含 3 行 4 列的二维数组。
- 进一步地，`c[0][0]` 是一个包含 4 个 `int` 的一维数组。

```c
#include <stdio.h>

int main() {
    int c[2][3][4] = {//存了两个三行四列的二维数组，按行存储，就是6行，每一行四列
        { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} },
        { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} }
    };

    printf("c[0][2][3] = %d\n", c[0][2][3]);  // 输出 12
    printf("c[1][1][2] = %d\n", c[1][1][2]);  // 输出 19

    return 0;
}
```

`c[0][2][3]` 输出第 0 个二维数组的第 2 行的第 3 列，结果是 12。

`c[1][1][2]` 输出第 1 个二维数组的第 1 行的第 2 列，结果是 19。

**总结：**

- **二维数组**可以看作是一个**存储多个一维数组的数组**，每个元素是一维数组的地址。
- **三维数组**可以看作是一个**存储多个二维数组的数组**，而每个二维数组又是存储多个一维数组的数组。

## 指针

### 变量与地址

```
int i = 1;//定义变量并初始化，存储占4个字节，以补码的形式存到分配的地址中
printf("%d\n",i);//打印i的值：1
printf("%p\n",&i);//打印存放i的值的地址：0000001404dffb0c
```

变量名就是程序员对某一块内存空间的抽象命名，地址是不会变的，关键看与什么变量名关联。

比如公司名与地址名的关系，只要合同没到期，公司名就是就是这个地址名的抽象标识

**变量与内存地址**：`int i = 1;` 定义了一个整型变量 `i`，并在内存中分配了 4 个字节用于存储它的值（在大多数系统上，`int` 通常占用 4 字节）。`&i` 获取的是 `i` 变量在内存中的地址。

**地址的稳定性**：变量的地址在程序运行期间是固定的，除非变量的作用域结束，或者是局部变量在函数调用中被重新分配。变量名是对这个内存地址的一个抽象标识符。

### 指针

指针可以被视为一个变量，它存储了另一个变量的内存地址。具体来说：

- **指针的定义**：指针是一个数据类型，用于**存储某个类型变量的地址**。例如，`int *p;` 定义了一个**指向整型的指针** `p`。

  - `int *p = &i;`并不是把&i赋值给*p, TYPE  NAME = VALUE
  - TYPE是int *,把地址赋值给指针p,TYPE要根据i的类型来指定。

- **指针的大小**：指针的大小通常是固定的，通常为 4 字节（在 32 位系统上）或 8 字节（在 64 位系统上）。**无论指针指向的数据类型是什么，指针本身的大小是相同的。**

- **指针的类型**：

  - 指针前面的类型（如 `int *`、`char *` 等）告诉编译器指针指向的数据类型。这在取值时很重要，因为它影响到如何访问和解释指针所指向的内存内容。

  - 例如，当你使用 `*p` 时，编译器知道 `p` 是指向整型的指针，因此它会根据整型的大小（通常是 4 字节）来读取内存中的数据。

  - **类型不匹配**：

    - ```c
      char *c = &i;
      ```

      这里 `c` 是一个指向 `char` 的指针，它实际上指向一个 `int` 类型的变量 `i`。因为 `int` 通常占用 4 个字节，而 `char` 只占用 1 个字节。

    - **取值时的问题**：当你使用 `*c` 时，实际上你只获取了 `i` 地址处的第一个字节，这可能不是 `i` 的完整值。例如，如果 `i` 的值是 1，它的 4 字节补码表示在内存中可能是 `0x01 0x00 0x00 0x00`（视系统的字节序而定），那么 `*c` 只会返回 `0x01`，而不是 `1`。

- **指向地址的作用**：指针本质上就是一个地址，它可以用来**间接访问**存储在该地址上的值。例如，通过 `*p` 可以访问指针 `p` 指向的地址上的值。

- **动态内存管理**：指针在动态内存分配、数组操作和函数参数传递中非常有用，因为它们允许你直接操作内存地址，而不是仅仅通过值。

指针本身也是一个变量，它存储着另一个变量的地址。**因此，指针也有自己的地址**。具体来说：

1. **指针的地址**：指针变量（如 `p`）在内存中有自己的地址，你可以使用 `&p` 来获取这个地址。
2. **指针内容**：指针中保存的是另一个变量的地址。例如，在 `int *p = &i;` 中，`p` 保存的是变量 `i` 的地址。
3. **总结**：**指针本身有地址，指向的内容是另一个变量的地址**。这种结构允许通过指针间接访问其他变量的值。

### 变量与指针

**变量**：直接保存数据的值。机器为每个变量分配一个内存地址，并在该地址上存储该值。

**指针**：保存另一个变量的内存地址。通过指针运算（如解引用运算符 `*`），你可以访问存储在该地址上的值。

```c
int i = 1;//定义变量并初始化，存储占4个字节，以补码的形式存到分配的地址中
printf("%d\n",i);//打印i的值：1
printf("%p\n",&i);//打印存放i的值的地址：0000001404dffb0c
int	*p = &i;//这个指针指向0000001404dffb0c，通过指针运算可以间接访问此地址中的值
printf("%p\n", &p); // 打印指针 p 本身的地址:000000a23d5ffa80
指向：*p存的是0000001404dffb0c，*p本身也就是有一个存放地址的
```

### 指针与指针变量

int *p

int *p = &i

这大概就是两者的区别吧？

### 二级指针

1. **指针变量**：如果你有一个指针 `int *p;`，它存储了另一个变量（如 `int i;`）的地址。

2. **二级指针**：如果你定义一个指针 `int **n;`，那么 `n` 存储的是指针 `p` 的地址。

   1. **二级指针的定义**：

      - `int **q = &p;` 定义了一个二级指针 `q`，它存储了指针 `p` 的地址。

      **使用 `q`**：

      - 当你使用 `q` 时，它代表这个二级指针本身，即它存储的 `p` 的地址。

      **使用 `*q`**：

      - 使用 `*q` 时，实际上是解引用 `q`，这将得到指针 `p` **的值**（即 `p` 存储的地址）。
      - 如果你进一步使用 `**q`，那将会访问 `p` 指向的地址中的值（也就是变量 `i` 的值）。

3. **关系**：

   - `*p` 存储的地址指向的是变量 `i`。
   - `*n` 将指向 `p` 存储的地址，因此可以通过 `**n` 来访问变量 `i` 的值。

这个概念被称为指针的指针，它可以用于处理更复杂的数据结构。

```c
int i = 1;
int	*p = &i;
int **q = &p;


i---> 1   i的值
&i---> 0000001404dffb0c  存放i的值的地址
p---> 0000001404dffb0c   作为变量在内存分配的地址里存的值，&i
&p---> 000000a23d5ffa80   作为变量本身在内存中的地址
*p---> *（0000001404dffb0c）---> 1  取值：去地址中取值
q---> 000000a23d5ffa80   作为变量在内存分配的地址里存的值，&p
&q---> 000000a23d5ffb85  作为变量本身在内存中的地址
*q---> 0000001404dffb0c  取值：取q在内存分配的地址里存的地址的值 &i
**q---> 1 --->*(&i)      分开步骤来操作,有多层嵌套时可以分开操作。

```

### 直接访问与间接访问

#### 直接访问

- **定义**：直接访问是通过变量名直接获取变量的值。

```c
int i = 1; // 直接访问变量 i
printf("%d\n", i); // 输出 1
```

- **特点**：直接使用变量名，易于理解，效率较高，因为不需要额外的操作。

#### 间接访问

- **定义**：间接访问是通过指针来访问变量的值。你首先通过指针获取变量的地址，然后使用解引用操作符 `*` 获取该地址中的值。

```c
int i = 1;
int *p = &i; // p 存储 i 的地址
printf("%d\n", *p); // 输出 1，通过指针间接访问
```

**特点**：间接访问允许更灵活的内存管理，特别是在处理动态分配内存、传递大数据结构（如数组或结构体）时，避免了复制整个数据的开销。但它需要更多的操作，可能导致更复杂的代码。

#### 总结

- **直接访问**：简单、快速，适合基本操作。
- **间接访问**：灵活、强大，适合更复杂的场景，如动态内存管理和数据结构操作。

### 空指针与野指针

#### 空指针

**定义**：空指针是一个指针变量，它不指向任何有效的内存地址，通常被初始化为 `NULL`。

```c
int *p = NULL; // p 是一个空指针
```

**特点**：使用空指针可以安全地表示“无效”或“未指向任何对象”。在使用空指针之前，检查它是否为 `NULL` 可以防止访问无效内存。

#### 野指针

**定义**：野指针是指一个指针变量，它指向了一个不再有效的内存地址。这个地址可能是之前被释放的内存，或者是未初始化的指针。

```c
int *p; // p 是未初始化的指针，成为野指针
int *q = malloc(sizeof(int)); // 分配内存
free(q); // 释放内存
// 此时 q 变成野指针，因为它指向的内存已经被释放
```

**特点**：使用野指针会导致未定义行为，因为你可能试图访问一个无效的内存区域。野指针常常导致程序崩溃或数据损坏。

#### 总结

- **空指针**：安全、不指向有效地址，可以用来表示“无效”。
- **野指针**：不安全、指向无效地址，容易导致错误。

### 空类型

“空类型的指针”通常指的是 `void *` 指针，这种指针没有具体的数据类型，可以指向任何类型的数据。

`void *` 是一种通用指针类型，表示它可以指向任何类型的数据。它本身不具备特定的类型信息。

- **灵活性**：`void *` 指针常用于需要通用指针的场合，例如在动态内存分配函数（如 `malloc`）中。

- **类型转换**：在使用 `void *` 时，通常需要将其转换为具体的指针类型，以便访问或操作指向的数据。

```c
void *p;
int i = 10;
p = &i; // p 指向整型变量 i
printf("%d\n", *(int *)p); // 将 void * 转换为 int * 后解引用
```

由于 `void *` 指针没有类型信息，因此在使用之前必须进行类型转换，以确保正确访问内存。

### 指针运算

1. **运算符含义**：
   - `&`：取变量的地址。
   - `*`：取指针所指向的地址中的值（解引用）。
2. **指针定义**：
   - 在 `int *p = &i;` 中，`*` 用于定义 `p` 为一个指向整型的指针，这是语法上的约定。
3. **指针的使用**：
   - 当你使用 `p` 时，它表示指针本身，即它所存储的地址。
   - 当你使用 `*p` 时，这个 `*` 就是运算符，它表示取 `p` 指向的地址中的值。

因此，`*` 的含义在不同上下文中是不同的：在定义指针时，它是类型标识符，而在使用时，它是解引用运算符。

### 指针与数组的关系

#### 	指针与一维数组

```c
int arr[3] = {1,2,3};
arr[i]是如何取对应值的位置的：a (数组的起始位置) + i （i个数据类型，这里是int），直接访问
int *p = a; 用指针变量p来存这个数组的起始地址
arr[i]是如何取到值的：p (存的是数组的起始位置) + i （i个数据类型，这里是int）再用*运算符，间接访问
arr[i] = *(a+i) = *（p+i）= p[i]
&arr[i] = arr+i =  p+i = &p[i]  
```

**数组名作为指针**：

- 在表达式 `arr[i]` 中，`arr` 是数组的名字，它实际上代表数组的起始地址。也就是说，`arr` 是指向数组第一个元素的指针。

**数组下标的计算**：

- `arr[i]` 的计算可以展开为 `*(arr + i)`，其中 `arr` 是数组的起始地址，`i` 是偏移量（元素的个数），`*(arr + i)` 通过解引用操作符 `*` 访问数组中第 `i` 个元素的值。

**指针的使用**：

- 当你定义 `int *p = arr;` 时，`p` 也指向数组的起始位置。
- 因此，`*(p + i)` 与 `arr[i]` 是等价的，都是访问数组中第 `i` 个元素。

**表达式的等价性**：

- 你的表达式 

  ```
  arr[i] = *(a + i) = *(p + i) = p[i]
  ```

   可以逐一解释如下：

  - `arr[i]`：直接通过数组下标访问元素。
  - `*(arr + i)`：通过指针运算访问元素（这里 `arr` 是数组的起始地址）。
  - `*(a + i)`：假设 `a` 也是指向数组起始位置的指针，它与 `arr` 相同。
  - `*(p + i)`：通过指针 `p` 访问第 `i` 个元素。
  - `p[i]`：通过数组下标语法访问指针 `p` 指向的元素。
    - 指针可以像数组一样使用下标，这是一种非常有用的特性

##### 指针的下标操作

**等价性**：

- 当你有一个指向数组的指针时，比如 `int *p = arr;`，你可以使用下标语法 `p[i]` 来访问指针所指向的数组元素。实际上，`p[i]` 等价于 `*(p + i)`。

**访问元素**：

- 使用下标操作，可以方便地访问指针指向的内存区域，就像访问数组一样。例如：

- ```c
  int arr[3] = {1, 2, 3};
  int *p = arr; // p 指向 arr 的起始位置
  printf("%d\n", p[1]); // 输出 2
  ```

**灵活性**：

- 这种方式使得指针在操作数组时更加灵活和强大。你可以动态地改变指针的指向，而不需要改变数组的结构

**差异：** 

- 一维数组名是常量，一级指针是变量，**其他在使用上可以等价**
- arr++  —> a = a+1  会报错，因为常量不能出现在左边
- p++ —> 指针就指向数组的第二个元素的地址
- p+1 —> 这一句话p指向不变，只不过要获取p指向的下一个地址

**数组名只是对内存一块空间的抽象**：

- ```c
  int *p = (int [3]){1,2,3};
  int i;
  for(i = 0;i<3;i++)
  	printf("%p--->%d\n",&p[i],p[i]);
  ```

  - 这里使用了复合字面量定义了一个大小为 3 的整型数组，并直接初始化为 `{1, 2, 3}`。这个数组的地址被赋给指针 `p`。

    `p` 现在指向这个数组的起始位置。

  - 在循环中，`&p[i]` 获取的是 `p` 指向的数组第 `i` 个元素的地址。

    `p[i]` 访问的是数组第 `i` 个元素的值。

    每次迭代，程序会输出该元素的地址和对应的值。

- **总结**

  - **数组名的抽象**：你提到的“数组名只是对内存一块空间的抽象”在这里得到了体现，因为通过指针 `p`，你可以灵活地操作这块内存，而不需要明确的数组名。
  - **指针与数组的关系**：这种方式展示了指针与数组之间的紧密关系，允许通过指针来访问和操作数组元素。

#### 	指针与二维数组（重点）

##### 行指针的概念

**行指针和数组指针是同一个概念！**

**数组名的含义**：

- `arr` 是一个指向二维数组第一行的指针，类型为 `int (*)[3]`，表示它指向一个包含 3 个整型元素的一维数组。
- `arr[0]` 和 `*(arr + 0)` 实际上是同一个地址，指向数组的第一行。

**行指针的计算**：

- 当你写 `arr + 1` 时，这实际上是指向数组的第二行。**由于每一行的大小是 3 个整型（12 字节）**，`arr + 1` 将指向数组中第二行的起始地址（即 `arr[1]`）。
- **在这种情况下，`arr + 1` 的类型是 `int (*)[3]`，同样是指向大小为 3 的整型数组的指针**。

例如，对于数组：

```c
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
arr 指向 arr[0]（第一行）。
arr + 1 指向 arr[1]（第二行）。
```

如果你使用行指针，可以通过如下方式访问：

```c
int (*p)[3] = arr; // p 指向第一行
printf("%d\n", p[1][0]); // 访问第二行的第一个元素，输出 4

int *p;
p = arr;//为什么不能这么赋值？
int (*p)[4] = arr; 是正确的，因为：

p 被声明为一个指向"大小为4的整型数组"的指针
arr 作为二维数组名，实际上就是指向第一个内层数组（含3个整数）的指针
所以类型是匹配的
    
int *p; p = arr; 是错误的，因为：
p 是指向单个整数的指针
而 arr 是指向"大小为3的整型数组"的指针
这两个类型不匹配
    
这就像是：
int *p 是"能装单个苹果的篮子"
int (*p)[3] 是"能装3个苹果的篮子"
你不能把"3个苹果的篮子"直接赋值给"单个苹果的篮子"
```

这涉及到了行指针和列指针的区别：

**行指针**：`int (*p)[4]`

```c
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
int (*p)[4] = arr;  // p是行指针
```

特点：

- 每次 `p+1` 会跳过一整行（4个整数）

- 可以用 `p[i][j]` 这样的方式访问元素

- 类型匹配二维数组的本质（指向含4个整数的数组）

- ```c
  p[1][0];      // 访问第2行第1个元素(值为5)
  *(*(p+1)+0);  // 等价形式
  ```

**列指针**：`int *p`

```c
int *p = &arr[0][0];  // p是列指针,这是直接把第一行第一个元素的地址赋值过去了
// 或
int *p = (int *)arr;  // 强制类型转换
```

特点：

- 每次 `p+1` 只跳过一个整数

- 需要手动计算行列偏移

- 可以连续访问所有元素

- ```c
  *(p + 4);     // 访问第2行第1个元素(值为5),一行三个，跳到第四个为第二行第一个
  p[4];         // 等价形式
  ```

###### 行指针与列指针的使用区别

```c
// 使用行指针
int (*p)[4] = arr;
printf("%d\n", p[1][0]);      // 直观地访问第2行第1个元素

// 使用列指针
int *p = &arr[0][0];
printf("%d\n", p[1*4 + 0]);   // 需要手动计算偏移量：行数×列数+列号
```

**内存访问示意图**：

```
内存布局：
1  2  3  4    ← 行指针p指向这里
5  6  7  8    ← p+1指向这里
9  10 11 12   ← p+2指向这里

同样的内存布局，但用列指针看：
1  →  2  →  3  →  4  →  5  →  6 ...   
↑
列指针p指向这里，然后一个个遍历
```

所以：

- 行指针更适合按行操作二维数组
- 列指针更适合连续遍历所有元素
- 它们的本质区别在于指针运算时的步长不同

在定义行指针时，我们必须明确指定一行有多少个元素（也就是列数），这样指针才能正确地按行跳转。

```c
// 例子1：标准的二维数组和行指针
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
int (*p)[4] = arr;   // 必须指定4，表示一行有4个元素
```

这里的 `[4]` 告诉编译器：

1. 每行占用 `4 × sizeof(int)` 字节的空间
2. 当执行 `p+1` 时，需要跳过 `4 × sizeof(int)` 字节

我们可以用不同类型来看这个原理：

```c
// 例子2：不同数据类型的情况
char arr1[3][5];
char (*p1)[5] = arr1;    // p1+1 跳过 5×sizeof(char) = 5字节

double arr2[3][6];
double (*p2)[6] = arr2;  // p2+1 跳过 6×sizeof(double) = 48字节

struct Student {
    int id;
    char name[20];
} class[3][2];
struct Student (*p3)[2] = class;  // p3+1 跳过 2×sizeof(struct Student)
```

实际使用时的内存布局：

```
以 int arr[3][4] 为例：

内存中的排列：
1    2    3    4    │ 一行占用 4×sizeof(int) = 16字节
↑
p 指向这里

5    6    7    8    │
↑
p+1 指向这里 (跳过了16字节)

9    10   11   12   │
↑
p+2 指向这里 (再次跳过16字节)
```

这就是为什么声明行指针时必须正确指定列数的原因：

1. 编译器需要知道每行有多少个元素
2. 这样才能在指针运算时计算出正确的内存偏移量
3. 确保 `p[i][j]` 这样的访问方式能正确找到目标元素

##### 二维数组的抽象

**定义**：

- 二维数组 `int arr[2][3]` 可以看作是一个包含 2 个元素的一维数组，每个元素又是一个大小为 3 的一维数组。

**内存布局**：

- 在内存中，arr是一个连续的内存块，所有元素都是顺序存储的。例如：
  - `arr[0][0]`, `arr[0][1]`, `arr[0][2]` 是第一个一维数组的元素。
  - `arr[1][0]`, `arr[1][1]`, `arr[1][2]` 是第二个一维数组的元素。

**访问方式**：

- 你可以通过数组下标**直接**访问二维数组元素：

  ```c
  arr[1][2] = 5; // 将第二个一维数组的第三个元素赋值为 5
  ```

- 也可以使用**行指针（数组指针）** **间接**来访问二维数组元素：

  ```c
  int (*p)[3] = arr; // p 是指向大小为 3 的整型数组的指针
  printf("%d\n", p[1][2]); // 访问第二个一维数组的第三个元素
  这里 p 是一个指向大小为 3 的整型数组的指针。
  (*p) 表示 p 是一个指针，而 [3] 指明 p 指向的内容是一个有 3 个整型元素的数组
      
  = arr 表示将二维数组 arr 的地址赋给指针 p。由于 arr 本身就是一个指向其第一行的指针，类型是 int (*)[3]（指向含有 3 个整数的一维数组的指针），这使得赋值是合法的。
      
  p[1] 获取的是指向第二个一维数组（arr[1]）的指针。
  p[1][2] 则访问这个数组的第三个元素（arr[1][2]），这将输出对应的值。
      
  为什么这种方式有效？
  因为二维数组在内存中是连续存储的，并且 arr 表示整个数组的地址，arr[i] 表示第 i 行的地址。因此，声明 int (*p)[3] 让 p 指向大小为 3 的数组（也就是二维数组中的每一行），这完全符合二维数组的内存结构。
  
  简化解释：
  
  p 指向一个数组，而这个数组的大小是 3 个 int，这与二维数组 arr[2][3] 中每行的大小一致。
  当你写 p[1][2]，实际上就是在访问 arr[1][2]，因为 p 已经指向了二维数组 arr。
  ```

- `arr[i][j]` 的值是怎么找到的？

`arr` 是一个二维数组，假设它被定义为 `int arr[3][4]`。在内存中，`arr` 的结构可以看作是一个包含 3 个元素的一维数组，每个元素都是一个包含 4 个整型的一维数组。

**arr[2] [3]是怎么找到的？**

**起点：arr**

- `arr` 是指向外层一维数组第一个元素的地址
- 这个外层一维数组有3个元素，每个元素都是一个包含4个整型的内层一维数组

**第一步：arr+2**

- `arr+2` 指向了外层一维数组的第三个元素的地址
- 这里的 `+2` 是按照内层数组的大小进行偏移的，这里类似行指针了，不过以抽象概念来看+2就像在一维数组中第三个元素的地址

**第二步：\*(arr+2)**

- `*(arr+2)` 解引用，拿到了外层数组第三个元素的值，里面存的是一维数组
- 这个值就是内层数组（大小为4的一维数组）的起始地址

**第三步：\*(arr+2)+3**

- `*(arr+2)+3` 在内层数组的起始地址上偏移3个位置
- 得到内层数组第四个元素（索引为3）的地址，索引从0开始的

**最后一步：**  * (*(arr+2)+3)

- `*(*(arr+2)+3)` 再次解引用
- 最终拿到了内层数组第四个元素的值

用图示表达就是：

```c
内存布局：

arr →  [内层数组1] → [0][1][2][3]
       [内层数组2] → [0][1][2][3]
       [内层数组3] → [0][1][2][3]
                           ↑
                     我们要找的元素
                     
索引值:   [0] [1] [2] [3]
arr[0]:   1   2   3   4    // 第1行
arr[1]:   5   6   7   8    // 第2行
arr[2]:   9   10  11  12   // 第3行
                    ↑
                arr[2][3]
arr[2][3]起始指的是第三行第四列元素，因为索引从0开始的
```

所以 `arr[2][3]` 等价于 `*(*(arr+2)+3)`，这两种写法本质上是一样的：

- `arr[2][3]` 是语法糖，更易读
- `*(*(arr+2)+3)` 展示了实际的指针运算过程

**抽象视角**

- **一维数组的数组**：从抽象的角度看，二维数组可以被视作一个包含多个一维数组的结构，这样的视角有助于理解数据的组织方式。
- **灵活性**：通过这种抽象，你可以在需要时轻松地将二维数组转换为一维数组进行处理，从而实现更灵活的内存操作。
- arr本质是一个地址常量以外，在使用上更贴近一个指向行的指针

##### 用二级指针来间接访问二维数组

使用二级指针 (`int **pp`) 来访问二维数组时，`pp` 是**指向指针的指针**，**每个指针再指向一个一维数组（行）**。这种方式与使用行指针的方式不同，因为**行指针直接指向二维数组的每一行，而二级指针涉及更多间接层次。**

总结：

- 你使用的方式是**数组指针**（行指针），它通过指向二维数组的行来间接访问元素。
- 二级指针 (`int **`) 则是通过指针指向指针来实现多维数组的访问。
- **数组指针和二级指针**都能实现对二维数组的间接访问，但它们的内存模型和使用方式不同。

使用二级指针来访问二维数组，涉及多个指针的嵌套。我们先动态分配内存来模拟二维数组。

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 动态创建 2 行 3 列的二维数组
    int **arr = (int **)malloc(2 * sizeof(int *));  // 二级指针，指向指针数组(指针类型的数组)
    for (int i = 0; i < 2; i++) {
        arr[i] = (int *)malloc(3 * sizeof(int));    // 每行分配 3 个 int 的空间
    }

    // 初始化二维数组
    arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3;
    arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6;

    // 用二级指针访问二维数组
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            printf("arr[%d][%d] = %d\n", i, j, arr[i][j]);
        }
    }

    // 释放动态分配的内存
    for (int i = 0; i < 2; i++) {
        free(arr[i]);
    }
    free(arr);

    return 0;
}
```

**解释：**

- `int **arr` 是一个二级指针，表示它指向一个指针数组。
- 通过 `malloc`，我们为 `arr` 分配了 2 个 `int*`，每个 `int*` 再指向一行（3 个 `int`）。
- 访问时，`arr[i][j]` 相当于 `*(arr[i] + j)`，表示对二维数组中第 `i` 行第 `j` 列的元素进行访问。

**内存布局**：

- `arr` 是一个指向指针的指针，每个指针指向一维数组（即每行）。

**二级指针 vs 数组指针**：

1. **内存模型**：
   - **二级指针**：`int **arr` 需要动态分配内存，并且每次访问时，先通过 `arr[i]` 找到指针，再通过 `arr[i][j]` 访问具体元素。每一行的内存位置可能是不连续的。
   - **数组指针**：`int (*p)[3]` 直接指向数组的每一行，数组在内存中是连续存储的，所以通过数组指针直接访问数组中的元素，性能会更高。
2. **访问方式**：
   - **二级指针**：`arr[i][j]` 实际上是先通过 `arr[i]` 找到第 `i` 行的指针，再通过 `arr[i][j]` 访问具体元素。
   - **数组指针**：`p[i][j]` 是直接访问二维数组中的元素。
3. **使用场景**：
   - **二级指针**：常用于动态分配多维数组的场景，可以灵活改变行和列的大小，适合在运行时决定数组大小的应用。
   - **数组指针**：适用于固定大小的二维数组，使用静态内存分配，适合性能要求较高的场景。

#### 	指针与字符数组

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    // 字符指针指向字符串常量区
    char *str = "hello";
    // 字符数组在栈上分配内存
    char stri[] = "hello";
    
    printf("str  的大小和长度: %lu %lu\n", sizeof(str), strlen(str));
    printf("stri 的大小和长度: %lu %lu\n", sizeof(stri), strlen(stri));
    
    // 这里会导致段错误
    // strcpy(str, "world");  // 错误：试图修改只读内存
    可以把指针直接指向“world”，但是hello依旧在字符串常量区，只是没引用
    所以要分清楚操作的是什么东西
    str = "world"; 
    
    // 这个是允许的
    strcpy(stri, "world");    // 正确：修改栈上的内存
    
    puts(stri);
    puts(str);
    
    return 0;
}
```

主要区别在于：

1. 内存位置不同：
   - `char *str = "hello"` 中的 "hello" 存储在常量区（只读内存）
   - `char stri[] = "hello"` 在栈上创建了一个数组，内容可以修改
2. sizeof 的结果不同：
   - `sizeof(str)` 返回指针的大小（通常是4或8字节）
   - `sizeof(stri)` 返回数组的实际大小（这里是6字节，包括结尾的'\0'）
3. 可修改性：
   - `str` 指向的是只读内存，不能修改其内容
   - `stri` 是在栈上的数组，可以自由修改

当你试图执行 `strcpy(str,"world")` 时会发生段错误，因为：

- 这相当于试图修改只读内存
- 字符串常量是不可修改的

### const与指针

#### 改变指针的值和指向的区别

```c
int a = 1;          // 假设a的地址是0x123123
int b = 5;          // 假设b的地址是0x7987866
int *p = &a;        // p存储的是0x123123

// 情况1：改变指针的指向
p = &b;             // p现在存储0x7987866
                    // p指向从a变成了b

// 情况2：修改指针指向的值
*p = 2;             // 因为p现在指向b，所以b的值被改成2
                    // p的值（存储的地址）没变，还是0x7987866
记住：

指针的指向 = 指针自己存储的地址值
指针指向的值 = 那个地址上存储的数据
```

 const关键字主要用于以下几个场景:

- 常量定义 - 最基础的用法:

```c
//用宏定义常量，不会检查语法，只是在预处理阶段进行与宏体的替换
用变量来保存一个常量值，会有被修改的风险
const int MAX_SIZE = 100; // 用const把变量常量化了，
int const a = 100;// 等价写法
```

- 和指针结合时有三种情况:

```c
// 1. 指向常量的指针 (两种等价写法)
const int* p 或 int const* p
// 不能通过指针修改值，但可以改变指针指向:
const int* p = &a;
*p = 2;             // 错误！
p = &b;             // 允许！

// 2. 常量指针
int* const p
// 可以修改指向的值，但不能改变指针指向:
int* const p = &a;
*p = 2;             // 允许！
p = &b;             // 错误！

// 3. 指向常量的常量指针,用法则的话，一左一右就是
const int* const p 或写作: int const* const p4 = &value;
// 既不能修改值，也不能改变指向:
const int* const p = &a;
*p = 2;             // 错误！
p = &b;             // 错误！

const的位置规则是：
const 关键字如果在 * 的左边，表示指针指向的值为常量
const 关键字如果在 * 的右边，表示指针本身为常量
为了帮助记忆，可以按照这个规则：
从右往左读
遇到 const 就加上"常量"这个词
遇到 * 就加上"指针"这个词
    
```

- 在库函数开发中，const和指针经常一起使用的原因:

  - 保护数据安全 比如字符串处理函数:

  - ```c
    size_t strlen(const char* str);
    ```

使用const确保**函数内部不会修改原字符串**。

1. 提高代码可读性 通过const清楚地表明函数的意图 - 这个参数是只读的。
2. 编译器优化 const让编译器能进行更多优化。
3. 接口设计
4. 限制对外的访问权限

```c
// 一个结构体例子
struct Student {
    char name[50];
    int age;
};

// 只读方式访问学生信息
void printStudent(const struct Student* stu) {
    printf("Name: %s\n", stu->name);
    printf("Age: %d\n", stu->age);
}
```

在这些场景中使用const + 指针的好处:

- 节省内存(**传递指针而不是整个对象的副本**)
- 保护数据(防止意外修改)
- 明确接口契约(告诉使用者这个数据是只读的)

这就是为什么在实际开发中，特别是封装库函数时，我们经常看到const和指针一起使用。它们的组合既保证了效率，又提供了安全保障。

#### 值传递和指针传递

```c
// 值传递的例子
void func1(int x) {
    x = 100;    // 修改的是副本，原值不变
}

// 指针传递的例子
void func2(int* x) {
    *x = 100;   // 修改的是原值
}

int main() {
    int a = 1;
    func1(a);   // a还是1
    func2(&a);  // a变成100
}
```

字符串处理函数的情况：

```c
// 这是在传递指针！不是值传递
size_t strlen(const char* str) {
    // str是指针，通过它可以访问原始字符串
    // const保护原字符串不被修改
}

int main() {
    char s[] = "hello";
    strlen(s);  // s传递的是地址，不是副本
}
```

让我们看一个对比示例：

```c
// 1. 真正的值传递 - 整个数组内容被复制
void func1(char str[5]) {
    // 这里的str实际上还是指针！
    // C语言中数组作为参数会退化为指针
}

// 2. 指针传递 - 只传递地址
void func2(const char* str) {
    // str指向原始字符串
    // const保护原始数据
}

int main() {
    char s[] = "hello";
    
    func1(s); // 看起来是值传递，实际上传递的是指针
    func2(s); // 明确的指针传递
}
```

关键点：

1. C语言中，当数组作为函数参数时，实际上会自动转换为指针

2. strlen(const char* str)中：

   - 传递的是字符串的地址（指针）
   - 不是字符串的副本
   - `const` 的作用是防止通过这个指针修改原始数据

3. ```c
   size_t strlen(const char* str) {
       int len = 0;
       while(str[len] != '\0') {
           // str[len] = 'x';  // 有const，这行会编译错误
           len++;
       }
       return len;
   }
   这样设计的原因：
   
   效率：避免复制整个字符串（特别是长字符串时）
   安全：通过const保护原始数据
   实用：大多数字符串处理函数只需要读取，不需要修改原字符串
   ```

   如果真要做值传递（完整复制），需要手动实现,实际上C语言的数组参数传递都会转换为指针传递，而不是真正的值传递。

   **总结：**

   1. C语言中所有参数传递**本质上都是值传递**
   2. 我们常说的"指针传递"实际上是**传递地址值**
   3. 指针传递之所以能修改原始数据，**是因为通过复制的地址值可以找到原始数据**
   4. 无论是值传递还是指针传递，**形参都是实参的副本**，区别在于：
      - **值传递复制的是数据值**
      - **指针传递复制的是地址值(这个能找到原始数据而已)**

### 指针数组与数组指针

数组指针：【存储类型】 数据类型 （*指针名） 【下标】 = 值

**数组指针（行指针）**: `int (*p)[4]`

数组指针是数组中的指针，抽象概念来看，一跳就跳一个一维数组（一行）

```c
 int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
int (*p)[4] = arr;  // p是一个指针，指向大小为4的数组

// 特点：
- "是一个指针"
- 指向一个数组
- 内存中只占用一个指针的空间（通常8字节）
```

**指针数组**: `int *p[4]`

指针类型的**数组**，**数组里面存的都是指针**

```c
int a = 1, b = 2, c = 3, d = 4;
int *p[4] = {&a, &b, &c, &d};  // p是一个数组，每个元素都是指针

// 特点：
- "是一个数组"
- 数组的每个元素都是指针
- "内存中占用 4个指针的空间（通常32字节）"
```

**从声明上理解区别**：

```c
int (*p)[4];    // 括号先与*结合：p是一个指针，指向一个int[4]数组
int *p[4];      // 方括号先与p结合：p是一个数组，有4个int*类型的元素
```

**使用方式的区别**：

```c
// 数组指针的使用
int arr[3][4];
int (*p)[4] = arr;
p[0][0];     // 访问第一行第一个元素
(p+1)[0];    // 访问第二行第一个元素

// 指针数组的使用
int a=1, b=2, c=3, d=4;
int *p[4] = {&a, &b, &c, &d};
*p[0];       // 访问第一个指针指向的值
*p[1];       // 访问第二个指针指向的值
```

主要区别总结：

1. 本质不同：
   - 数组指针是一个指针
   - 指针数组是一个数组
2. 内存占用：
   - 数组指针占用一个指针的空间
   - 指针数组占用多个指针的空间
3. 用途不同：
   - 数组指针常用于处理二维数组
   - 指针数组常用于管理多个指针（如字符串数组）
4. 声明解析：
   - `int (*p)[n]`：p是指向n个整型的数组的指针
   - `int *p[n]`：p是有n个整型指针的数组

### 指针数组与二级指针的关系

指针数组并不等同于[二级指针](###二级指针)，虽然它们有一些相似之处。

- 指针数组`int *p[4]`：表示一个包含 4 个元素的数组，每个元素都是指向 `int`类型的指针。简单来说，这是一个“指针的数组”。
  - 例子：`p[0]`, `p[1]` 等元素分别指向不同的 `int` 变量。
- 二级指针：`int **p` 表示**一个**指向指针的指针。它可以用来指向一个指针数组的首元素，或者用来处理指针指向的多维数组。
  - 例子：`*p` 是一个指针，它指向另一个指针（也可以是指向 `int` 的指针）。

**区别**：

- 指针数组是**多个指针的集合**，而二级指针是一个**指向指针的单一指针**。
- 指针数组可以用来存储多个指针，而二级指针常用于动态管理二维数组或间接访问多个指针。

### 多级指针(画一下内存图就没那么抽象了)

[二级指针传送门](###二级指针)多级指针确实在一些特定场景下很常用。

- 二级指针最常见的应用场景：

- ```c
  // 场景1: 在函数中修改指针的指向
  void allocateMemory(int** ptr) {
      *ptr = (int*)malloc(sizeof(int));  // 修改指针的指向
      **ptr = 100;                       // 修改指针指向的值
  }
  
  int main() {
      int* p = NULL;
      allocateMemory(&p);  // 传入指针的地址
      printf("%d\n", *p);  // 输出100
      free(p);
      return 0;
  }
  
  // 场景2: 字符串数组的处理
  void sortStrings(char** arr, int n) {
      // arr[i]是字符串的首地址(char*)
      // arr是指向字符串指针的指针(char**)
      for(int i = 0; i < n-1; i++) {
          for(int j = 0; j < n-i-1; j++) {
              if(strcmp(arr[j], arr[j+1]) > 0) {
                  // 交换字符串指针
                  char* temp = arr[j];
                  arr[j] = arr[j+1];
                  arr[j+1] = temp;
              }
          }
      }
  }
  
  int main() {
      char* names[] = {"Tom", "Jerry", "Spike"};
      sortStrings(names, 3);
      // names现在是按字母顺序排序的
  }
  ```

- 三级指针的应用场景：

- ```c
  // 场景: 动态二维数组的创建和管理
  void create2DArray(int*** arr, int rows, int cols) {
      // 分配行指针数组
      *arr = (int**)malloc(rows * sizeof(int*));
      
      // 分配每行的空间
      for(int i = 0; i < rows; i++) {
          (*arr)[i] = (int*)malloc(cols * sizeof(int));
      }
  }
  
  void free2DArray(int*** arr, int rows) {
      // 释放每行
      for(int i = 0; i < rows; i++) {
          free((*arr)[i]);
      }
      // 释放行指针数组
      free(*arr);
      *arr = NULL;  // 避免悬空指针
  }
  
  int main() {
      int** matrix = NULL;
      int rows = 3, cols = 4;
      
      // 创建二维数组
      create2DArray(&matrix, rows, cols);
      
      // 使用二维数组
      matrix[0][0] = 1;
      
      // 释放内存
      free2DArray(&matrix, rows);
      return 0;
  }
  ```

- 实际值的访问方式：

- ```c
  int value = 42;
  int* p = &value;     // 一级指针,
  int** pp = &p;       // 二级指针
  int*** ppp = &pp;    // 三级指针
  
  // 不同方式访问value
  printf("%d\n", value);    // 直接访问
  printf("%d\n", *p);       // 通过一级指针
  printf("%d\n", **pp);     // 通过二级指针
  printf("%d\n", ***ppp);   // 通过三级指针
  ```

  多级指针的使用建议：

  1. 除非必要，尽量不使用超过二级的指针
  2. 二级指针常用于：
     - 需要在函数中修改指针指向时
     - 处理字符串数组或类似的指针数组
  3. 三级指针主要用于：
     - 动态管理二维数组
     - 需要在函数中修改二级指针时

  使用多级指针时的注意事项：

  1. 每一级指针都要正确初始化
  2. 注意内存泄漏，特别是多维数组的释放
  3. 使用前进行NULL检查
  4. 命名要清晰，表明指针的用途

## 函数

### 函数的定义

返回值数据类型 函数名  （【数据类型  形式参数名，数据类型  形式参数名，……】）

定义的形参在函数调用完后会释放。

在C语言中，主调函数与被调函数的位置关系以及声明确实有一些重要的注意事项。

```c
// 1. 被调函数在主调函数之前 - 直接可用
int add(int a, int b) {
    return a + b;
}

int main() {    // 主调函数
    int sum = add(1, 2);  // 正常调用
    return 0;
}

// 2. 被调函数在主调函数之后 - 需要前向声明
int main() {    // 主调函数
    int sum = add(1, 2);  // 错误！除非前面有声明
    return 0;
}

int add(int a, int b) {  // 被调函数
    return a + b;
}
```

正确的做法 - 使用函数原型声明：

```c
// 方式1：在文件开头声明
int add(int a, int b);    // 函数原型声明（注意分号）

int main() {
    int sum = add(1, 2);  // 现在可以使用了
    return 0;
}

int add(int a, int b) {   // 函数定义
    return a + b;
}

// 方式2：使用头文件（函数声明和定义都分开了，程序入口用include包含就可以）
// mymath.h
#ifndef MYMATH_H
#define MYMATH_H

int add(int a, int b);    // 函数声明
int subtract(int a, int b);

#endif

// mymath.c
#include "mymath.h"

int add(int a, int b) {   // 函数定义
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

// main.c
#include "mymath.h"

int main() {
    int sum = add(1, 2);
    return 0;
}
```

函数声明的注意事项：

```c
// 1. 参数名可以省略，但类型必须保留
int add(int, int);         // 合法
int add(int x, int y);     // 合法
int add();                 // 错误！与定义不符

// 2. 返回类型必须一致
int add(int a, int b);     // 声明
double add(int a, int b)   // 错误！返回类型不一致
{
    return a + b;
}

// 3. static函数只在当前文件可见
static int helper(int x);   // 其他文件不能调用

// 4. 同一个函数不能重复定义，但可以重复声明
int add(int a, int b);     // 第一次声明
int add(int x, int y);     // 重复声明，合法
```

多文件项目的组织：

```c
// 1. 头文件 operations.h
#ifndef OPERATIONS_H
#define OPERATIONS_H

// 函数声明
int add(int a, int b);
int subtract(int a, int b);
void printResult(int result);

#endif

// 2. 实现文件 operations.c
#include "operations.h"
#include <stdio.h>

// 函数定义
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

void printResult(int result) {
    printf("Result: %d\n", result);
}

// 3. 主程序文件 main.c
#include "operations.h"

int main() {
    int result = add(10, 5);
    printResult(result);
    return 0;
}
```

常见错误及解决：

```c
// 错误1：没有声明就使用
int main() {
    foo();      // 错误！未声明就使用
}
void foo() { }

// 解决：添加声明
void foo();    // 声明
int main() {
    foo();     // 现在正确了
}
void foo() { }

// 错误2：声明和定义不匹配
int calc(int);     // 声明一个参数
int calc(int, int) // 错误！定义与声明不匹配
{
    return 0;
}

// 错误3：头文件没有防止重复包含
// 解决：使用include guard
#ifndef HEADER_H
#define HEADER_H
// 头文件内容
#endif
```

最佳实践建议：

1. 把函数声明放在头文件中
2. 把函数定义放在源文件中
3. 使用include guard防止头文件重复包含
4. 保持声明和定义的一致性
5. 在头文件中仅包含必要的声明
6. 函数声明时注意参数类型的完整性

这样组织代码的好处：

- 提高代码可维护性
- 便于团队协作
- 减少编译错误
- 提高代码重用性

### 函数的传参方式

[值传递和指针传递传送门](####值传递和指针传递)

值传递和地址传递的区别：

```c
// 1. 值传递版本的swap - 无法完成交换
void swap_value(int x, int y) {
    int temp = x;     // temp = 1
    x = y;           // x = 2
    y = temp;        // y = 1
    // 交换的是副本，原始值不受影响
}

// 2. 指针传递版本的swap - 可以完成交换
void swap_pointer(int* px, int* py) {
    int temp = *px;    // temp = 1
    *px = *py;        // *px = 2
    *py = temp;       // *py = 1
    // 通过地址修改原始值
}

int main() {
    int a = 1, b = 2;
    printf("交换前：a = %d, b = %d\n", a, b);

    // 值传递尝试交换
    swap_value(a, b);
    printf("值传递后：a = %d, b = %d\n", a, b);  // a=1, b=2 没变

    // 指针传递尝试交换
    swap_pointer(&a, &b);
    printf("指针传递后：a = %d, b = %d\n", a, b);  // a=2, b=1 成功交换
    
    return 0;
}
```

区别说明：

1. 值传递版本失败原因：

- swap_value函数得到的x和y是a和b的副本
- 在函数内部交换x和y不影响原始的a和b
- 函数结束后，修改的副本被销毁

1. 指针传递版本成功原因：

- swap_pointer函数得到的是a和b的地址
- 通过地址可以访问并修改原始变量
- 函数结束后，原始值已经被交换

这个swap函数的例子很好地说明了：

- 值传递只能操作副本，无法修改原值
- **指针传递虽然指针本身是副本**(复制了一份地址)，但可以通过地址修改原值

### 函数的调用

#### 嵌套调用

为了程序的高复用性，一般一个功能都用一个函数实现，那么大函数可能由多个小功能汇合而成，所以很容易形成嵌套调用的情况

#### 递归调用

一个函数直接或者间接的嵌套自身，相当于嵌套的特例。面试常考，生产环境用的很谨慎。

```c
#include <stdio.h>

// 递归函数：计算斐波那契数列的第n个数
int fibonacci(int n) {
    // 1. 基本情况（递归终止条件）递归出口
    if (n <= 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    
    // 2. 递归情况：F(n) = F(n-1) + F(n-2)
    return fibonacci(n-1) + fibonacci(n-2);
}

int main() {
    int n = 7;
    printf("计算斐波那契数列的前 %d 个数：\n", n);
    
    for (int i = 0; i < n; i++) {
        printf("F(%d) = %d\n", i, fibonacci(i));
    }
    
    return 0;
}
```

递归函数的几个重要注意点：

**递归终止条件**：

- 这是最重要的部分，每个递归函数必须有明确的终止条件
- 在这个例子中，当 n <= 0 或 n == 1 时会返回具体值

**递归步骤**：

- 每次递归调用都会把问题变得更小
- fibonacci(n) 被分解为 fibonacci(n-1) 和 fibonacci(n-2)

**调用栈**：

- 每次递归调用都会占用新的栈空间
- 如果递归层次太深，可能会导致栈溢出
- 比如计算 fibonacci(50) 就会非常慢，因为会有大量重复计算
- 递归本身并不一定导致重复计算，问题的特性才是决定是否有重复计算的关键。
- **是否出现大量重复计算** 取决于递归的结构。如果递归的每一步都调用了相同的子问题，并且这些子问题没有缓存，那么重复计算就会发生。



### 函数与数组（指针形式和原始数组形式）

在C语言中，数组作为函数参数时有一些特殊的注意事项。数组与普通变量传参方式不同，以下是总结与用例说明：

**数组传参时的注意事项**

1. **数组名作为指针传递**： 当数组作为参数传递给函数时，实际上传递的是指向数组首元素的指针（地址），而不是整个数组的副本。也就是说，函数对数组元素的修改会影响到原数组（相当于地址传递了）。
2. **数组大小信息不会自动传递**： 由于数组名仅仅是指针，**函数无法通过数组参数本身知道数组的大小**。因此，如果函数需要知道数组的大小，通常需要显式地传递数组的长度。（仅仅把数组名传过去，用sizeof也只是指针的大小8个字节）
3. **数组作为函数参数的声明**： 虽然函数的参数列表中可以**写作 `int arr[]`，但它本质上与 `int *arr` 是等价的**。它们都表示传递的是指针。（数组名本身就是元素起始地址）
4. **数组传递的是地址**： 由于传递的是指针，因此对数组元素的修改会直接反映到调用函数的实际数组上。这与传递普通变量不同，普通变量在函数中传递的是值的副本，不会影响原变量。

#### 传递一维数组

```c
#include <stdio.h>

// 方式1：传统数组形式（其实会自动转为指针），因为数组名就是起始地址嘛
void method1(int arr[], int size) {
    printf("方式1中数组大小: %lu\n", sizeof(arr));  // 将输出指针的大小，按照前面的结论是没办法看到数组的大小的
    for(int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// 方式2：指针形式
void method2(int* arr, int size) {
    for(int i = 0; i < size; i++) {
        printf("%d ", *(arr + i));  // 使用指针算术
    }
    printf("\n");
}

// 展示数组作为参数时的特性，这里有函数调用的嵌套
void demonstrateArrayProperties(void) {
    int original[5] = {1, 2, 3, 4, 5};
    
    printf("在main函数中数组大小: %lu\n", sizeof(original));  // 将输出数组实际大小
    
    method1(original, 5);
    method2(original, 5);
}

// 常见实际应用：数组元素求和
int arraySum(int* arr, int size) {
    int sum = 0;
    for(int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}

// 常见实际应用：原地修改数组元素，想要修改数组元素的话，必须是指针传递
void doubleElements(int* arr, int size) {
    for(int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    
    printf("原始数组: ");
    for(int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n\n");
    
    printf("=== 数组属性演示 ===\n");
    demonstrateArrayProperties();
    printf("\n");
    
    printf("=== 实际应用示例 ===\n");
    printf("数组元素和: %d\n", arraySum(arr, 5));
    
    doubleElements(arr, 5);
    printf("将所有元素翻倍后: ");
    for(int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```

- 数组形式传参

- ```c
  void function(int arr[], int size)
  ```

- 特点：

  - 看起来是数组，但实际上编译器会自动转换为指针
  - 无法通过 sizeof(arr) 获取数组实际大小
  - 更直观，容易理解

  使用场景：

  - 当你想明确表示这是一个数组时
  - 代码可读性要求高的场合

- 指针形式传参

- ```c
  void function(int* arr, int size)
  ```

- 特点：

  - 直接表明这是一个指针
  - 功能上与数组形式完全相同
  - 可以使用指针算术运算（可以修改原始值）

  - 使用场景：
    - 需要强调指针操作的场合
    - 需要进行指针运算的场合

- 重要注意点：

  1. 数组退化

     - 无论使用哪种方式，一维数组作为参数传递时都会退化为指针
     - 在函数内部无法获知原数组的实际大小
     - 必须额外传递数组大小参数
     - **传递整个数组会导致大量数据复制，而传递指针只需要复制一个地址。**

  2. **最佳实践**

     - 总是传递数组大小作为参数

     - 在函数内进行边界检查

     - 如果数组不会被修改，考虑添加 const 限定符

     - ```c
       void readOnlyFunction(const int* arr, int size);
       ```

  3. **选择建议**

     - 如果主要进行数组索引操作，使用数组形式（`int arr[]`）
     - 如果需要指针运算，使用指针形式（`int* arr`）
     - 如果数据不应被修改，使用 const 指针形式（`const int* arr`）

#### 传递二维数组（重点且比较复杂）

```c
#include <stdio.h>
#include <stdlib.h>

// 方式1：指定数组大小（列数必须明确指定）
void method1(int arr[3][4], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

// 方式2：行可变，列固定的数组指针(这不就是行指针嘛？)
void method2(int (*arr)[4], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

// 方式3：使用双指针（完全动态的二维数组）行和列都是动态的没有固定，自由度高
void method3(int **arr, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

// 方式4：将二维数组当作一维数组处理，不过自己手动计算偏移值
void method4(int *arr, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i * cols + j]);
        }
        printf("\n");
    }
}

int main() {
    // 1. 静态声明的二维数组
    int array1[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    // 2. 动态分配的二维数组（使用双指针）比较麻烦
    int **array2 = (int **)malloc(3 * sizeof(int *));
    for (int i = 0; i < 3; i++) {
        array2[i] = (int *)malloc(4 * sizeof(int));
        for (int j = 0; j < 4; j++) {
            array2[i][j] = i * 4 + j + 1;
        }
    }

    printf("方式1 - 指定大小的数组：\n");
    method1(array1, 3, 4);
    
    printf("\n方式2 - 数组指针：\n");
    method2(array1, 3, 4);
    
    printf("\n方式3 - 双指针：\n");
    method3(array2, 3, 4);
    
    printf("\n方式4 - 一维数组形式：\n");
    method4((int *)array1, 3, 4);

    // 释放动态分配的内存
    for (int i = 0; i < 3; i++) {
        free(array2[i]);
    }
    free(array2);

    return 0;
}
```

让我们详细分析每种传参方式的特点和使用场景：

**方式1：指定数组大小**

- 语法：`void function(int arr[3][4], int rows, int cols)`
- 特点：
  - 需要明确指定列数
  - 最接近原始二维数组的使用方式
  - 代码直观，易于理解
- 适用场景：
  - 处理固定大小的二维数组
  - 列数确定的情况

**方式2：数组指针**

- 语法：`void function(int (*arr)[4], int rows, int cols)`
- 特点：
  - 行数可以变化，列数必须固定
  - 内存连续，访问效率高
- 适用场景：
  - 需要处理不同行数但列数固定的数组
  - 对内存性能要求较高的场景

**方式3：双指针(重点)**

- 语法：`void function(int **arr, int rows, int cols)`
- 特点：
  - 完全灵活的行数和列数
  - 可以处理动态分配的二维数组
  - 内存不一定连续
- 适用场景：
  - 处理动态分配的二维数组
  - 需要在运行时确定数组大小
  - 需要不规则的二维数组（每行列数可能不同）

**方式4：一维数组** 

- 语法：`void function(int *arr, int rows, int cols)`
- 特点：
  - 将二维数组当作一维数组处理
  - 内存连续，访问效率最高
  - 需要手动计算下标
- 适用场景：
  - 追求最高的性能
  - 进行矩阵运算等需要频繁访问数组元素的场景
- 公式的推导过程：

**内存布局原理**：

- C语言中，二维数组在内存中实际上是按行主序连续存储的
- 例如一个3×4的数组实际是连续的12个元素

**下标转换推导**： 假设有一个数组 `arr[3][4]`：

```c
第0行: arr[0][0] arr[0][1] arr[0][2] arr[0][3]  // 内存位置：0,1,2,3
第1行: arr[1][0] arr[1][1] arr[1][2] arr[1][3]  // 内存位置：4,5,6,7
第2行: arr[2][0] arr[2][1] arr[2][2] arr[2][3]  // 内存位置：8,9,10,11
```

**公式解析**：`index = i * cols + j`

`i`：当前行号

`cols`：总列数

`j`：当前列号

**计算示例**：

- 访问 arr[1] [2]时：因为是按行线性存储的，按存储位置抽象成一维数组的话， `arr[1][2]`相当于是第二行第三个元素，它前面一共有多少个元素呢？（下标从0开始）：前面有一行（4个元素），自己这一行是第三个元素，相当于一维数组的第七个元素也就是下标6
  - i = 1, cols = 4, j = 2
  - index = 1 * 4 + 2 = 6
  - 所以 `arr[1][2]` 等价于一维数组的 `arr[6]`

**一些重要注意点：**

1. 在选择传参方式时，需要考虑：
   - 数组大小是否固定
   - 是否需要动态分配
   - 性能要求
   - 代码可读性要求
2. 内存管理：
   - 使用动态分配（方式3）时，记得及时释放内存
   - 注意避免内存泄漏和数组越界
3. 性能考虑：
   - 方式4（一维数组）通常性能最好
   - 方式3（双指针）由于内存不连续，可能性能较差

#### 传递字符数组

```c
#include <stdio.h>
#include <stdlib.h>

char *mystrcpy(char *dest,const char *src){
	//从右向左看*在const的右边：不能通过指针修改值，但可以改变指针指向
	//这个做法就是要保证不改变原字符串
	char *ret = dest;//指针传递起始地址在下面会变所以那个临时变量存一下
	if(dest != NULL && src != NULL);//对传进来的参数进行校验,定义时指针是带*的，使用时直接用变量名
		while((*dest++ = *src++)!='\0');//依次把地址中的值取出来赋值给对应的地址中的位置，地址向后移动
	return ret;
	
}

char *mystrncpy(char *dest,const char *src,size_t n){
	int i;
	//数组名和一级指针是等价的
	for(i=0;i<n && (dest[i] = src[i]);i++);
	//自己补充结束符
	dest[i] = '\0';
	return dest;
}

int main(){
	char str1[] = "helloworld";
	char str2[128];
	//mystrcpy(str2,str1);
	//puts(str2);
	mystrncpy(str2,str1,5);
	puts(str2);
	exit(0);
}
```

### 函数与指针

#### 指针函数(函数的返回值是指针)

返回值  *  函数名  （形参）；

```c
#include <stdio.h>
#include <stdlib.h>

// 定义一个指针函数
int* createNumber(int value) {
    int* ptr = (int*)malloc(sizeof(int));  // 分配一个int大小的内存起始地址
    *ptr = value;  // 将值存储在分配的内存中，把值存放到地址中
    return ptr;  // 返回指向这个值的指针，返回值在内存中的存放地址即指针指向的地址（指针里的值）
}

int main() {
    int* result = createNumber(42);
    printf("在内存中的地址是: %p\n", result);
    printf("创建的数字是: %d\n", *result);
    free(result);  // 释放内存
    return 0;
}
```

#### 函数指针

- 函数指针是一种**指向函数的指针**。它**存储函数的地址**，允许我们**间接地调用函数**。

- 在**C语言**中，**函数名本质上就是指向该函数的地址**。因此，你可以将函数名赋值给**函数指针**，并通过该指针来调用函数。这是一种非常强大的功能，广泛用于回调函数和动态函数调用。

函数指针的定义：**返回类型 (*指针名)(参数列表);** `int (*pFunc)(int, int);`

这定义了一个名为 pFunc 的函数指针，它指向一个接受两个 int 参数并返回 int 的函数。

```c
#include <stdio.h>

// 两个简单的函数
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }

int main() {
    // 声明一个函数指针
    int (*operation)(int, int);
    
    // 使用函数指针调用函数(间接调用)，
    operation = add;//把函数的地址赋给指针
    printf("10 + 5 = %d\n", operation(10, 5));
    
    operation = subtract;
    printf("10 - 5 = %d\n", operation(10, 5));
    
    return 0;
}
```

函数指针的主要应用场景包括：

1. 回调函数：
   - 在事件驱动编程中，可以**将函数作为参数传递给其他函数**。
   - 例如，在图形用户界面编程中，可以为按钮点击事件设置回调函数。
2. 算法策略：
   - 允许在运行时选择不同的算法实现。
   - 比如，可以轻松切换不同的排序算法。
3. 状态机：
   - 在实现状态机时，可以**用函数指针数组表示不同状态下的行为**。
4. 插件系统：
   - 在设计插件架构时，可以使用函数指针来动态加载和执行插件功能。
5. 简化代码结构：
   - **可以减少重复代码，提高代码的灵活性和可维护性。**
   - 减少重复看不出来，可维护性提升不少
6. 实现多态：
   - 在 C 语言中模拟面向对象编程中的多态性。

使用**函数指针数组**实现简单的计算器：

```c
#include <stdio.h>

double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) { return b != 0 ? a / b : 0; }

int main() {
    double (*operations[])(double, double) = {add, subtract, multiply, divide};//这写法第一次见
    //字符指针数组
    char *op_names[] = {"加", "减", "乘", "除"};
    //char op_names1[] = {'加', '减', '乘', '除'};用一维字符数组也行，但是有一些很细节的差别
    //char op_names[4] [4] = {"加", "减", "乘", "除"};这种更好，因为汉字不等于单个字符
    int choice;
    double a, b;

    printf("请选择操作：0-加，1-减，2-乘，3-除\n");
    scanf("%d", &choice);//输入的值会赋值给choice
    printf("请输入两个数：\n");
    scanf("%lf %lf", &a, &b);

    if (choice >= 0 && choice < 4) {
        printf("结果：%.2f\n", operations[choice](a, b));
        printf("您进行了%s法运算\n", op_names[choice]);
    } else {
        printf("无效的选择\n");
    }

    return 0;
}
```

- 函数指针数组：`double (*operations[])(double, double) = {add, subtract, multiply, divide};`

优势： 

a) 灵活性：可以存储不同的函数，只要它们具有相同的签名（参数类型和返回类型）。 **很重要的条件**

b) 运行时多态：可以在运行时动态选择要执行的函数。 

c) 代码复用：避免了使用大量 if-else 或 switch 语句。 

d) 可扩展性：轻松添加新的操作，只需定义新函数并将其加入数组。

如果使用普通数组，你可能需要这样做：

```c
double results[4];
results[0] = add(a, b);
results[1] = subtract(a, b);
results[2] = multiply(a, b);
results[3] = divide(a, b);

// 使用时
double result = results[choice];
这种方法需要预先计算所有结果，即使只需要其中一个。而函数指针数组允许你只在需要时调用特定函数。
```

- 字符串数组：`char *op_names[] = {"加", "减", "乘", "除"};`

优势： a) 数据和逻辑分离：操作名称与实际操作逻辑分开存储。 b) 易于国际化：可以轻松切换到其他语言版本的操作名称。 c) 集中管理：所有操作名称在一处定义，便于修改和维护。

如果不使用字符串数组，你可能会这样做：

```c
switch(choice) {
    case 0: printf("您进行了加法运算\n"); break;
    case 1: printf("您进行了减法运算\n"); break;
    case 2: printf("您进行了乘法运算\n"); break;
    case 3: printf("您进行了除法运算\n"); break;
}
```

这种方法使得修改或添加新操作名称变得繁琐，也增加了代码重复。

结合使用这两种数组的优势：

1. 代码简洁性：可以用很少的代码处理多种操作。
2. 可维护性：添加新操作只需在两个数组中各添加一个元素。
3. 灵活性：可以轻松重排操作顺序或添加/删除操作。
4. 性能：避免了复杂的条件判断，直接通过索引访问函数和名称。

添加新操作变得非常简单：

```c
double power(double a, double b) { return pow(a, b); }

// 只需要修改这两行
double (*operations[])(double, double) = {add, subtract, multiply, divide, power};
char *op_names[] = {"加", "减", "乘", "除", "幂"};

// 主循环逻辑不需要改变,可维护性强
```

这种方法特别适合于需要频繁修改或扩展功能的场景，如插件系统、命令处理器等。它提供了一种优雅且可扩展的方式来组织和管理相关的函数和它们的描述。

#### 函数名与数组名的区别

**函数名和数组名在 C 语言中的行为非常相似**，它们本质上都代表**内存地址**，不过也有一些细微的区别。

**函数名和数组名的相似性**

1. **都代表地址：**

   - **数组名**表示数组的首地址，即第一个元素的地址。

   - **函数名**表示该函数的入口地址。

   - ```c
     int arr[3] = {1, 2, 3};
     int *p = arr;  // 数组名是首地址
     
     void say_hello();
     void (*func_ptr)() = say_hello;  // 函数名是地址
     ```

2. **都可以用作指针赋值：**

   - 数组名可以赋值给**指向数组元素的指针**。
   - 函数名可以赋值给**函数指针**。

   **访问方式：**

   - 对于数组，你可以使用指针访问元素，如 `*(arr + 1)`。
   - 对于函数，你可以使用函数指针来j间接调用，如 `func_ptr()`。

**函数名和数组名的区别**

1. **数组名是一个常量指针，但函数名不是**：

   - 虽然数组名是**首地址**，但它**不可更改**，无法赋值给其他指针。

   - 函数名虽然表示地址，但你可以自由将其赋值给不同的**函数指针**。

   - ```c
     int arr[3] = {1, 2, 3};
     arr = arr + 1;  // 错误，数组名是常量，常量不能出现在赋值的左边
     
     void say_hello();
     void (*func_ptr)() = say_hello;  // 合法，函数名可以赋值给指针
     ```

2. **数组可以按索引访问，但函数不行：**

   - 数组可以通过 `arr[i]` 的方式访问元素。
   - 函数只能通过函数指针调用，如 `func_ptr()`，不支持按索引访问。

   **存储位置不同**：

   - **数组**的数据存储在内存的**数据段**或**堆栈**中。
   - **函数**的代码存储在**代码段**中。

#### 函数指针数组

- 函数指针数组的定义格式如下:

```c
返回类型 (*数组名[数组大小])(参数列表);
int (*func_ptr_arr[5])(int, int);
```

这定义了一个包含5个函数指针的数组,每个函数指针指向一个接受两个int参数并返回int的函数。

- 函数指针数组在以下场景中特别有用:

a) 实现函数分发表或命令模式: 当您有多个相似的函数,并且需要根据某些条件选择其中一个执行时。(不用写那么多，if,else语句，不用写switch,case语句)

b) 回调函数数组: 在事件驱动编程中,可以存储多个回调函数。

c) 有限状态机: 每个函数代表一个状态,通过数组可以方便地切换状态。

d) 菜单驱动的程序: 每个函数对应一个菜单项的操作。

- 注意事项:

a) 类型匹配: 确保数组中的所有函数指针具有相同的签名(返回类型和参数列表)。

b) 数组大小: 在定义时明确指定数组大小,或者让编译器根据初始化推断大小。

c) 初始化: 可以在定义时初始化,也可以稍后赋值。

d) 空指针检查: 在调用函数之前,检查指针是否为NULL以避免运行时错误。

e) 可读性: 使用typedef可以提高代码的可读性。

```c
#include <stdio.h>

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

int main() {
    int (*operations[3])(int, int) = {add, subtract, multiply};//指针指向三个函数的地址
    //int (*operation)(int, int);
    int result;
    
    for (int i = 0; i < 3; i++) {
        result = operations[i](10, 5);//输入两个参数，分别做加减乘运算
        printf("Operation %d result: %d\n", i, result);
    }
    
    // 使用加法函数,单个函数指针
    operation = add;
    result = operation(10, 5);
    printf("Addition result: %d\n", result);
    
    // 切换到减法函数,单个函数指针
    operation = subtract;
    result = operation(10, 5);
    printf("Subtraction result: %d\n", result);
    
    // 切换到乘法函数,单个函数指针
    operation = multiply;
    result = operation(10, 5);
    printf("Multiplication result: %d\n", result);
    
    return 0;
}
```

#### 指向指针函数的函数指针数组

定义格式：

```c
返回值类型* (*数组名[数组大小])(参数列表);
假设我们有一个返回 int 指针的函数指针数组：
int* (*func_ptr_arr[5])(int, int);
这定义了一个包含 5 个函数指针的数组，每个函数指针指向一个接受两个 int 参数并"返回 int 指针"的函数。
```

让我们看一个具体的例子来说明这个概念：

```c
#include <stdio.h>
#include <stdlib.h>

// 函数返回一个指向两个整数和的指针
int* add(int a, int b) {
    int* result = (int*)malloc(sizeof(int));
    *result = a + b;
    return result;
}

// 函数返回一个指向两个整数差的指针
int* subtract(int a, int b) {
    int* result = (int*)malloc(sizeof(int));
    *result = a - b;
    return result;
}

int main() {
    // 定义一个指向指针函数的函数指针数组
    int* (*operations[2])(int, int) = {add, subtract};
    
    int a = 10, b = 5;
    
    for (int i = 0; i < 2; i++) {
        int* result = operations[i](a, b);//返回的值指针（地址），需要一个指针变量接收
        printf("Operation %d result: %d\n", i, *result);
        free(result);  // 不要忘记释放内存，当我们使用 malloc 分配内存后，这块内存就会一直存在，直到我们显式地释放它
    }
    
    return 0;
}
```

