# C语言学习记录5之常用的数据结构

![image-20241018112618099](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录5之必要的数据结构.assets\image-20241018112618099.png)

## 顺序存储实现静态链表（数组）

### 生产环境的常规使用

在生产环境中，使用**带头节点的静态链表**较为常见，主要是因为带头节点（也称哨兵节点或虚拟节点）能带来以下好处：

**统一了空表和非空表的操作：**

- 无头节点时，空表head为-1，需要特殊处理
- 有头节点时，永远可以从头节点开始操作

**统一了第一个节点和其他节点的插入操作：**

- 无头节点时，插入第一个位置需要修改head
- 有头节点时，所有插入都是修改next指针
  - 插入到第一个有效节点前面也只需要修改头节点和新节点的next即可


**简化了代码结构：**

- 无头节点的代码需要很多if-else判断
- 有头节点的代码逻辑更统一，更少分支

**有头节点时的优势：**

- 代码更简洁、更容易维护
- 减少了特殊情况的处理
- 降低了出错的可能性

#### [带头节点的实现](##带头结点的静态链表分析（经过验证的）)

当我们写 `*e = L->node[p].data` 时：

1. `L->node[p].data` 是一个 int 类型值

2. `e` 是一个 int* 类型（指向int的指针）

3. `*e` 是解引用操作，代表这个指针指向的内存位置的值

4. 所以 `*e = L->node[p].data` 是在将一个int值赋给另一个int值

5. ```c
   int main() {
       StaticLinkedList list;
       initList(&list);
       
       // 插入一些数据
       insertAfter(&list, 0, 10);  // 插入值10
       
       int value;  // 用于存储获取的值
       if (getValue(&list, 1, &value)) {  // 传入value的地址
           printf("获取的值为：%d\n", value);  // value现在是10
       }
       
       return 0;
   }
   value 是一个int变量
   &value 获取value的地址，类型是 int*
   将这个地址传给getValue函数的参数 e
   在getValue函数中，*e = L->node[p].data 将数据写入到value的内存位置
   ```

   

这个实现包含了以下几个关键特点：

1. 使用头节点（下标0）简化操作
2. 维护了一个备用链表（free）来管理空闲空间

主要的设计考虑：

1. 使用头节点简化了边界情况的处理
2. 通过备用链表实现了内存的动态分配和回收
3. 每个操作都包含了必要的错误检查

使用这个静态链表时需要注意：

1. 插入操作是在指定位置之后插入(**任意后插法所有节点统一操作不需要区分情况**)
2. 为了统一序号编号从0开始（0是头节点）
3. 删除操作也是删除指定位置之后的元素（**任意后删法所有节点统一操作不需要区分情况**）

### 静态链表的实现思路（无头结点）

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAXSIZE 100    // 静态链表的最大长度

// 静态链表节点结构
typedef struct {
    int data;           // 数据域
    int next;           // 游标(下一个元素的数组下标)
} StaticListNode;

// 静态链表结构
typedef struct {
    StaticListNode node[MAXSIZE];  // 节点数组
    int head;                      // 头节点的位置
    int length;                    // 当前链表长度
    int free;                      // 空闲链表的第一个位置
} StaticList;

// 初始化静态链表
void initList(StaticList* list) {
    list->length = 0;
    list->head = -1;  // -1表示空链表
    
    // 初始化空闲链表
    for (int i = 0; i < MAXSIZE - 1; i++) {
        list->node[i].next = i + 1;
    }
    list->node[MAXSIZE - 1].next = -1;  // 最后一个节点的next为-1
    list->free = 0;  // 空闲链表头指针为0，不带头节点所有数组位置都拿来当作有效节点
}

// 分配空闲节点，只操作空闲链表
int mallocNode(StaticList* list) {
    int i = list->free;
    if (list->free != -1) {//空闲链表不为空，更新空闲链表的free指向
        list->free = list->node[i].next;
    }
    return i;
}

// 回收节点，这个函数专门操作空闲链表的，更新有效链表则由其他函数完成
void freeNode(StaticList* list, int k) {
    //让被释放节点指向当前空闲链表的第一个节点
	//采用头插法将节点插入空闲链表，操作简单且效率高，
    list->node[k].next = list->free;
    //让空闲链表的头指向被释放的节点
    list->free = k;
}

// 在指定位置插入元素(位置从0开始)
//将位置参数改为从0开始计数,这样更符合计算机思维和数组使用习惯。
bool insertList(StaticList* list, int i, int data) {
    // 位置检查改为从0开始
    if (i < 0 || i > list->length || list->free == -1) {
        return false;
    }
    
    //取空闲节点数组下标位置
    int newNode = mallocNode(list);
    list->node[newNode].data = data;
    
    // 插入到链表头部(位置0)第一个节点用头插法
    if (i == 0) {
        list->node[newNode].next = list->head;
        list->head = newNode;
    } else {
        // 找到第i-1个节点，在第i个位置插入，要找到i的前驱节点（第i-1个节点）
        int k = list->head;//从头部开始遍历 
        //从第0个节点到第i-1个节点需要跳转i-1次
        for (int j = 0; j < i - 1; j++) {  // 循环次数调整，后自增，如果有等号就会多跳转一次：i次
            k = list->node[k].next;
        }
        // 插入新节点
        //必须先设置新节点的next，再修改前驱节点的next
	   //如果顺序反过来，会丢失后继节点的位置
        list->node[newNode].next = list->node[k].next;
        list->node[k].next = newNode;
    }
    list->length++;
    return true;
}

// 删除指定位置的元素(位置从0开始)
bool deleteList(StaticList* list, int i, int* data) {
    if (i < 0 || i >= list->length) {  // 边界检查修改，序号最大到length-1，跟数组最大下标类似
        return false;
    }
    
    if (i == 0) {  // 删除头部节点：第一个有效节点
        *data = list->node[list->head].data;//这是解引用，是赋值操作
        int temp = list->head;//获取到头部节点的数组下标
        list->head = list->node[list->head].next;//更新head指向新的头部节点
        freeNode(list, temp);//将旧的头部节点释放回空闲链表
    } else {
        int k = list->head;//其他位置就要遍历到指定位置
        //还是要先找到第i个位置的前驱节点
        for (int j = 0; j < i - 1; j++) {  // 循环次数调整
            k = list->node[k].next;
        }
        int temp = list->node[k].next;
        *data = list->node[temp].data;
        list->node[k].next = list->node[temp].next;//前驱节点指向删除节点的next(相当于跳过删除节点)
        freeNode(list, temp);
    }
    list->length--;
    return true;
}

// 获取指定位置的元素(位置从0开始)
bool getElem(StaticList* list, int i, int* data) {
    if (i < 0 || i >= list->length) {  // 边界检查修改
        return false;
    }
    
    int k = list->head;
    //从第0个节点开始找到第i个节点，需要跳转i次
    for (int j = 0; j < i; j++) {  // 循环次数调整
        k = list->node[k].next;
    }
    *data = list->node[k].data;
    return true;
}

// 使用示例
int main() {
    StaticList list;
    initList(&list);
    
    // 插入测试
    insertList(&list, 0, 10);  // 10        位置0
    insertList(&list, 1, 20);  // 10 20     位置1
    insertList(&list, 0, 30);  // 30 10 20  位置0
    insertList(&list, 1, 40);  // 30 40 10 20 位置1
    
    printf("After insertion:\n");
    printList(&list);
    
    // 删除测试
    int deleted;
    deleteList(&list, 1, &deleted);  // 删除位置1的元素
    printf("\nDeleted element at position 1: %d\n", deleted);
    printf("After deletion:\n");
    printList(&list);
    
    // 获取元素测试
    int element;
    if (getElem(&list, 1, &element)) {  // 获取位置1的元素
        printf("\nElement at position 1: %d\n", element);
    }
    
    return 0;
}
```

**插入顺序很关键**：

- 先连后面(新节点指向后继)
- 再连前面(前驱指向新节点)
- 这个顺序可以避免断链

**边界情况**：

- 在头部插入时特殊处理(i == 0)
- 在尾部插入时next指向-1
- 注意空间是否已满(free == -1)

#### 头尾节点下标的设计

在静态链表中，我们使用**-1**来表示**空指针**（即无效位置或链表结束）。因为数组的下标是从0开始，没有实际的`-1`下标，所以它只是一种**标志符**，用于表示链表的结束或节点为空。换句话说，`-1`不会占用数组空间。

**空指针概念**：

- 在传统链表中使用`NULL`表示指针不指向任何节点。
- 在静态链表中，我们用`-1`来模拟这个逻辑，表示**链表结束**或**节点不存在**。

**头节点和尾节点处理**：

- 当`head == -1`时，表示链表是**空的**。
- 在遍历链表时，如果某个节点的`next == -1`，表示该节点是**最后一个节点**。

**数组与指针模拟的关系**：

- 假设你有一个静态链表长度为`MAX_SIZE = 100`，数组下标范围为`0~99`。
- 所有指向`-1`的地方，只是一个标志，不对应实际的数组位置。

```c
list.head = 2; // 有效链表的第一个节点位置为2（在数组中的位置）

// 节点结构
list.nodes[2] = {data: 30, next: 4};
list.nodes[4] = {data: 20, next: 7};
list.nodes[7] = {data: 10, next: -1}; // 下标7是最后一个节点
```

**头节点下标为`2`**，表示链表的第有效一个节点存储在`nodes[2]`位置。

**`nodes[7].next == -1`**，表示该节点是链表的**尾节点**。

**空闲节点链表**也会通过类似的`-1`来标记空间结束，如`list.free == -1`表示没有可用空间。跟有效链表一样

**遍历逻辑示例：**

```c
//充当临时变量，标识当前节点位置
int current = list.head;
while (current != -1) {//此链表不为空
    printf("%d -> ", list.nodes[current].data);
    current = list.nodes[current].next;//不断的按照链表顺序遍历
}
printf("NULL\n");
```

如果链表为空，则`head == -1`，循环不会执行。

所以，使用`-1`作为**空指针**的标志不会占用实际数组空间，而只是一个逻辑上的处理方法。它在遍历、插入、删除节点时起到控制的作用，使得链表操作更加简单和明确。

#### **不带头节点的静态链表中的head如何理解？**

**head的逻辑意义**:

- **头节点的下标初始为 -1**：这表示链表当前没有任何数据节点，链表是**空的**。
- **头节点并不是一个实际的节点**，而是一种**逻辑表示**，用于标记链表的第一个有效数据节点的下标。

换句话说：

- 在静态链表中，**head**（头节点下标）是一个变量，存储的是第一个有效节点在数组中的下标。
- 如果`head == -1`，表示链表为空，没有任何有效数据节点。

**初始化链表时的节点串联**:

你说得对，**初始化时的“串联”不是串起数据节点，而是串起空闲节点链表**，用于管理未使用的节点空间。这些空闲节点在实际插入数据时会被占用。

```c
void initList(StaticLinkedList *list) {
    list->head = -1;  // 初始时链表为空，head为-1表示无有效数据节点
    list->free = 0;    // 空闲节点的下标为0

    // 串联空闲链表，形成连续的可用节点空间
    for (int i = 0; i < MAX_SIZE - 1; i++) {
        list->nodes[i].next = i + 1;  // 每个节点指向下一个空闲节点
    }
    list->nodes[MAX_SIZE - 1].next = -1;  // 最后一个节点指向-1，表示空闲链表结束
}
```

**插入节点后的变化**:

当你插入一个节点时，**`head`就会指向第一个数据节点（逻辑层面上的第一个数据节点）的下标**，而**这个节点从空闲链表中取出**。

```c
int insertNode(StaticLinkedList *list, int value) {
    if (list->free == -1) {//通过指针访问整个链表的成员：节点数组、头节点下标和空闲节点下标。
        printf("链表已满，无法插入！\n");//free为-1表示没有节点数组下标可用：没有空间节点可用
        return -1;
    }

    int newIndex = list->free;  // 取出第一个空闲节点的下标，可用节点的起始下标，空闲链表的起始下标
    list->free = list->nodes[newIndex].next;  // 更新空闲链表

    list->nodes[newIndex].data = value;  // 存储数据
    list->nodes[newIndex].next = list->head;  // 新节点指向原头节点，头插法
    list->head = newIndex;  // 更新头节点为新插入的节点，头节点原来指向的位置交给新节点，头节点再指向新节点

    return newIndex;
}
```

**插入节点后的链表状态：**

1. 如果head原来是-1（空链表），插入第一个节点后：
   - `head`指向新插入节点的下标，例如`head = 0`。
2. 如果链表已有节点，头节点会指向新节点下标，而原来的头节点指向的旧节点下标变为新节点的**后继**。

假设：

1. 初始时，`head = -1`（空链表）。
2. 插入值为10的节点：
   - 取`free = 0`，新节点存储在`nodes[0]`中，`head`变为`0`。
3. 再插入值为20的节点：
   - 取`free = 1`，新节点存储在`nodes[1]`中，`head`变为`1`，且`nodes[1].next = 0`（指向旧节点下标）。

#### 链表位置与节点数据下标位置的区别

在**静态链表**中，**即使数据按照数组下标递增的顺序存储（空链表时）**，但逻辑上的链表顺序是通过`next`指针（下标）来连接的。**头插法**确保每次插入的新节点都成为逻辑上的第一个节点，因此`head`指针始终指向最新插入的节点，而不一定是数组中下标最小的元素。

**头节点不是实际节点，而是一个指向节点的标记**

- **`head`只是一个指针（下标），存储逻辑上第一个数据节点的下标位置**。
- **链表没有“专门的头节点”**占用数组中的某个位置，`head`变量只是负责标记链表的入口，**头插法是需要找头的位置的**。通过head可以找到逻辑上第一个节点的下标位置，从而方便新节点next的指向。

**静态链表 vs 数组下标的区别**

- **数组下标的顺序**：节点存储的位置（即`nodes[i]`）由你管理的**空闲链表**决定，**并不一定连续或有序。**
- **逻辑链表的顺序**：链表中的节点顺序由`next`指针决定，**与数组下标的顺序无关。**
- 这就是静态链表的强大之处：通过`next`指针来管理逻辑顺序，**与数组下标无关**，从而实现灵活的链表操作。

在**静态链表**中，即使初始化时数据按数组下标递增顺序存储，**经过增、删、改、查操作后，数据在数组中的存储顺序**也可能会发生变化。这种变化的原因在于，**逻辑链表的顺序由`next`指针决定**，而非数组下标顺序。

```c
初始状态（空闲链表）
假设链表的大小为5，初始化时所有节点组成一个空闲链表：
free = 0//单独初始化
nodes[0].next = 1
nodes[1].next = 2
nodes[2].next = 3
nodes[3].next = 4
nodes[4].next = -1  // 空闲链表结束，单独初始化
此时，数组存储顺序是有序的：0, 1, 2, 3, 4。
```

经过插入和删除后的变化：

插入3个数据（10, 20, 30，使用头插法）

插入数据时，总是从空闲节点链表中取出节点，因此每次插入的数据存储的位置由**当前空闲节点的下标`free`决定**。

插入过程：

- **插入 10**：使用`nodes[0]`，`free`更新为1，`head`变为0。

- **插入 20**：使用`nodes[1]`，`free`更新为2，`head`变为1。

- **插入 30**：使用`nodes[2]`，`free`更新为3，`head`变为2。

- ```c
  head = 2
  nodes[2]: data = 30, next = 1
  nodes[1]: data = 20, next = 0
  nodes[0]: data = 10, next = -1
  逻辑顺序：30 -> 20 -> 10(头插法)
  ```

删除链表第一个有效节点（删除 30）

删除时，只需将`head`更新为`nodes[2].next`，并将删除的节点重新加入空闲链表。

- **如果不是从头节点开始删除呢？怎么标记新的尾节点呢？因为没有向前指的指针**

删除链表一个节点，直接把前一个节点的next指向删除节点的next即可(后一个节点)

- **怎么来找到删除节点的前一个节点呢？因为没有向前指的指针**

```c
head = 1
free = 2
nodes[1]: data = 20, next = 0
nodes[0]: data = 10, next = -1
nodes[2].next = 3  // 被回收，加入空闲链表，直接赋值为初始化时的值就是回收吗？这么一搞就接上了初始化时的空闲链表
```

**head的本质**

- head只是一个整型变量，存储第一个有效节点的数组下标
- 它不占用nodes数组中的任何存储空间
- 当链表为空时，head = -1
- 当链表非空时，head存储的是第一个有效数据所在的数组下标

**与带头节点的区别**

- 带头节点：会占用nodes数组的第一个位置作为头节点，不存储实际数据
- 不带头节点：不占用专门的存储空间，head只是一个索引值

**head的使用场景**

- 插入第一个节点时：直接修改head的值
- 删除第一个节点时：修改head为下一个节点的位置
- 遍历时：从head指向的位置开始遍历

**优点**

- 节省一个节点的空间
- 操作更直接，不需要跳过头节点
- 空间利用率更高

**需要注意的地方**

- 所有涉及头部操作的地方都需要特别处理
- 插入第一个节点时需要修改head
- 删除第一个节点时需要特别注意

#### 删除节点并回收

**释放节点**（这个操作就像是在内存管理中"释放内存",但实际上是在静态数组中管理可用空间。需要配合其他操作一起使用）

**单独使用会导致有效链表断裂：**

- 原有效链表的连接关系没有维护

- 导致链表断裂，数据结构被破坏

- 可能造成内存泄露或访问错误

**参数说明：**

- list: 静态链表的指针
- k: 要释放的节点在数组中的下标位置（也就是节点的物理位置）
- 将指定位置的节点回收到空闲链表中,相当于把这个节点重新加入到空闲空间的管理中

```c
// 回收节点，这个函数专门操作空闲链表的，更新有效链表则由其他函数完成
void freeNode(StaticList* list, int k) {
    //让被释放节点指向当前空闲链表的第一个节点
	//采用头插法将节点插入空闲链表，操作简单且效率高，
    list->node[k].next = list->free;
    //让空闲链表的头指向被释放的节点
    list->free = k;
}
```

**正确示范：完整的删除操作**

```c
bool correctDelete(StaticLinkedList* list, int pos) {
    // pos表示要删除节点在有效链表中的位置序号
    // pos从0开始计数，比如:
    // head -> A -> B -> C -> -1
    //        0    1    2
    //位置序号的边界问题
    if (pos < 0 || pos >= list->size) {
        return false;
    }
    
    // 1. 先找到要删除节点的前驱节点（虽然传入的是位置序号，但获取的是数组下标位置）
    int prev = -1;//临时变量：充当当前节点的前驱节点位置
    int current = list->head;//从链表入口开始遍历
    for (int i = 0; i < pos; i++) {//当i为pos的前一个值时，就找到了pos序号节点的前驱节点位置
        prev = current;
        current = list->nodes[current].next;
    }
    
    // 2. 维护有效链表的连接关系
    if (prev == -1) {  // 删除第一个节点，pos为0：删除有效链表中序号为0的有效节点
        list->head = list->nodes[current].next;//哨兵节点直接跳过指向删除节点的后继节点
    } else {  
        // 删除中间或尾部节点
        // 让前驱节点指向要删除节点的后继
        list->nodes[prev].next = list->nodes[current].next;
    }
    
    // 3. 最后才释放节点，操作空闲连表
    freeNode(list, current);
    list->size--;
    
    return true;
}

// 删除具体值的节点
bool deleteValue(StaticLinkedList* list, int value) {
    // value表示要删除节点的数据值
    // 需要遍历查找具体值
    int prev = -1;
    int current = list->head;
    
    // 1. 遍历查找要删除的值
    while (current != -1 && list->nodes[current].data != value) {
        prev = current;
        current = list->nodes[current].next;
    }
    
    // 遍历到链表最后一个节点了，没找到值
    if (current == -1) {
        return false;
    }
    
    // 2. 维护链表连接（这里还是要区别是否为第一个有效节点）
    if (prev == -1) {
        list->head = list->nodes[current].next;
    } else {
        list->nodes[prev].next = list->nodes[current].next;
    }
    
    // 3. 最后释放节点
    freeNode(list, current);
    list->size--;
    
    return true;
}
```

- pos参数 (位置删除)

  - pos代表节点在有效链表中的序号/位置（从0开始）
  - 直接根据pos遍历pos次就能找到目标节点
  - 时间复杂度O(pos)，最坏O(n)

- value参数 (值删除)

  - value代表要删除的节点中存储的数据值
  - 需要遍历比较每个节点的data值来查找
  - 时间复杂度始终是O(n)，除非恰好第一个就是

- ```c
  // 数组状态：
  // 下标：   0    1    2    3    4    5    6    7    8    9
  // data：  --   --   15   --   --   20   --   --   35   --
  // next：   -    -    5    -    -    8    -    -    -1   -
  
  // head = 2，表示有效链表从下标2开始
  // 此时有效链表实际形态：
  // 下标2(15) -> 下标5(20) -> 下标8(35) -> -1
  
  // 如果删除pos=1的节点（值为20的节点）
  // 1. 遍历找到物理位置：current最终等于5（是数组下标，不是位置序号）
  // 2. 调用freeNode(list, 5)：把下标5的节点加入空闲链表
  
  //使用value删除：
  //deleteValue(list, 20);     // 删除值为20的节点，需要遍历查找
  ```

- 主要区别：

  1. 查找方式：
     - pos直接按位置计数查找
     - value需要比较节点值查找
  2. 效率：
     - pos查找更快，知道具体位置
     - value需要遍历，除非目标在最前面
  3. 使用场景：
     - pos适合知道位置的情况（如删除第一个、最后一个）
     - value适合按值查找的情况（如删除特定数据）
  4. 返回结果：
     - pos超出范围直接返回false
     - value找不到值才返回false

#### **节点回收**的流程，以及删除操作后`free`指针的更新规则。

- **删除节点后的处理流程**

假设我们使用的静态链表通过**空闲链表**来管理被删除的节点。每次删除节点后，我们需要：

1. **将被删除的节点加入空闲链表**。
2. **更新`free`指针**，以指向最新的空闲节点。
3. **让删除的节点链接上其他空闲节点**（如果有的话），以维护空闲链表的顺序。

- **完整删除操作示例**

假设链表和空闲链表初始状态如下：

```c
初始状态（空闲链表）
假设链表的大小为5，初始化时所有节点组成一个空闲链表：
head = -1
free = 0//单独初始化
nodes[0].next = 1
nodes[1].next = 2
nodes[2].next = 3
nodes[3].next = 4
nodes[4].next = -1  // 空闲链表结束，单独初始化
此时，数组存储顺序是有序的：0, 1, 2, 3, 4。
    

head = 2
free = 3
nodes[2]: data = 30, next = 1
nodes[1]: data = 20, next = 0
nodes[0]: data = 10, next = -1
    
此时的空闲链表还有：其他都被用了
nodes[3].next = 4
nodes[4].next = -1
```

现在我们要**删除链表第一个有效节点（30，存储在`nodes[2]`）**。

**删除节点后的变化**

1. **更新`head`**：
   把`head`更新为`nodes[2].next`的值，即`1`。

   1. 重新更改头节点的指向，指向此节点的next位置

2. **将`nodes[2]`加入空闲链表**：

   - 当前`free`指向空闲链表的第一个节点，即`3`。

   - 将`nodes[2]`链接到`free`指向的空闲链表上：

   - ```c
     nodes[2].next = 3;
     ```

3. **更新`free`指针**：
   让`free`指向最新的空闲节点，即刚被删除的`nodes[2]`。`free = 2`

**删除后的状态**

```c
head = 1
free = 2

nodes[1]: data = 20, next = 0
nodes[0]: data = 10, next = -1

nodes[2].next = 3  // 被回收，指向原空闲链表的第一个节点
nodes[3].next = 4
nodes[4].next = -1
```

##### free能管理空闲链表的条件

在静态链表中，通过数组实现链表节点的管理，`free`指向**第一个空闲节点**，并形成一个**空闲链表**，用于回收和分配节点。因此，如果删除逻辑不正确，可能导致空闲链表管理混乱。

不一定必须从头节点删除，但要确保在删除节点时正确地维护**空闲链表**。即无论删除哪个节点，都必须把该节点插入到空闲链表的开头，使`free`始终指向第一个空闲节点。

**有效链表**和**空闲链表**都可以采用**头插法**来简化逻辑和管理。这样既方便插入和删除操作，又能确保链表结构和空闲节点的维护不会混乱。

- **有效链表的头插法**

在有效链表中，头插法将新节点插入到链表的最前面，时间复杂度为 O(1)，不需要遍历链表（**找尾巴节点需要从第一个有效节点开始遍历**）。

- **空闲链表的头插法**

在空闲链表中，删除的节点会被回收并放到空闲链表的头部，同样是利用头插法。这样可以保证`free`总是指向第一个空闲节点，并方便管理。

```c
void deleteNode(int index) {
    list[index].next = free;  // 删除节点指向当前的free节点,
    free = index;             // 更新free为新回收的节点
}即无论删除哪个节点，都必须把该节点插入到空闲链表的开头，使`free`始终指向第一个空闲节点。
```

插入和删除的过程总结

- **插入新节点**：
  - 从空闲链表中拿出`free`指向的节点。
  - 更新`free`为下一个空闲节点。
  - 将该节点用头插法加入有效链表。
- **删除节点**：
  - 将删除的节点用头插法加入空闲链表。
- 通过**头插法**管理有效链表和空闲链表，能避免链表遍历，简化逻辑，提高效率。
- 使用头插法时，始终保证`head`指向有效链表的第一个节点，`free`指向空闲链表的第一个节点。

这种设计方式非常适合**静态链表**，因为静态链表的容量固定，回收节点和重用空闲节点十分重要。

##### 插入和删除的逻辑示例

**插入节点:**

```c
void insertAtHead(int value) {
    int newNode = allocateNode();  // 从空闲链表中分配节点
    if (newNode == -1) return;  // 无可用节点

    list[newNode].data = value;
    list[newNode].next = head;  // 新节点指向当前的头节点
    head = newNode;  // 更新head为新节点
}
```

插入后：

- **`head`** 改变为新节点的索引。
- **`free`** 改变为下一个空闲节点的索引。

**删除节点:**

```c
void deleteFromHead() {
    if (head == -1) {
        printf("链表为空，无法删除！\n");
        return;
    }

    int nodeToDelete = head;
    head = list[head].next;  // 头节点指向下一个节点

    list[nodeToDelete].next = free;  // 被删除节点归还到空闲链表
    free = nodeToDelete;  // 更新free为该节点
}
```

删除后：

- **`head`** 更新为下一个节点。
- **`free`** 更新为被删除节点的索引。

##### **为什么需要这种设计？**

- 静态链表使用**数组来模拟链表**，避免了动态内存分配的复杂性。
- 通过`next`指针实现逻辑上的灵活顺序，数据位置在数组中不需要连续存储。
- **空闲链表机制**允许回收和重用节点，提高存储效率。通过`free`管理空闲链表，保证**被删除的节点能被回收并复用**，避免浪费空间。

#### 数组实现静态链表的限制条件

使用**头插法**处理有效链表和空闲链表能有效简化逻辑，并保证结构正确。除了这个基本操作外，数组实现的静态链表还有以下几个注意事项，但整体逻辑没有特别复杂的限制条件。

**主要逻辑与流程**

1.1 插入节点

- 从**空闲链表**（`free`指向的节点）取出一个节点用于插入。
- 更新空闲链表的头节点，即`free`指向下一个空闲节点。
- 将新节点插入到**有效链表**头部（用头插法）。

1.2 删除节点

- 将删除的节点从**有效链表**中摘除。
- 用头插法将该节点加入到**空闲链表**头部（更新`free`指向该节点）。

1.3注意事项

1. **初始化空闲链表**：必须在使用前初始化，把所有节点串起来，形成初始的空闲链表。
2. **检查空闲链表是否为空**：如果`free == -1`，表示没有可用节点，需要处理这种情况。
3. **检查有效链表是否为空**：在删除节点时需要判断`head`是否为`-1`，避免非法操作。
4. **内存管理**：虽然静态链表不会涉及动态分配，但需要确保节点使用和回收的逻辑严格匹配，避免出现死循环或链表断裂的情况。

#### 总结

**"改"和"查"操作都不会影响`head`和`free`的值，也不会改变链表的整体结构。**这两类操作仅限于访问或修改节点的**数据域（`data`）**，不涉及节点之间的链接关系（即`next`指针）。因此，链表的头节点、空闲链表的管理，以及有效链表的结构都保持不变。

 在**数组实现的静态链表**中，最重要且复杂的操作就是**插入节点**和**删除节点**，因为它们会影响链表的结构——即有效链表和空闲链表的状态，以及**`head`**和**`free`**的值。

**影响链表结构的操作**：

**插入节点（Insert）**

- **影响`head`**：插入新节点后，`head`会指向新的头节点。
- **影响`free`**：从空闲链表中取节点后，`free`指向下一个可用节点。
- **结构变化**：有效链表新增一个节点，空闲链表减少一个节点。

**删除节点（Delete）**

- **影响`head`**：删除有效链表中的头节点后，`head`指向下一个节点。
- **影响`free`**：删除的节点会被归还到空闲链表，`free`指向该节点。
- **结构变化**：有效链表减少一个节点，空闲链表增加一个节点。

**改和查的特点**：

**改（Update）**

- **仅修改节点的数据域（`data`）**。
- **不改变`head`、`free`或节点的`next`指针**。

**查（Search）**

- **只遍历节点，查找数据或索引**。
- **不改变链表结构**，`head`和`free`保持不变。

#### 链表指针传递的值是什么？

##### **指针传递的本质**

在C语言中，当你传递一个结构体指针（如`StaticLinkedList *list`），**传递的是结构体变量在内存中的起始地址**。这意味着：

- **`list`指向的是整个链表结构体在内存中的起始位置**，而不是链表节点的头部节点或数组起始地址。
- 通过`list`指针，我们可以访问链表中的成员变量，如`head`（头节点下标）和`nodes`（节点数组）。

##### **链表的头节点和链表结构体的区别**

- **链表头部节点**：指的是链表中第一个有效节点，在你的代码中使用`head`来保存它的数组下标。
- **链表结构体（StaticLinkedList）**：是一个用来管理整个链表的容器，包括节点数组、头节点下标和空闲节点下标。

##### **指针传递 vs 链表头节点 vs 数组起始位置**

- **`list`指针**：指向整个`StaticLinkedList`结构体的起始位置。
- **`list->head`**：表示链表中第一个有效节点的**数组下标**，不是链表本身或结构体的位置。
- **数组起始位置**：`nodes`数组的第一个元素的地址是`list->nodes[0]`。

```scss
StaticLinkedList
+-------------------------+
| head  | -1              |  (链表头节点初始为空)
| free  | 0               |   // 这是空闲链表的第一个节点的位置（数组下标），但并不代表后续下标都是空闲的，唯一能确定的						   //是free这个位置的节点是空闲的
| nodes | [0] -> [1] -> ... -> [99] -> -1 (空闲链表)
+-------------------------+
```

### 详细对比带头结点和不带头结点的静态链表

主要区别总结：

**1.结构设计差异**

- 带头结点：
  - 头结点固定占用数组0号位置
  - 头结点不存储数据
  - 实际数据从1号位置开始存储
  - 空链表时头结点next为-1
- 不带头结点：
  - head是位置索引，不占用固定位置
  - 所有位置都可以存储数据
  - 空链表时head为-1
  - 可以充分利用0号位置

**2.操作实现差异**

- 初始化
  - 带头结点：需要初始化头结点，空闲链表从1开始
  - 不带头结点：直接置head为-1，空闲链表从0开始
- 插入操作
  - 带头结点：
    - 不需要特殊处理头部插入
    - 位置计数从1开始
    - 查找时从头结点开始
  - 不带头结点：
    - 需要特别处理头部插入(i==0)
    - 位置计数从0开始
    - 查找时直接从head开始
- 删除操作
  - 带头结点：
    - 删除第一个节点与其他位置相同
    - 永远不会删除头结点
  - 不带头结点：
    - 删除第一个节点需要特殊处理
    - 需要修改head指向
- 遍历操作
  - 带头结点：从头结点的next开始
  - 不带头结点：直接从head开始

**3.各自优缺点**

带头结点优点：

- 统一操作，不需要特殊处理头部
- 实现逻辑更简单
- 便于处理空表情况

带头结点缺点：

- 浪费一个存储位置
- 需要额外的空间开销

不带头结点优点：

- 节省存储空间
- 能充分利用所有位置
- 更接近数组操作习惯

不带头结点缺点：

- 需要特殊处理头部操作
- 实现逻辑稍复杂
- 代码可能略多

选择建议：

1. 如果空间紧张，建议使用不带头结点
2. 如果追求实现简单，建议使用带头结点(**所有节点操作统一**)
3. 如果经常在头部操作，建议使用带头结点

## 链式存储实现动态链表（指针）

### 生产环境的常规使用

在生产环境中，关于静态链表的实现，我来分析一下这两个问题:

1.关于头节点的选择: 在实际生产中，通常**更倾向于使用带头结点的静态链表**，原因是:

- 统一了操作，不需要对第一个节点进行特殊处理
- 插入和删除操作更简单，不需要修改头指针（**每一个节点操作统一**）
- 便于处理空链表的情况
- 降低了代码的出错概率

2.关于实现方式: 在生产环境中，数组实现的静态链表和指针实现的动态链表各有使用场景:

数组实现多用于:

- **嵌入式系统等内存受限的环境**

- 对内存碎片敏感的场景（**数组实现都是连续的空间，内存碎片会小一点**）

  - 指针实现：

    - 每个节点单独分配,在堆上随机存储

    - 反复的new/delete会造成不连续的内存空洞

    - 这些空洞可能因为大小不合适而无法被重新利用

    - 导致严重的内存碎片化

  - 数组实现：

    - 一次性分配连续的大块内存
    - 节点物理位置固定,不会产生物理碎片
    - 虽然有逻辑碎片(空闲节点),但易于管理
    - 空闲位置一定能被重复利用，free指针管理空闲位置

- 需要频繁增删的场合(**避免频繁动态分配，静态链表空间大小和位置都已经固定好了**)

- 数据规模固定或可预知的情况

指针实现多用于:

- 普通应用程序开发
- 数据规模不确定的场景
- 内存资源相对充足的环境
- 需要灵活扩展的情况

### 带头结点的动态链表分析

[实现传送门](##带头结点的动态链表分析(已验))

#### 反转链表思路

假设我们有一个链表: 1 -> 2 -> 3 -> NULL

初始状态：

```c
head -> 1 -> 2 -> 3 -> NULL
        ↑
     current
prev = NULL
next = NULL
```

第一次循环：

```c
// next = current->next
head -> 1 -> 2 -> 3 -> NULL
        ↑    ↑
     current next
prev = NULL

// current->next = prev
head -> 1    2 -> 3 -> NULL
        ↑    ↑
     current next
        ↓
       NULL

// prev = current
head -> 1    2 -> 3 -> NULL
        ↑    ↑
       prev  next
       /↓
      NULL

// current = next
head -> 1    2 -> 3 -> NULL
        ↑    ↑
       prev  current
       /↓
      NULL
```

第二次循环：

```c
// next = current->next
head -> 1    2 -> 3 -> NULL
        ↑    ↑    ↑
       prev  cur  next
       /↓
      NULL

// current->next = prev
head -> 1 <- 2    3 -> NULL
        ↑    ↑    ↑
       prev  cur  next

// prev = current
head -> 1 <- 2    3 -> NULL
        ↑    ↑    ↑
            prev  next
             ↑
          current

// current = next
head -> 1 <- 2    3 -> NULL
        ↑    ↑    ↑
            prev  current
```

第三次循环：

```c
// next = current->next
head -> 1 <- 2    3 -> NULL
        ↑    ↑    ↑
            prev  current
                  next=NULL

// current->next = prev
head -> 1 <- 2 <- 3
        ↑    ↑    ↑
            prev  current
                  next=NULL

// prev = current
head -> 1 <- 2 <- 3
        ↑    ↑    ↑
                  prev
                  current

// current = next
head -> 1 <- 2 <- 3
        ↑    ↑    ↑
                  prev
              current=NULL
```

循环结束，更新头节点指向：

```c
// list->head->next = prev
head -> 3 -> 2 -> 1 -> NULL
```

关键点解析：

1. 需要三个指针：
   - prev: 当前节点要指向的前一个节点
   - current: 当前正在处理的节点
   - next: 保存下一个要处理的节点(防止链表断开)
2. 注意事项：
   - 从头节点的下一个节点开始反转
   - 先保存next，否则改变current->next后会丢失后续节点
   - 每次循环完整移动三个指针
   - 最后更新头节点指向反转后的第一个节点
3. 边界条件：
   - 空链表不需要反转
   - 只有一个节点不需要反转
   - 头节点始终存在不参与反转

### 不带头节点

在初始化上，指针在两种实现上的区别，就是一个需要单独初始化一个头节点，另一个就不需要了

```c
// 带头结点的初始化
struct Node* initList() {
    struct Node* head = (struct Node*)malloc(sizeof(struct Node));
    head->next = NULL;
    return head;
}

// 不带头结点的初始化 
struct Node* initList() {
    return NULL;  // 直接返回空指针即可
}
```

带头结点的需要额外分配一个节点作为头结点,而不带头结点的初始化时就直接返回NULL就可以了。

不过这只是初始化上的区别。在后续的插入、删除等操作中,由于结构上的差异,两种实现方式的具体代码会有较大的不同,需要不同的处理方式。

## 单向带头节点循环链表（数组）

### 在c语言的生产环境中，实现单向循环链表的话，使用数组多一点还是指针多一点？

使用数组实现的优点：

1. 内存连续，访问效率高，CPU缓存友好
2. 内存管理简单，不用担心内存泄漏和碎片化
3. 代码结构简单，维护成本低
4. 适合元素数量可预知的场景

数组实现的缺点：

1. 需要预先分配固定大小
2. 空间利用效率可能不高
3. 插入和删除操作需要移动元素，效率较低

使用指针实现的优点：

1. 空间利用更灵活，按需分配
2. 插入和删除操作效率高，只需修改指针
3. 无需预先知道元素数量
4. 空间利用率高

指针实现的缺点：

1. 内存不连续，cache miss率较高
2. 需要仔细管理内存，避免泄漏
3. 代码相对复杂，容易出错
4. 每个节点需要额外存储指针，空间开销大

在生产环境中，我建议根据具体场景选择：

- 如果数据量固定且较小，建议用数组实现，代码更安全可靠
- 如果数据量不固定或较大，需要频繁插入删除，建议用指针实现

### 也就是动态链表和静态链表的区别嘛？与单向链表的区别就是尾巴节点要指向第一个节点或者头节点？

静态链表(数组实现)vs动态链表(指针实现):

```c
// 静态链表实现
struct Node {
    int data;          // 数据域
    int next;          // 下一个元素的数组下标
};
struct Node arr[MAXSIZE];  // 静态分配

// 动态链表实现
struct Node {
    int data;           // 数据域
    struct Node *next;  // 指向下一节点的指针
};
struct Node *head = NULL;  // 动态分配
```

普通单向链表vs单向循环链表:

```c
// 普通单向链表 - 最后一个节点指向NULL
A -> B -> C -> D -> NULL

// 单向循环链表 - 最后一个节点指回头节点
A -> B -> C -> D -┐
^                 |
└-----------------┘
```

主要区别:

1. 单向链表最后节点指向NULL,表示链表结束
2. 单向循环链表最后节点指向头节点,形成闭环
3. 循环链表判断结束的条件变为:当前节点的next等于头节点(**从头节点开始遍历，到最后一个节点时因为循环会再一次遍历到头节点**)

循环链表的优点是:

1. 从任意节点都能遍历整个链表
2. 适合需要循环处理的场景(如操作系统的进程调度)
3. 在尾部添加节点时不用遍历到最后

单向链表和单向循环链表遍历位置的区别：

​	单向链表:

- 确实只能从头节点/第一个节点开始遍历
- 因为每个节点只知道自己的下一个节点,不知道前面的节点
- 如果从中间某个节点开始,你无法遍历到之前的节点
- 只能访问到当前节点之后的元素

```c
// 单向链表遍历示例
void traverse(struct Node* head) {
    struct Node* current = head;
    while (current != NULL) {  // 到NULL结束
        // 处理current节点
        current = current->next;
    }
}
```

单向循环链表:

- 可以从任意节点开始遍历
- 因为最后节点会指向头节点,形成闭环
- 从任意节点出发,都能遍历一圈回到起点
- 遍历终止条件变为:回到起始节点

```c
// 单向循环链表从任意节点遍历示例
void traverse_from_any(struct Node* start) {
    if(start == NULL) return;
    
    struct Node* current = start;
    do {
        // 处理current节点
        current = current->next;
    } while (current != start);  // 回到起点结束
}
```

这也是为什么循环链表在某些场景(如轮询调度)更有优势,因为它不需要每次都从头开始遍历。

### 数组实现单向循环链表的最佳实践

```c
#include <stdio.h>
#include <stdbool.h>

#define MAX_SIZE 1000
#define INVALID_IDX -1
#define ERROR_CODE -1

typedef struct {
    int data;              // 头节点中存储链表长度
    int next;              // 指向下一个节点的索引
} Node;

typedef struct {
    Node nodes[MAX_SIZE];  // 节点数组(0号位为头节点)
    int head;              // 头节点索引(固定为0)
    int free;              // 空闲节点链表的头索引
} CircularList;

// 初始化循环链表
void initList(CircularList* list) {
    // 初始化头节点，有效链表就指向自己（空有效链表的情况）
    list->head = 0;
    list->nodes[0].data = 0;    // 头节点data存储长度,初始为0
    list->nodes[0].next = 0;    // 空链表时指向自己
    
    // 初始化空闲链表，空闲链表的最后一个位置还是指向-1
    for (int i = 1; i < MAX_SIZE - 1; i++) {
        list->nodes[i].next = i + 1;
    }
    list->nodes[MAX_SIZE - 1].next = INVALID_IDX;//会被替换为-1
    list->free = 1;  // 空闲链表从索引1开始
}

// 分配新节点
int allocNode(CircularList* list) {
    if (list->free == INVALID_IDX) {//空闲链表没有节点可以使用
        return ERROR_CODE;
    }
    
    int newNode = list->free;
    list->free = list->nodes[newNode].next;
    list->nodes[0].data++;  // 利用头节点的数据来保存有效链表的长度，更新链表长度
    
    return newNode;
}

// 释放节点，跟别的操作一起使用
void freeNode(CircularList* list, int nodeIdx) {
    if (nodeIdx <= 0 || nodeIdx >= MAX_SIZE) {
        return;
    }
    
    list->nodes[nodeIdx].next = list->free;
    list->free = nodeIdx;
    list->nodes[0].data--;  // 更新链表长度
}

// 在头节点后插入(即链表首部插入，顶替第一个有效节点的位置)
int insertFirst(CircularList* list, int data) {
    int newNode = allocNode(list);
    if (newNode == ERROR_CODE) {
        return ERROR_CODE;
    }
    
    list->nodes[newNode].data = data;
    // 新节点指向头节点的下一个节点
    list->nodes[newNode].next = list->nodes[0].next;
    // 头节点指向新节点
    list->nodes[0].next = newNode;
    
    return newNode;
}

// 在链表尾部插入，充当有效链表的最后一个位置并指向头节点（普通单向链表是指向-1）
int insertLast(CircularList* list, int data) {
    int newNode = allocNode(list);
    if (newNode == ERROR_CODE) {
        return ERROR_CODE;
    }
    
    list->nodes[newNode].data = data;
    list->nodes[newNode].next = list->head;  // 新节点指向头节点
    
    // 找到最后一个节点（还是要从头节点遍历）
    int current = list->head;
    while (list->nodes[current].next != list->head) {//只要当前节点指向了头节点就代表是最后一个节点了
        current = list->nodes[current].next;
    }
    
    list->nodes[current].next = newNode;
    
    return newNode;
}

// 删除第一个有效节点
int deleteFirst(CircularList* list) {
    if (list->nodes[0].next == list->head) {  // 空链表
        return ERROR_CODE;
    }
    
    int firstNode = list->nodes[0].next;//头节点永远指向第一个有效节点
    int data = list->nodes[firstNode].data;
    
    // 头节点指向第二个节点
    list->nodes[0].next = list->nodes[firstNode].next;
    
    freeNode(list, firstNode);//把节点在数组中的下标传入就可以释放
    return data;
}

// 在"指定位置后"插入节点
int insertAfter(CircularList* list, int prevIdx, int data) {
    if (prevIdx < 0 || prevIdx >= MAX_SIZE) {//数组只有从1到max_size-1的位置有效，才可以在他们后面插入
        return ERROR_CODE;
    }
    
    int newNode = allocNode(list);
    if (newNode == ERROR_CODE) {
        return ERROR_CODE;
    }
    
    list->nodes[newNode].data = data;
    list->nodes[newNode].next = list->nodes[prevIdx].next;
    list->nodes[prevIdx].next = newNode;
    
    return newNode;
}

// 删除指定位置的后继节点
int deleteAfter(CircularList* list, int prevIdx) {
    if (prevIdx < 0 || prevIdx >= MAX_SIZE) {
        return ERROR_CODE;
    }
    
    int toDelete = list->nodes[prevIdx].next;
    if (toDelete == list->head) {  // 不能删除头节点
        return ERROR_CODE;
    }
    
    int data = list->nodes[toDelete].data;
    list->nodes[prevIdx].next = list->nodes[toDelete].next;
    
    freeNode(list, toDelete);
    return data;
}

// 查找指定值的节点索引
int findValue(CircularList* list, int value) {
    if (list->nodes[0].next == list->head) {  // 空链表
        return ERROR_CODE;
    }
    
    int current = list->nodes[0].next;  // 从第一个实际节点开始
    while (current != list->head) {
        if (list->nodes[current].data == value) {
            return current;
        }
        current = list->nodes[current].next;
    }
    
    return ERROR_CODE;
}

// 从指定节点开始遍历打印
void traverseFrom(CircularList* list, int startIdx) {
    if (startIdx <= 0 || startIdx >= MAX_SIZE) {
        return;
    }
    
    printf("List length: %d\n", list->nodes[0].data);
    printf("Elements: ");
    
    int current = startIdx;
    do {
        printf("%d ", list->nodes[current].data);
        current = list->nodes[current].next;
    } while (current != list->head && current != startIdx);
    printf("\n");
}

// 获取链表大小
int getSize(CircularList* list) {
    return list->nodes[0].data;
}

// 判断链表是否为空
bool isEmpty(CircularList* list) {
    return list->nodes[0].next == list->head;
}

// 判断链表是否已满
bool isFull(CircularList* list) {
    return list->nodes[0].data == MAX_SIZE - 1;  // 减1是因为头节点占用一个位置
}

// 清空链表
void clearList(CircularList* list) {
    while (!isEmpty(list)) {
        deleteFirst(list);
    }
}
```

带头节点的主要改动和优点：

1. 结构变化：

   - 索引0固定用作头节点
   - 空闲链表从索引1开始
   - 实际容量减少1(因为头节点占用一个位置)

2. 操作简化：

   - 不需要维护tail指针（可以通过遍历到head找到尾部）
   - insertFirst/deleteFirst操作更简单，不需要处理空链表特殊情况
   - isEmpty判断简化为检查头节点的next是否指向自己

3. 优点：

   - 统一了空链表和非空链表的操作
   - 无需特殊处理第一个节点和最后一个节点
   - 插入和删除操作更简单
   - 代码更容易维护

4. 主要改进：

   1. 节点结构简化：

   2. ```c
      typedef struct {
          int data;              // 数据域
          int next;              // 指针域
      } Node;
      ```

      1. 删除了多余的`is_used`字段
      2. 头节点的data域用于存储链表长度

   3. 链表结构简化：

   4. ```c
      typedef struct {
          Node nodes[MAX_SIZE];  
          int head;              // 头节点索引(固定为0)
          int free;              // 空闲链表头指针
      } CircularList;
      ```

      1. 删除了多余的size字段
      2. 保留free字段用于管理空闲空间

   5. 长度管理：

      - 插入节点时: `list->nodes[0].data++`

      - 删除节点时: `list->nodes[0].data--`

      - 获取长度: `return list->nodes[0].data`

   6. 判空和判满：

   7. ```c
      bool isEmpty(CircularList* list) {
          return list->nodes[0].next == list->head;
      }
      
      bool isFull(CircularList* list) {
          return list->nodes[0].data == MAX_SIZE - 1;
      }
      ```

      

示例：

```c
CircularList list;
initList(&list);

insertFirst(&list, 1);
insertFirst(&list, 2);
insertLast(&list, 3);

// 从第一个节点开始遍历
traverseFrom(&list, list.nodes[0].next);  
// 输出:
// List length: 3
// Elements: 2 1 3

printf("List size: %d\n", getSize(&list));  // 输出: 3
```

#### 与数组实现带头节点单向链表的区别

[与实现带头节点的单向链表而言](####带头节点的实现)： 节点结构体定义中多了一个bool is_used;  头节点初始化时，空链表单向链表是指向-1，而单向循环链表指向自己以及data域没有赋值的

```c
// 循环链表中的节点结构
typedef struct {
    int data;               
    int next;              
    bool is_used;          // 这个在普通单链表中是不需要的
} Node;

// 普通单链表中的节点结构就够了
typedef struct {
    int data;               
    int next;              
} Node;
```

**不需要这个字段原因是:**

1. 带头节点的数组实现(无论是单向还是循环链表),都是通过free链表来管理空闲空间
2. 节点是否被使用可以通过:
   - 是否在free链表中来判断
   - 或通过遍历有效链表(从头节点的next开始)来判断
3. free链表和有效链表是互斥的:
   - 一个节点要么在free链表中
   - 要么在以头节点为起点的有效链表中
4. head节点(索引0)是特殊的,永远被使用
5. 其他节点(索引1~MAX_SIZE-1)要么在free链表中,要么在有效链表中

所以不需要额外的bool字段来标记节点是否被使用。

头节点初始化的差异:

```c
// 普通单向链表的头节点初始化
list->head = 0;
list->nodes[0].next = -1;  // 指向INVALID_IDX
list->nodes[0].data = 0;   // 一般不使用头节点的数据域

// 单向循环链表的头节点初始化
list->head = 0;
list->nodes[0].next = 0;   // 指向自己
list->nodes[0].data = 0;   // 可以用来存储链表信息(如长度等)
```

差异原因:

- 普通单链表用-1(INVALID_IDX)表示链表结束

- 循环链表没有结束点,空时头节点指向自己形成循环

- 循环链表中头节点的data域可以用于存储链表信息(虽然我上面的实现没有充分利用这点)

  - ```c
    // 插入和删除时更新头节点的data(存储长度信息)
    list->nodes[0].data++;  // 插入时
    list->nodes[0].data--;  // 删除时
    ```

  - 这样我们就不需要单独维护size字段了,直接用头节点的data域存储链表长度,这也是头节点一个常见的用法。

## 单向带头节点循环链表（指针）

[对比简单单向链表实现](###带头结点的动态链表（指针实现）)

```c
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点结构体
typedef struct Node {
    int data;           // 数据域：保存节点值
    struct Node* next;  // 指针域：指向下一个节点的指针
} Node;

// 定义链表结构体
typedef struct LinkedList {
    Node* head;  // 头节点（保存链表长度）
} LinkedList;

// 创建新节点,不做指向操作
Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (!newNode) {
        printf("内存分配失败\n");
        exit(1);
    }
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// 初始化链表：创建头节点并让它指向自己，长度初始为 0
LinkedList* initList() {
    LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));//实例化一个链表
    if (!list) {
        printf("内存分配失败\n");
        exit(1);
    }
    list->head = createNode(0);  // 头节点 data 域保存长度，这个函数已经给data域赋值为0了
    list->head->next = list->head;  // 头节点指向自身，形成循环链表
    return list;
}

// 在链表头部插入节点
void insertAtHead(LinkedList* list, int value) {
    Node* newNode = createNode(value);//返回一个node*类型的指针，出来需要一个node*类型的指针接收
    newNode->next = list->head->next;  // 新节点指向第一个数据节点
    list->head->next = newNode;  // 头节点指向新节点
    list->head->data++;  // 链表长度 +1，这里直接用data++没有任何问题
}

// 在链表尾部插入节点（成为最后一个节点位置）
void insertAtTail(LinkedList* list, int value) {
    Node* newNode = createNode(value);
    Node* temp = list->head;
    // 找到最后一个节点（指向头节点的节点）
    while (temp->next != list->head) {
        temp = temp->next;
    }
    temp->next = newNode;  // 最后一个节点指向新节点
    newNode->next = list->head;  // 新节点指向头节点
    list->head->data++;  // 链表长度 +1
}

// 删除指定值的节点
void deleteNode(LinkedList* list, int value) {
    Node* temp = list->head;
    // 找到目标节点的前驱节点
    while (temp->next != list->head && temp->next->data != value) {
        temp = temp->next;
    }
    if (temp->next == list->head) {
        printf("未找到值为 %d 的节点\n", value);
        return;
    }
    Node* toDelete = temp->next;
    temp->next = toDelete->next;  // 跳过目标节点
    free(toDelete);  // 释放内存
    list->head->data--;  // 链表长度 -1
}

// 查找节点：返回指向目标节点的指针
Node* searchNode(LinkedList* list, int value) {
    Node* temp = list->head->next;
    while (temp != list->head) {
        if (temp->data == value) {
            return temp;
        }
        temp = temp->next;
    }
    return NULL;
}

// 打印链表
void printList(LinkedList* list) {
    printf("链表长度: %d\n", list->head->data);
    Node* temp = list->head->next;
    while (temp != list->head) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("(头节点)\n");
}

// 释放链表内存
void freeList(LinkedList* list) {
    Node* temp = list->head->next;
    while (temp != list->head) {
        Node* next = temp->next;
        free(temp);
        temp = next;
    }
    free(list->head);  // 释放头节点
    free(list);  // 释放链表结构体
}

// 测试代码
int main() {
    LinkedList* list = initList();

    insertAtHead(list, 1);
    insertAtHead(list, 2);
    insertAtTail(list, 3);
    printList(list);

    deleteNode(list, 2);
    printList(list);

    Node* found = searchNode(list, 3);
    if (found) {
        printf("找到节点: %d\n", found->data);
    } else {
        printf("节点未找到\n");
    }

    freeList(list);
    return 0;
}
```

## 双向带头结点循环链表（数组）

在**生产环境**中，使用**带头节点的链表**（无论是单向、双向还是循环链表）通常会更多一些，因为它能带来以下优势：

1. **简化边界处理**

- **头节点**不存储实际数据，但作为链表的固定入口，避免了特殊情况下的空指针问题。例如，当链表为空或需要插入第一个节点时，不需要单独判断。
- 对于插入、删除等操作，不需要检查是否在链表的首部或尾部，逻辑更简洁。

2. **提升操作一致性**

- 无论插入的位置（首部、中间或尾部），代码的处理流程可以一致，避免冗余的判断逻辑。
- 对于循环链表，有头节点的设计更容易实现循环结构的完整性。

3. **方便扩展和维护**

- **双向链表**的头节点可以有额外的指针来管理链表元信息（如链表长度）。
- 在多线程环境下，头节点可以作为链表的锁或同步操作的起点，保证数据的一致性。

4. **适用场景多样**

- **循环链表**常用于队列或缓存算法（如LRU缓存）。
- **单向链表**用于一些简单的数据存储场景，如消息队列。
- **双向链表**在需要频繁前后遍历的场景中，如内存管理和双端队列（Deque）。

小结

**带头节点的链表**简化了代码逻辑，避免了很多边界问题和特殊情况的判断，使得生产环境中的开发和维护更加高效。这种结构在**系统编程、缓存管理**以及**网络消息传递**等领域广泛应用。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 1000  // 数组最大容量
#define INVALID_IDX -1 // 无效索引标记

// 链表节点结构
typedef struct {
    int data;           // 数据域
    int prev;           // 前驱节点在数组中的索引,单向链表中没有指向前面的指针
    int next;           // 后继节点在数组中的索引
} Node;

// 双向循环链表结构
typedef struct {
    Node nodes[MAX_SIZE];  // 存储节点的数组
    int head;              // 头节点索引
    int free;             // 空闲链表头指针
} DoublyCircularList;

// 初始化链表
void initList(DoublyCircularList* list) {
    // 初始化头节点
    list->head = 0;//把数组0号下标给头节点
    list->nodes[0].data = 0;  // 使用头节点的data域存储链表大小，初始化为空，所以为0
    list->nodes[0].next = 0;  // 指向自身
    list->nodes[0].prev = 0;  // 指向自身
    
    // 初始化空闲链表，空闲链表没必要双向，所以前驱指针不初始化。
    list->free = 1;//0号下标给头节点了
    for (int i = 1; i < MAX_SIZE - 1; i++) {
        list->nodes[i].next = i + 1;
    }
    list->nodes[MAX_SIZE - 1].next = INVALID_IDX;//最后一个位置单独处理
}

// 分配新节点
int allocNode(DoublyCircularList* list) {
    if (list->free == INVALID_IDX) {
        return INVALID_IDX;  // 没有可用节点
    }
    
    int newIdx = list->free;
    list->free = list->nodes[newIdx].next;
    return newIdx;
}

// 释放节点
void freeNode(DoublyCircularList* list, int idx) {
    // 将节点加入空闲链表头部
    list->nodes[idx].next = list->free;
    list->free = idx;
}

// 在指定位置后插入节点
int insertAfter(DoublyCircularList* list, int pos, int data) {
    if (pos < 0 || pos >= MAX_SIZE) {
        return 0;  // 插入位置无效
    }
    
    int newIdx = allocNode(list);
    if (newIdx == INVALID_IDX) {
        return 0;  // 数组已满
    }
    
    // 初始化新节点
    list->nodes[newIdx].data = data;
    
    // 调整链接关系（只有增删操作才会改变链表的结构才会改动指针指向）
    list->nodes[newIdx].next = list->nodes[pos].next;
    list->nodes[newIdx].prev = pos;
    list->nodes[list->nodes[pos].next].prev = newIdx;
    list->nodes[pos].next = newIdx;
    
    // 更新链表大小（存储在头节点的data域）
    list->nodes[list->head].data++;
    return 1;
}

// 删除指定位置的节点
int deleteNode(DoublyCircularList* list, int pos) {
    if (pos <= 0 || pos >= MAX_SIZE) {
        return 0;  // 删除位置无效或是头节点
    }
    
    // 调整链接关系
    list->nodes[list->nodes[pos].prev].next = list->nodes[pos].next;
    list->nodes[list->nodes[pos].next].prev = list->nodes[pos].prev;
    
    // 将节点加入空闲链表
    freeNode(list, pos);
    
    // 更新链表大小
    list->nodes[list->head].data--;
    return 1;
}

// 查找指定数据的节点位置
int findNode(DoublyCircularList* list, int data) {
    if (list->nodes[list->head].data == 0) {
        return INVALID_IDX;
    }
    
    int current = list->nodes[list->head].next;
    while (current != list->head) {
        if (list->nodes[current].data == data) {
            return current;
        }
        current = list->nodes[current].next;
    }
    return INVALID_IDX;
}

// 修改指定位置的节点数据
int updateNode(DoublyCircularList* list, int pos, int new_data) {
    if (pos <= 0 || pos >= MAX_SIZE) {
        return 0;
    }
    list->nodes[pos].data = new_data;
    return 1;
}

// 判断链表是否为空
int isEmpty(DoublyCircularList* list) {
    return list->nodes[list->head].data == 0;
}

// 获取链表大小
int getSize(DoublyCircularList* list) {
    return list->nodes[list->head].data;
}

// 正向遍历打印链表
void printList(DoublyCircularList* list) {
    if (isEmpty(list)) {
        printf("链表为空\n");
        return;
    }
    
    printf("链表内容: ");
    int current = list->nodes[list->head].next;
    while (current != list->head) {
        printf("%d ", list->nodes[current].data);
        current = list->nodes[current].next;
    }
    printf("\n");
}

// 反向遍历打印链表
void printListReverse(DoublyCircularList* list) {
    if (isEmpty(list)) {
        printf("链表为空\n");
        return;
    }
    
    printf("链表反向内容: ");
    int current = list->nodes[list->head].prev;
    while (current != list->head) {
        printf("%d ", list->nodes[current].data);
        current = list->nodes[current].prev;
    }
    printf("\n");
}

// 打印空闲链表（用于调试）
void printFreeList(DoublyCircularList* list) {
    printf("空闲链表索引: ");
    int current = list->free;
    while (current != INVALID_IDX) {
        printf("%d ", current);
        current = list->nodes[current].next;
    }
    printf("\n");
}

// 清空链表
void clearList(DoublyCircularList* list) {
    int current = list->nodes[list->head].next;
    while (current != list->head) {
        int next = list->nodes[current].next;
        freeNode(list, current);
        current = next;
    }
    
    list->nodes[list->head].next = list->head;
    list->nodes[list->head].prev = list->head;
    list->nodes[list->head].data = 0;  // 重置大小为0
}

// 示例使用
int main() {
    DoublyCircularList list;
    initList(&list);
    
    // 插入测试
    insertAfter(&list, 0, 10);
    insertAfter(&list, 1, 20);
    insertAfter(&list, 2, 30);
    printf("当前链表大小: %d\n", getSize(&list));
    printList(&list);
    
    // 打印空闲链表状态
    printFreeList(&list);
    
    // 删除测试
    deleteNode(&list, 2);
    printf("删除后链表大小: %d\n", getSize(&list));
    printList(&list);
    
    // 再次打印空闲链表状态
    printFreeList(&list);
    
    // 查找和更新测试
    int pos = findNode(&list, 30);
    if (pos != INVALID_IDX) {
        updateNode(&list, pos, 35);
    }
    printList(&list);
    
    // 反向打印测试
    printListReverse(&list);
    
    // 清空链表
    clearList(&list);
    printf("清空后链表大小: %d\n", getSize(&list));
    
    return 0;
}
```

主要改进包括：

1. 结构优化：
   - 移除了独立的 size 字段，使用头节点的 data 域存储链表大小
   - 移除了 is_used 字段，改用free空闲链表管理方式
   - 简化了 DoublyCircularList 结构体
2. 内存管理：
   - 使用更直观的空闲链表（free list）管理未使用的节点
   - 新增 allocNode 和 freeNode 函数，使内存管理更清晰
   - 添加了 printFreeList 函数用于调试和观察空闲链表状态
3. 功能完善：
   - 所有基本操作都相应修改以适应新的结构
   - 维护了更清晰的空闲节点管理
   - 保持了双向循环链表的所有特性

### 实现优点

以数组方式实现的静态双向链表（也叫游标实现）有几个重要的优点：

1. 内存管理优势：
   - 内存连续，空间局部性好，cache友好
   - 无需动态内存分配，避免内存碎片
   - 内存使用可预测，适合嵌入式等对内存管理有严格要求的环境
   - 无需考虑内存泄漏问题
   - 不会因频繁的malloc/free导致性能抖动
2. 性能优势：
   - 数组随机访问快，可以O(1)时间直接访问任意节点
   - 避免了指针操作的开销
   - 节点的添加/删除仅需修改索引，无需实际移动数据
   - 可以实现O(1)的节点回收和分配
3. 稳定性优势：
   - 不会出现野指针问题
   - 数据存储在连续空间，更容易做持久化
   - 便于实现内存池，控制资源使用上限
   - 程序行为更确定，易于调试
4. 应用场景优势：
   - 适合嵌入式系统等资源受限环境
   - 适合需要频繁插入删除但总节点数可预测的场景
   - 适合要求高可靠性的系统
   - 便于序列化和反序列化
   - 适合多线程环境（锁粒度可以更细）
5. 维护和调试优势：
   - 整个链表在一段连续内存，容易观察和dump
   - 节点关系清晰，通过索引就能确定位置
   - 便于添加调试信息和状态检查
   - 数据结构状态容易验证

实际应用示例：

1. 文件系统的空闲块管理
2. 进程调度队列
3. 内存池实现
4. 嵌入式系统的定时器管理
5. 数据库系统的空闲页管理

需要注意的限制：

1. 需要预先确定最大节点数
2. 不适合节点数量变化很大的场景
3. 不适合总节点数非常大的场景
4. 可能会有空间浪费

## 双向带头结点循环链表（指针）

```c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

// 链表节点结构
typedef struct Node {
    struct Node* prev;    // 前驱指针
    struct Node* next;    // 后继指针
    int data;            // 数据域（头节点中用作size计数）
} Node;

// 链表结构体，只需要保存头节点指针
typedef struct {
    Node* head;          // 头节点指针（其data域用作size）
} List;

// 创建新节点
static Node* create_node(int data) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    if (new_node == NULL) {
        return NULL;
    }
    new_node->data = data;
    new_node->prev = new_node->next = NULL;
    return new_node;
}

// 初始化链表
List* list_init(void) {
    List* list = (List*)malloc(sizeof(List));
    if (list == NULL) {
        return NULL;
    }

    list->head = create_node(0);  // 初始化size为0
    if (list->head == NULL) {
        free(list);
        return NULL;
    }

    // 初始时头节点自己构成循环
    list->head->next = list->head;
    list->head->prev = list->head;
    return list;
}

// 在指定节点后插入新节点
static void insert_after(Node* pos, Node* new_node) {
    new_node->next = pos->next;
    new_node->prev = pos;
    pos->next->prev = new_node;
    pos->next = new_node;
}

// 在链表尾部插入节点
bool list_push_back(List* list, int data) {
    if (list == NULL) {
        return false;
    }

    Node* new_node = create_node(data);
    if (new_node == NULL) {
        return false;
    }

    insert_after(list->head->prev, new_node);
    list->head->data++;  // 使用头节点的data域作为size计数
    return true;
}

// 在链表头部插入节点
bool list_push_front(List* list, int data) {
    if (list == NULL) {
        return false;
    }

    Node* new_node = create_node(data);
    if (new_node == NULL) {
        return false;
    }

    insert_after(list->head, new_node);
    list->head->data++;  // 使用头节点的data域作为size计数
    return true;
}

// 删除指定节点
static void remove_node(Node* node) {
    node->prev->next = node->next;
    node->next->prev = node->prev;
}

// 删除尾部节点
bool list_pop_back(List* list) {
    if (list == NULL || list->head->data == 0) {  // 使用头节点的data域判断空
        return false;
    }

    Node* last = list->head->prev;
    remove_node(last);
    free(last);
    list->head->data--;  // 使用头节点的data域作为size计数
    return true;
}

// 删除头部节点
bool list_pop_front(List* list) {
    if (list == NULL || list->head->data == 0) {  // 使用头节点的data域判断空
        return false;
    }

    Node* first = list->head->next;
    remove_node(first);
    free(first);
    list->head->data--;  // 使用头节点的data域作为size计数
    return true;
}

// 查找指定值的节点
Node* list_find(const List* list, int value) {
    if (list == NULL) {
        return NULL;
    }

    for (Node* curr = list->head->next; curr != list->head; curr = curr->next) {
        if (curr->data == value) {
            return curr;
        }
    }
    return NULL;
}

// 在指定位置插入节点
bool list_insert_at(List* list, size_t position, int data) {
    if (list == NULL || position > (size_t)list->head->data) {  // 使用头节点的data域判断范围
        return false;
    }

    Node* new_node = create_node(data);
    if (new_node == NULL) {
        return false;
    }

    Node* curr = list->head;
    for (size_t i = 0; i < position; i++) {
        curr = curr->next;
    }

    insert_after(curr, new_node);
    list->head->data++;  // 使用头节点的data域作为size计数
    return true;
}

// 删除指定位置的节点
bool list_remove_at(List* list, size_t position) {
    if (list == NULL || position >= (size_t)list->head->data) {  // 使用头节点的data域判断范围
        return false;
    }

    Node* curr = list->head->next;
    for (size_t i = 0; i < position; i++) {
        curr = curr->next;
    }

    remove_node(curr);
    free(curr);
    list->head->data--;  // 使用头节点的data域作为size计数
    return true;
}

// 获取链表大小
size_t list_size(const List* list) {
    return list ? (size_t)list->head->data : 0;  // 使用头节点的data域获取size
}

// 判断链表是否为空
bool list_is_empty(const List* list) {
    return list ? list->head->data == 0 : true;  // 使用头节点的data域判断空
}

// 清空链表
void list_clear(List* list) {
    if (list == NULL) {
        return;
    }

    Node* curr = list->head->next;
    while (curr != list->head) {
        Node* next = curr->next;
        free(curr);
        curr = next;
    }

    list->head->next = list->head;
    list->head->prev = list->head;
    list->head->data = 0;  // 重置size为0
}

// 销毁链表
void list_destroy(List* list) {
    if (list == NULL) {
        return;
    }

    list_clear(list);
    free(list->head);
    free(list);
}

// 遍历链表（用于调试）
void list_print(const List* list) {
    if (list == NULL) {
        printf("List is NULL\n");
        return;
    }

    printf("List [size=%d]: ", list->head->data);  // 使用头节点的data域获取size
    for (Node* curr = list->head->next; curr != list->head; curr = curr->next) {
        printf("%d -> ", curr->data);
    }
    printf("HEAD\n");
}

// 验证链表的循环性和双向性（用于调试）
bool list_verify(const List* list) {
    if (list == NULL || list->head == NULL) {
        return false;
    }

    // 检查头节点的循环性
    if (list->head->next->prev != list->head || 
        list->head->prev->next != list->head) {
        return false;
    }

    // 检查所有节点的双向链接
    size_t count = 0;
    for (Node* curr = list->head->next; curr != list->head; curr = curr->next) {
        if (curr->next->prev != curr || curr->prev->next != curr) {
            return false;
        }
        count++;
    }

    // 验证节点计数
    return count == (size_t)list->head->data;  // 使用头节点的data域验证size
}
```

这个实现具有以下特点：

1. 内存安全：
   - 所有内存分配都有错误检查
   - 提供完整的资源清理函数
   - 使用 static 函数限制内部函数的作用域
2. 错误处理：
   - 所有公共函数都进行参数验证
   - 返回布尔值指示操作是否成功
   - 保持数据结构的一致性
3. 基本操作：
   - 头尾插入删除
   - 指定位置插入删除
   - 查找特定值
   - 获取大小和判空
4. 调试支持：
   - 提供打印函数用于调试
   - 提供验证函数检查链表完整性
5. 性能优化：
   - 使用头节点简化边界情况处理
   - 关键操作已抽象为内联函数

主要改动：

1. 移除了 List 结构体中的 size 字段，改用头节点的 data 域存储大小
2. 修改了所有涉及 size 的操作，改为使用 `list->head->data`
3. List 结构体变得更加简洁，只需要存储头节点指针

优化后的好处：

1. 内存使用更有效率：
   - 原来的实现：每个链表需要 sizeof(List) = 16 字节（8字节指针 + 8字节size）
   - 优化后：每个链表只需要 sizeof(List) = 8 字节（仅一个指针）
2. 代码逻辑保持不变，只是改变了 size 的存储位置
3. 没有功能损失，所有操作的时间复杂度保持不变

使用示例:

```c
int main() {
    List* list = list_init();
    if (list == NULL) {
        return 1;
    }

    list_push_back(list, 1);
    list_push_back(list, 2);
    list_push_front(list, 0);

    list_print(list);  // 输出: List [size=3]: 0 -> 1 -> 2 -> HEAD
    assert(list_verify(list));

    list_destroy(list);
    return 0;
}
```



## 总结

### 数组实现的共性

我发现使用数组实现带头节点的链表，无论单向还是双向以及是否为循环链表。使用头节点data域保存链表长度，free管理空闲链表。 那他们在定义上差别不大，初始化空闲链表时，但是free都指向单向链表的头部索引。 差别在他们各自的增删操作上：

共同点：

1. 基础结构：

```c
// 节点结构
typedef struct {
    int data;      // 数据域(头节点复用为size)
    int next;      // 后继索引
    // 双向链表额外增加 int prev
} Node;

// 链表结构
typedef struct {
    Node nodes[MAX_SIZE];
    int head;       // 头节点索引(通常为0)
    int free;       // 空闲链表头指针
} StaticList;       // 可以是单向、双向、循环
```

2. 初始化操作基本相同：

```c
void initList(StaticList* list) {
    // 1. 初始化头节点
    list->head = 0;
    list->nodes[0].data = 0;  // size = 0
    
    // 2. 初始化空闲链表（对所有类型都一样）
    list->free = 1;
    for(int i = 1; i < MAX_SIZE-1; i++) {
        list->nodes[i].next = i + 1;
    }
    list->nodes[MAX_SIZE-1].next = INVALID_IDX;
    
    // 3. 根据链表类型设置头节点的链接关系
    if (单链表) {
        list->nodes[0].next = INVALID_IDX;
    }
    else if (循环单链表) {
        list->nodes[0].next = list->head;
    }
    else if (双向链表) {
        list->nodes[0].next = INVALID_IDX;
        list->nodes[0].prev = INVALID_IDX;
    }
    else if (循环双向链表) {
        list->nodes[0].next = list->head;
        list->nodes[0].prev = list->head;
    }
}
```

主要差别在于增删操作：

1. 单链表的插入：

```c
int insertAfter(StaticList* list, int pos, int data) {
    int newIdx = allocNode(list);
    if(newIdx == INVALID_IDX) return 0;
    
    // 仅需调整一个next指针
    list->nodes[newIdx].data = data;
    list->nodes[newIdx].next = list->nodes[pos].next;
    list->nodes[pos].next = newIdx;
    
    list->nodes[list->head].data++;  // size++
    return 1;
}
```

2. 双向链表的插入：

```c
int insertAfter(StaticList* list, int pos, int data) {
    int newIdx = allocNode(list);
    if(newIdx == INVALID_IDX) return 0;
    
    // 需要调整两个方向的链接
    list->nodes[newIdx].data = data;
    list->nodes[newIdx].next = list->nodes[pos].next;
    list->nodes[newIdx].prev = pos;
    
    // 如果不是插入到末尾，需要更新后继节点的prev
    if(list->nodes[pos].next != INVALID_IDX) {
        list->nodes[list->nodes[pos].next].prev = newIdx;
    }
    list->nodes[pos].next = newIdx;
    
    list->nodes[list->head].data++;  // size++
    return 1;
}
```

3. 循环链表的特殊处理：

- 循环单链表插入时，需要处理尾节点指向头节点的情况
- 循环双向链表插入时，需要同时处理前后两个方向的循环链接

删除操作的差异：

```c
// 单链表删除（需要找前驱）
int deleteNode(StaticList* list, int pos) {
    // 找前驱节点
    int prev = list->head;
    while(prev != INVALID_IDX && list->nodes[prev].next != pos) {
        prev = list->nodes[prev].next;
    }
    if(prev == INVALID_IDX) return 0;
    
    list->nodes[prev].next = list->nodes[pos].next;
    freeNode(list, pos);
    list->nodes[list->head].data--;  // size--
    return 1;
}

// 双向链表删除（直接通过prev找到前驱）
int deleteNode(StaticList* list, int pos) {
    if(pos == list->head) return 0;
    
    list->nodes[list->nodes[pos].prev].next = list->nodes[pos].next;
    if(list->nodes[pos].next != INVALID_IDX) {
        list->nodes[list->nodes[pos].next].prev = list->nodes[pos].prev;
    }
    
    freeNode(list, pos);
    list->nodes[list->head].data--;  // size--
    return 1;
}
```

这种实现方式的巧妙之处在于：

1. 统一了内存管理方式（free链表）
2. 统一了长度管理方式（头节点data域）
3. 使得不同类型链表的实现仅在链接关系处理上有差异
4. 提高了代码复用性，降低了维护成本

这种设计思路在实际工程中很有价值，因为它提供了一个统一的框架，使得代码更容易维护和扩展。

### 指针实现的共性

共同点：

1. 基础结构定义：

```c
// 节点结构
typedef struct Node {
    int data;              // 数据域(头节点复用为size)
    struct Node* next;     // 后继指针
    // 双向链表额外增加 struct Node* prev
} Node;

// 链表结构
typedef struct {
    Node* head;           // 头节点指针
} List;                   // 可以是单向、双向、循环
```

2. 初始化操作相似：

```c
Node* createNode(int data) {
    Node* node = (Node*)malloc(sizeof(Node));
    if(node) {
        node->data = data;
        node->next = NULL;
        // 双向链表还需要 node->prev = NULL
    }
    return node;
}

void initList(List* list) {
    // 创建头节点
    list->head = createNode(0);  // size = 0
    
    // 根据链表类型设置头节点的链接关系
    if (单链表) {
        list->head->next = NULL;
    }
    else if (循环单链表) {
        list->head->next = list->head;
    }
    else if (双向链表) {
        list->head->next = NULL;
        list->head->prev = NULL;
    }
    else if (循环双向链表) {
        list->head->next = list->head;
        list->head->prev = list->head;
    }
}
```

主要差别也在增删操作：

1. 单链表插入：

```c
int insertAfter(Node* pos, int data) {
    Node* newNode = createNode(data);
    if(!newNode) return 0;
    
    // 仅需调整一个next指针
    newNode->next = pos->next;
    pos->next = newNode;
    
    return 1;
}
```

2. 双向链表插入：

```c
int insertAfter(Node* pos, int data) {
    Node* newNode = createNode(data);
    if(!newNode) return 0;
    
    // 需要调整两个方向的链接
    newNode->next = pos->next;
    newNode->prev = pos;
    
    if(pos->next) {
        pos->next->prev = newNode;
    }
    pos->next = newNode;
    
    return 1;
}
```

3. 删除操作：

```c
// 单链表删除（需要找前驱）
int deleteNodeAfter(Node* prev) {
    if(!prev || !prev->next) return 0;
    
    Node* toDelete = prev->next;
    prev->next = toDelete->next;
    free(toDelete);
    return 1;
}

// 双向链表删除（直接通过prev找到前驱）
int deleteNode(Node* node) {
    if(!node || node->prev == NULL) return 0; // 不能删除头节点
    
    node->prev->next = node->next;
    if(node->next) {
        node->next->prev = node->prev;
    }
    
    free(node);
    return 1;
}
```

共同特点：

1. 头节点使用方式相同：
   - data域都可以用来存储链表长度
   - 简化了边界处理
2. 内存管理类似：
   - 统一的节点创建/释放方式
   - 需要注意内存泄漏问题
3. 实现差异主要在于：
   - 链接关系的维护
   - 循环链表的首尾相连处理
   - 双向链表的prev指针维护
4. 主要区别在于：
   - 指针实现需要动态内存管理
   - 没有空闲链表的概念
   - 节点地址不连续，cache不友好
   - 需要处理内存分配失败的情况

这种设计模式的价值在于：

1. 提供了统一的接口和操作模式
2. 简化了边界条件的处理
3. 便于代码维护和扩展
4. 降低了出错概率

在实际工程中，我们往往会根据具体需求选择合适的实现方式：

1. 如果对内存使用有严格要求，选择数组实现
2. 如果需要动态扩展，选择指针实现
3. 如果需要频繁插入删除，考虑双向链表
4. 如果需要循环访问，使用循环链表

不同实现方式的共性思维可以帮助我们：

1. 更好地理解数据结构的本质
2. 写出更统一和优雅的代码
3. 更容易进行代码重构和维护
4. 在不同场景下灵活选择实现方式

### 循环链表的判空和判满以及遍历的区别

带头节点的单向循环，双向循环链表，使用头节点data域存放链表长度信息。

**通用约定**

- **头节点**：头节点的 `data` 域存储链表长度，`next` 域指向第一个有效节点。
- **链表长度计算**：假设 `capacity` 为链表最大容量，`head->data` 为当前长度。

#### **1.单向循环链表**

1.1 判空和判满

- **判空**：`head->data == 0`
- **判满**：`head->data == capacity`

1.2 遍历

- 从 `head->next` 开始依次访问到末尾，再循环回到头节点（`next == head`）。

------

#### 2. **双向循环链表**

2.1 判空和判满

- **判空**：`head->data == 0`
- **判满**：`head->data == capacity`

2.2 遍历

- **正向遍历**：从 `head->next` 开始访问，直至回到头节点（`next == head`）。
- **反向遍历**：从 `head->prev` 开始，逐步访问至头节点。

------

3. **判空与判满的区别**

- **判空**：判断链表是否有元素，即 `head->data == 0`。
- **判满**：判断链表是否达到容量上限，即 `head->data == capacity`。

4. **遍历的区别**

- **单向循环**：只能从头节点沿 `next` 方向遍历。
- **双向循环**：可以正向（`next`）或反向（`prev`）遍历，更灵活。

这两种链表都依赖头节点的 `data` 域来管理长度信息，以实现更优化的数据结构操作。

#### 3.遍历的区别

对于**循环链表**来说，你可以从**任意节点**开始遍历，因为链表是首尾相连的，只要**回到起始位置**就表示遍历完成。

**遍历的要点（循环链表）**

- **任意节点开始**：无论是单向还是双向循环链表，都可以从任意节点出发。
- **遍历结束判断**：当再次回到**起始节点**时（即 `当前节点 == 起始节点`），说明已完成遍历。

**遍历示例：**

**1. 单向循环链表**

```c
void traverse_singly(Node* start) {
    Node* current = start;
    do {
        printf("%d ", current->data);
        current = current->next;
    } while (current != start);  // 回到起始节点时结束
}
```

**2.双向循环链表**

```c
void traverse_doubly(Node* start) {
    Node* current = start;
    do {
        printf("%d ", current->data);
        current = current->next;  // 或 current = current->prev; 反向遍历
    } while (current != start);  // 回到起始节点时结束
}
```

**正向与反向遍历区别（双向循环链表）**

- **正向遍历**：从某节点沿 `next` 方向走，直到回到起始位置。
- **反向遍历**：从某节点沿 `prev` 方向走，直到回到起始位置。

**总结**

- **循环链表的遍历**灵活，可以从**任何节点**出发。
- 遍历结束的标志是：**重新回到起始节点**。
- **双向循环链表**额外支持反向遍历，更加灵活。

## 带头结点的静态链表分析（已验）

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAXSIZE 1000  // 静态链表的最大长度

// 静态链表结点结构
typedef struct {
	int data;           // 数据域
	int next;           // 游标(下一个元素的数组下标)
} StaticListNode;



// 静态链表结构，这个只会初始化一次，而节点是使用时才申请，初始化多次
typedef struct {
	StaticListNode node[MAXSIZE];  // 结点数组，最多有100个节点，包括头节点
	int length;                    // 当前链表长度
	int free;                     // 空闲链表中第一个结点的下标，管理空闲链表
} StaticLinkedList;



// 初始化静态链表
//传递一个实例化后的链表起始地址
void initList(StaticLinkedList* L) {
	// 初始化长度为0
	L->length = 0;
	
	//初始化空闲链表
	//将所有结点连接成空闲链表
	//指向链表节点数组下标即可
	for (int i = 0; i < MAXSIZE - 1; i++) {
		L->node[i].next = i + 1;
	}
	// 最后一个结点的next为-1，没有指向节点了，直接指向一个特殊值表示为最后一个空闲节点
	//节点数组下标没有-1的，所以-1确实可以用来代表无指向。
	L->node[MAXSIZE-1].next = -1; 
	// 设置空闲链表的起始位置（跳过头节点（节点数组下标零）），真的从数组中让出一个位置给哨兵节点
	//至此空闲链表有了形状，通过下标彼此连接
	L->free = 1;
	
	//初始化有效链表的头节点
	// 从空闲链表中取节点在数组中下标为0的节点出来初始化为头节点
	// 空链表，头节点指向-1,数组没有下标-1可以作为空或者结束表示
	L->node[0].next = -1;
}



// 分配空闲结点，从空闲链表中取出节点，只操作空闲链表返回空闲节点位置以及更新free指向
int malloc_ssl(StaticLinkedList* L) {
	//获取空闲链表的第一个节点位置，free为节点在空闲链表中的物理位置（数组下标）
	int i = L->free;
	// 没有空闲节点了
	if (i == -1) {  
		printf("Error: No free nodes available in static linked list!\n");
		return -1;
	}
	
	if (i > 0) {  // i必须大于0，因为0是头节点
		//更新free指针，操作的是都是节点数组，使用free来管理
		//刚开始所有的节点数组都是可用的，所以不用怕
		L->free = L->node[i].next;  // 更新空闲链表的首节点
	} else {
		printf("Error: Invalid free node index!\n");//不是大于0又不是-1就是出错了
		return -1;
	}
	return i;
}



// 回收结点到空闲链表，只操作空闲链表，直接头插法修改指向就行
//传递进来一个链表地址，和回收节点在节点数组的物理下标
void free_ssl(StaticLinkedList* L, int k) {
	//k为有效节点在数组中的下标，一定大于0，小于数组最大边界
	if (k <= 0 || k >= MAXSIZE) {
		printf("Error: Invalid node index for recycling!\n");
		return;
	}
	
	//头插法，空闲链表的第一个连接在新回收节点的后面
	L->node[k].next = L->free;
	//连接后好，再更新free指针，否者空闲链表会断链
	L->free = k;
}



bool insertAfter(StaticLinkedList* L, int position, int e) {
	// 检查位置合法性
	if (position < 0 || position > L->length) {
		printf("Error: Invalid position for insertion!\n");
		return false;
	}
	
	// 分配新节点
	int newNodeIndex = malloc_ssl(L);
	if (newNodeIndex == -1) {
		printf("Error: No free nodes available!\n");
		return false;
	}
	
	// 找到要插入位置的实际节点，找到那个序号位置的节点
	int current = 0;  // 从头结点开始
	for (int i = 0; i < position; i++) {
		//position为3，从第0个节点开始，在第三个节点位置后面插入，先找到第三个节点
		//看程序i到2时，已经找到第三个节点了
		current = L->node[current].next;
	}
	
	//position为0时，在头节点后插入成为新的第一个有效节点
	//current也为0，可以在成功在头节点后插入
	
	// 插入新节点
	//防止断链，先修改新节点指向，再修改旧节点指向
	L->node[newNodeIndex].data = e;
	L->node[newNodeIndex].next = L->node[current].next;
	L->node[current].next = newNodeIndex;
	
	L->length++;
	return true;
}



//删除序号i节点之后的节点
bool deleteAfter(StaticLinkedList* L, int position) {
	//序号0之后即删除第一个有效节点，所以0可以取到
	//有效链表的最后一个节点后面是没有节点的，所以最后一个节点的序号是不能取的
	//而length代表有效节点的个数，也可以表示最后一个节点的序号
	if (position < 0 || position >= L->length ) return false;
	
	//除了最后一个序号之后不能删除，其他节点之后都可以删除
	//找到要删除序号的实际节点，再删除此节点后面的节点
	int current = 0;  // 从头结点开始
	for (int i = 0; i < position; i++) {
		current = L->node[current].next;
	}
	
	//跳过要删除的节点位置即可，修改next即可
	//拿到删除节点的物理数组下标
	int temp = L->node[current].next;
	// 跳过要删除的结点
	L->node[current].next = L->node[temp].next;
	
	//直接回收结点下标
	free_ssl(L, temp); 
	
	L->length--;
	return true;
}


//要的是逻辑序号，而不是节点数组中的物理下标
int findValue(StaticLinkedList* L, int e) {
	int current = 0;  // 从头结点开始
	int position = 0;  // 逻辑序号
	
	//从头节点开始但是不从头节点比较啊
	while (L->node[current].next != -1) {
		current = L->node[current].next;
		position++;
		
		if (L->node[current].data == e) {
			return position;  // 返回逻辑序号
		}
	}
	
	return -1;  // 未找到
}



// 获取链表序号位置为i的元素值（获取节点值的话，序号从1开始，0号被拿去当作头节点了！）
//为了与前面一致，序号依旧从0开始
//传递进来一个目标序号，增删之后，下标不一定代表节点序号，需要计数器！！！
bool getValue(StaticLinkedList* L, int position, int* e) {
	//序号的校验，序号为i的节点，
	//length为有效节点的个数，
	//position为0，是头节点没有值，直接返回！
	if (position < 1 || position > L->length) return false;
	
	//序号经过校验之后，我能保证一定能拿到某一个序号节点的元素值
	//从头头节点开始遍历,知道序号为position的节点
	int current = 0;  // 从头结点开始
	for (int i = 0; i < position; i++) {
		current = L->node[current].next;
	}
	
	*e = L->node[current].data;//通过解引用修改地址中的值,只能出此下策，因为返回操作状态，所以值单独用地址带出去
	return true;
}



// 打印链表
void printList(StaticLinkedList* L) {
	printf("List: ");
	//取第一个有效节点
	int i = L->node[0].next;
	//空的话直接跳出了，不然就是遍历到有效链表的最后一个节点
	while (i != -1) {
		//打印每一个节点的数据域
		printf("%d ", L->node[i].data);
		//直接不断利用节点的后继指针去赋值i即可，不用i++,而且i++还找不到节点呢！
		i = L->node[i].next;
	}
	printf("\nLength（不包括头节点）: %d\n", L->length);
}

// 使用示例
int main() {
	//实例化一个链表（开空间）
	StaticLinkedList list;
	
	//初始化链表
	initList(&list);
	
	// 插入测试
	insertAfter(&list, 0, 10);  // 在头节点后插入10
	insertAfter(&list, 0, 20);  // 在头节点后插入20（会排在10前面）
	insertAfter(&list, 0, 30);  // 在头节点后插入30
	printf("插入三个元素后：\n");
	printList(&list);
	
	// 查找测试
	int pos = findValue(&list, 20);
	printf("值为20的元素序号（从序号0开始）：%d\n", pos);
	
	// 获取元素测试
	int value; // 即使未初始化也没关系，因为getValue一定会给它赋值，如果确定变量会被赋新值，那么初始值不是必需的
	if (getValue(&list, 2, &value)) {
		printf("节点序号为2的元素值：%d\n", value);
	}
	
	// 删除测试
	deleteAfter(&list, 0);  // 删除第一个有效节点
	printf("删除第一个有效节点后：\n");
	printList(&list);
	
	return 0;
}
```

### insertAfter函数问题

**我在设计"在位置i（从0开始）之后插入元素e",遇到了一个问题：增删之后，下标不一定代表节点序号，是不是需要计数器遍历而不是直接使用下标？？？**

您提出了一个非常好的观点。在静态链表中，下标确实不总是直接对应节点的实际位置。对于插入操作，您需要通过遍历链表来找到正确的插入位置。

- 从头结点(下标0)开始遍历

- 使用 `for` 循环精确定位到指定位置的节点

- 当 `position = 0` 时，实际上是在头结点后插入第一个有效节点

**这个position和合法性判断条件的由来？**

1. 对于带头结点的静态链表，结构是这样的：
   - 下标0是头结点
   - 头结点的 `next` 指向第一个实际数据节点
   - 实际有效数据节点从下标1开始
2. `position`的定义：
   - `position = 0` 表示在第一个有效节点之前插入（实际上是在头结点之后）
   - `position = 1` 表示在第一个有效节点之后插入
   - 以此类推
3. 合法性判断条件 `position < 0 || position >= L->length`
   - `position < 0` 防止负数下标
   - `position > L->length` 防止超出当前链表的有效节点数
     - `length` 记录的是有效节点的个数，那么 `position` 确实可以等于 `length`。这意味着允许在链表末尾追加新节点。
     - 使用严格的不等式 `>` 而不是 `>=`，确保插入位置不会超出当前链表的范围

这个设计保证了：

- 可以在任何有效节点位置之后插入
- 不会访问超出当前链表范围的位置
- 提供了灵活的插入方式

```c
头结点(0) -> 第1个节点 -> 第2个节点 -> ... -> 第n个节点
           ↑position=0   ↑position=1  ↑position=2
```

#### 实现

```c
bool insertAfter(StaticLinkedList* L, int position, int e) {
	// 检查位置合法性
	if (position < 0 || position > L->length) {
		printf("Error: Invalid position for insertion!\n");
		return false;
	}
	
	// 分配新节点
	int newNodeIndex = malloc_ssl(L);
	if (newNodeIndex == -1) {
		printf("Error: No free nodes available!\n");
		return false;
	}
	
	// 找到要插入位置的实际节点，找到那个序号位置的节点
	int current = 0;  // 从头结点开始
	for (int i = 0; i < position; i++) {
		current = L->node[current].next;
	}
	
	// 插入新节点
	//防止断链，先修改新节点指向，再修改旧节点指向
	L->node[newNodeIndex].data = e;
	L->node[newNodeIndex].next = L->node[current].next;
	L->node[current].next = newNodeIndex;
	
	L->length++;
	return true;
}
```

- 头节点之后
  - position为0时，在头节点后插入成为新的第一个有效节点
  - current也为0，可以在成功在头节点后插入
- 其他位置
  - position为3，从序号为0的头节点开始，在序号为3的节点位置后面插入，先找到序号为3的节点
  - 0-1-2-3，这是逻辑上的序号，与物理下标没有一点关系。增删之后，下标不一定代表序号了。
  - i = 0时，current已经指到序号为1的节点了，可以看程序：循环i到2时，已经找到序号为3的节点了
- 在链表尾部添加新节点
  - 根据有效节点个数length，就可以通过循环拿到最后一个节点的位置
  - length为6时，除开头节点，有效节点个数为6。position为6即在序号为6的节点（实际上就是最后一个节点位置）后插入。
  - 当循环i=5时，current就是序号为6的节点，可以完成插入！

### deleteAfter函数实现

```c
//删除序号i节点之后的节点
bool deleteAfter(StaticLinkedList* L, int position) {
	//序号0之后即删除第一个有效节点，所以0可以取到
	//有效链表的最后一个节点后面是没有节点的，所以最后一个节点的序号是不能取的
	//而length代表有效节点的个数，也可以表示最后一个节点的序号
	if (position < 0 || position >= L->length ) return false;
	
	//除了最后一个序号之后不能删除，其他节点之后都可以删除
	//找到要删除序号的实际节点，再删除此节点后面的节点
	int current = 0;  // 从头结点开始
	for (int i = 0; i < position; i++) {
		current = L->node[current].next;
	}
	
	//跳过要删除的节点位置即可，修改next即可
	//拿到删除节点的物理数组下标
	int temp = L->node[current].next;
	// 跳过要删除的结点
	L->node[current].next = L->node[temp].next;
	
	//直接回收结点下标
	free_ssl(L, temp); 
	
	L->length--;
	return true;
}
```

您的实现看起来非常好！让我分析一下代码的细节：

1. 边界条件判断非常准确：
   - `position < 0`：防止负数下标
   - `position >= L->length`：防止删除不存在的节点之后的节点
2. 遍历方式正确：
   - 从头结点开始
   - 精确定位到指定序号的节点
3. 删除操作逻辑清晰：
   - 保存要删除节点的下标
   - 修改前一个节点的 `next` 指针
   - 回收被删除节点
   - 减少链表长度
4. 特殊情况处理：
   - 可以删除第一个有效节点（`position = 0`）

唯一需要注意的是边界情况：

- 如果链表为空（`length = 0`），也会返回 `false`

代码看起来逻辑严密，我没有发现明显的边界问题。这是一个非常好的实现！

### getValue函数的实现

```c
// 获取链表序号位置为i的元素值（获取节点值的话，序号从1开始，0号被拿去当作头节点了！）
//为了与前面一致，序号依旧从0开始
//传递进来一个目标序号，增删之后，下标不一定代表节点序号，需要计数器！！！
bool getValue(StaticLinkedList* L, int position, int* e) {
	//序号的校验，序号为i的节点，
	//length为有效节点的个数，
	//position为0，是头节点没有值，直接返回！
	if (position < 1 || position > L->length) return false;
	
	//序号经过校验之后，我能保证一定能拿到某一个序号节点的元素值
	//从头头节点开始遍历,知道序号为position的节点
	int current = 0;  // 从头结点开始
	for (int i = 0; i < position; i++) {
		current = L->node[current].next;
	}
	
	*e = L->node[current].data;//通过解引用修改地址中的值,只能出此下策，因为返回操作状态，所以值单独用地址带出去
	return true;
}
```

这个实现：

- 保证不会访问头节点
- 正确遍历到指定序号的节点
- 通过 `current` 获取正确的节点值

### findValue函数的设计问题

这个函数是不是设计的不合理？其实数组节点的物理下标没有用，应该是逻辑上的序号。

```c
// 查找值为e的元素，返回其位置，返回的值物理下标，其实我们要的是逻辑上的序号，这样我们就可以通过函数再一次找到它
int findValue(StaticLinkedList* L, int e) {
	// 从第一个有效结点开始
	int i = L->node[0].next;
	
	//有效链表不为空且值不匹配的情况下，一开始为空的话就直接返回了
	//其实有效链表和空闲链表始终都是在操作node[]数组，只不过使用头节点，free和后继指针把它区分为有效链表和空闲链表
	while (i != -1 && L->node[i].data != e) {
		//一直遍历完没找到也会返回-1，中间找到了就直接跳出循环返回位置了
		//有效链表的最后一个节点的后继指针是指向-1的，没找到必会返回
		i = L->node[i].next;
	}
	return i;  // 找到返回位置，未找到返回-1
}
```

改进：

1. 引入 `position` 记录逻辑序号
2. 从头结点开始遍历
3. 每次移动 `current`，`position` 自增
4. 找到匹配值时返回逻辑序号
5. 未找到返回 -1

这样设计更加合理，因为：

- 返回的是逻辑序号
- 可以直接用于其他需要序号的函数
- 屏蔽了物理下标的复杂性

```c
//要的是逻辑序号，而不是节点数组中的物理下标
int findValue(StaticLinkedList* L, int e) {
	int current = 0;  // 从头结点开始
	int position = 0;  // 逻辑序号
	
	//从头节点开始但是不从头节点比较啊
	while (L->node[current].next != -1) {
		current = L->node[current].next;
		position++;
		
		if (L->node[current].data == e) {
			return position;  // 返回逻辑序号
		}
	}
	
	return -1;  // 未找到
}
```

## 带头结点的动态链表分析(已验)

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


// 定义链表节点结构
typedef struct Node {
	int data;               // 数据域
	struct Node* next;      // 指针域,结构体自嵌套，指向node类型数据的指针
} Node;


// 定义链表结构(包含头节点指针和当前长度)
typedef struct {
	Node* head;            // 头节点指针
	int length;            // 链表当前长度
} LinkedList;


// 初始化链表（返回值是一个链表类型的指针地址，一个链表结构体空间的起始地址）
LinkedList* initList() {
	//实例化链表分配空间
	LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));
	if (!list) {
		return NULL;    // 内存分配失败
	}
	
	// 创建有效链表的头节点
	list->head = (Node*)malloc(sizeof(Node));
	//看分配的头节点是否成功
	if (!list->head) {
		free(list);//如果头节点分配失败，那就把分配的链表也释放
		return NULL;
	}
	
	list->head->next = NULL;//初始化有效链表为空，因为头节点的next指向为空
	list->length = 0;
	return list;
}



// 在指定位置后插入元素，序号从0开始，要把理念贯彻
bool insertAfter(LinkedList* list, int position, int value) {
	// 检查位置合法性：0 ~ length（允许在末尾插入）
	if (!list || position < 0 || position > list->length) {
		return false;
	}
	
	// 创建新节点
	Node* newNode = (Node*)malloc(sizeof(Node));
	if (!newNode) {
		return false;
	}
	//给新节点的数据域赋值
	newNode->data = value;
	
	// 从头节点开始找插入位置前的节点
	//从头节点开始变量找
	Node* current = list->head;
	
	// 因为从0开始，所以直接移动position次
	//i=0时，current已经指向序号为1的节点了，从0开始
	//position为0时直接开插
	for (int i = 0; i < position; i++) {
		current = current->next;
	}
	
	// 插入节点，先解决新节点的指向，再看旧节点
	newNode->next = current->next;
	current->next = newNode;
	list->length++;
	return true;
}



// 删除指定序号之后的节点（只能删除现有节点，不能删除最后一个节点之后）
bool deleteAfter(LinkedList* list, int position) {
	// 检查位置合法性：0 ~ length-1
	if (!list || position < 0 || position >= list->length) {
		return false;
	}
	
	// 找到要删除节点的前一个节点，还是从头节点开始
	Node* current = list->head;
	
	// 因为从0开始，所以直接移动position次
	for (int i = 0; i < position; i++) {
		current = current->next;
	}
	
	// 删除节点并释放内存
	Node* temp = current->next;
	current->next = temp->next;
	free(temp);
	list->length--;
	return true;
}



// 从0开始，但过滤头节点，获取指定位置的值
bool getValue(LinkedList* list, int position, int* value) {
	// 位置检查：0 ~ length
	if (!list || position < 1 || position > list->length) {
		return false;
	}
	
	Node* current = list->head;
	// 遍历 position 次，实际是找第 position+1 个节点
	for (int i = 0; i < position; i++) {
		current = current->next;
	}
	
	*value = current->data;
	return true;
}



// 修改指定位置的节点值，过滤掉头节点
bool updateNode(LinkedList* list, int position, int value) {
	if (!list || position < 1 || position > list->length) {
		return false;
	}
	
	Node* current = list->head;
	// 遍历 position 次，实际是找第 position+1 个节点
	for (int i = 0; i < position; i++) {
		current = current->next;
	}
	
	current->data = value;//找到位置后直接修改值
	return true;
}



// 查找值为value的第一个节点的位置,找到就返回
int findValue(LinkedList* list, int value) {
	if (!list || list->length == 0) {
		return -1;
	}
	
	//从头节点开始但是不从头节点比较啊
	Node* current = list->head->next;
	int position = 1;
	
	//遍历到最后一个节点后会自动跳出
	while (current) {
		//从第一个有效节点开始比较
		if (current->data == value) {
			return position;
		}
		current = current->next;
		position++;
	}
	
	return -1;  // 未找到
}



// 遍历打印链表
void printList(LinkedList* list) {
	if (!list) {
		printf("链表不存在\n");
		return;
	}
	
	if (list->length == 0) {
		printf("链表为空\n");
		return;
	}
	
	Node* current = list->head->next;
	printf("链表内容: ");
	//不为空的话，会一直遍历到最后一个节点
	while (current) {
		printf("%d ", current->data);
		current = current->next;
	}
	printf("\n长度: %d\n", list->length);
}



// 销毁链表并释放内存
void destroyList(LinkedList* list) {
	if (!list) {
		return;
	}
	
	// 释放所有数据节点，从第一个有效节点开始逐个释放
	Node* current = list->head->next;
	while (current) {
		//使用临时变量，不断链
		Node* temp = current;
		current = current->next;
		free(temp);
	}
	
	// 单独释放头节点和链表结构
	free(list->head);//释放头节点的空间
	free(list);//释放链表结构：长度信息和头节点指针本身空间
}



// 判断链表是否为空
bool isEmpty(LinkedList* list) {
	return list ? list->length == 0 : true;
}



// 反转链表
bool reverseList(LinkedList* list) {
	if (!list || list->length <= 1) {//反转至少有两个有效节点才有意义，不包括头节点
		return false;
	}
	
	Node* prev = NULL;
	Node* current = list->head->next;//反转也只是反转有效节点，头节点不动
	Node* next = NULL;
	
	while (current) {
		next = current->next;     // 保存下一个节点
		current->next = prev;     // 反转指针
		prev = current;           // 移动prev指针
		current = next;           // 移动current指针
	}
	
	list->head->next = prev;     // 更新头节点指向
	return true;
}



// 示例使用
int main() {
	// 初始化链表
	LinkedList* list = initList();
	if (!list) {
		printf("链表初始化失败\n");
		return 1;
	}
	
	// 添加节点
	//在头节点后插入成为第一个有效节点
	insertAfter(list,0,10);
	insertAfter(list,0,20);
	printList(list);
	
	//在尾巴节点插入成为最后一个新节点
	insertAfter(list,list->length,30);
	printList(list);
	
//	//删除头节点后的节点
//	deleteAfter(list,0);
//	printList(list);
	
	int value;
	//获取指定位置的值
	getValue(list,1,&value);
	printf("%d\n",value);
	
	//修改指定位置的值
	updateNode(list,1,100);
	printList(list);
	
	//找值返回位置
	printf("位置：%d\n",findValue(list,30));
	
	//判断空链表
	printf("是否空链%d\n",isEmpty(list));
	
	//翻转链表
	reverseList(list);
	printList(list);
	
	
	// 清理资源
	destroyList(list);
	return 0;
}
```

### 静态链表和动态链表开空间的差别

静态链表和动态链表在实例化方式上确实存在差异，主要是因为它们的内存分配机制不同：

1. 静态链表（数组实现）

```c
//实例化一个链表（开空间）// 直接定义，已经分配了固定大小的数组空间
	StaticLinkedList list;

//初始化链表
	initList(&list);

// 初始化静态链表
//传递一个实例化后的链表起始地址
void initList(StaticLinkedList* L) {
	// 初始化长度为0
	L->length = 0;
	
	//初始化空闲链表
	//将所有结点连接成空闲链表
	//指向链表节点数组下标即可
	for (int i = 0; i < MAXSIZE - 1; i++) {
		L->node[i].next = i + 1;
	}
	// 最后一个结点的next为-1，没有指向节点了，直接指向一个特殊值表示为最后一个空闲节点
	//节点数组下标没有-1的，所以-1确实可以用来代表无指向。
	L->node[MAXSIZE-1].next = -1; 
	// 设置空闲链表的起始位置（跳过头节点（节点数组下标零）），真的从数组中让出一个位置给哨兵节点
	//至此空闲链表有了形状，通过下标彼此连接
	L->free = 1;
	
	//初始化有效链表的头节点
	// 从空闲链表中取节点在数组中下标为0的节点出来初始化为头节点
	// 空链表，头节点指向-1,数组没有下标-1可以作为空或者结束表示
	L->node[0].next = -1;
}
```

- 静态链表通常使用数组预先分配固定大小的空间

- 数组在编译时已经分配好内存

- 不需要额外的内存分配操作

- 空间大小在定义时就已确定

2. 动态链表（指针实现）

```c
// 初始化链表，空间都是手动创建申请，
	LinkedList* list = initList();

LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));  // 需要手动分配内存
```

- 动态链表使用指针和动态内存分配

- 需要使用malloc()或new显式分配内存空间

- 分配的内存需要后续手动管理和释放

- 提供更灵活的内存使用方式

关键区别：

- 静态链表：空间固定、**一次性**分配
- 动态链表：需要手动分配和释放内存
- 静态链表实例化更简单直接
- 动态链表实例化需要显式内存管理

选择建议：

- 数据量确定：静态链表
- 数据量不确定：动态链表
- C语言使用malloc和free

#### 开空间并初始化

```c
// 初始化链表（返回值是一个链表类型的指针地址，分配空间的起始地址）
LinkedList* initList() {
	//实例化链表分配空间
	LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));
	if (!list) {
		return NULL;    // 内存分配失败
	}
	
	// 创建有效链表的头节点
	list->head = (Node*)malloc(sizeof(Node));
	//看分配的头节点是否成功
	if (!list->head) {
		free(list);//如果头节点分配失败，那就把分配的链表也释放
		return NULL;
	}
	
	list->head->next = NULL;//初始化有效链表为空，因为头节点的next指向为空
	list->length = 0;
	return list;
}
```

你的代码展示了一种常见的动态链表初始化方式，需要手动为链表结构体和头节点分配空间。这种方式在C语言中是典型的实现。

1.为链表结构体分配空间

```c
LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));
```

- 分配整个链表结构体的内存空间

- 使用malloc分配

- 需要检查内存分配是否成功

2.为头节点分配空间

```c
list->head = (Node*)malloc(sizeof(Node));
```

- 为头节点单独分配内存

- 头节点通常是一个**不存储实际数据的特殊节点**

- 用于简化链表操作，作为链表的起始标记

3.初始化操作

```c
list->head->next = NULL;  // 初始化为空链表
list->length = 0;//不算头节点，有效节点初始为0
```

- 设置头节点的next指针为NULL
- 初始化链表长度为0

**其实分配整个链表结构体的内存空间，也就是开辟了两个空间而已，一个是头节点的指针，用于指向第一个有效节点的地址，一个是表示链表长度的变量而已，后面需要增加节点时，直接malloc节点结构体即可，这就是动态的好处，随时用随时开空间？**

是的,你完全正确! 这种设计体现了动态链表的精髓:

**链表结构体很轻量**

```c
typedef struct {
    Node* head;     // 头节点指针 
    int length;     // 链表当前长度
} LinkedList;
```

只包含两个核心信息:

- 头节点指针(指向第一个有效节点),8字节用来存放第一个有效节点的地址而已。
- 链表当前长度

**节点的动态分配**

```c
// 添加节点时随时malloc
Node* newNode = (Node*)malloc(sizeof(Node));
```

- 需要节点时立即分配内存
- 不需要时可以立即释放
- 空间利用灵活

**动态链表的优势**

- 内存使用更加灵活
- 可以根据实际需求动态增删节点
- 不像静态链表需要预先分配固定大小空间
- 内存分配和释放由程序员完全控制

这正是动态链表最大的特点 - 动态、灵活的内存管理!

### insertAfter函数动态实现

[跟静态的对比，理念不变](###insertAfter函数问题)。

```c
// 在指定位置后插入元素，序号从0开始
bool insertNode(LinkedList* list, int position, int value) {
    // 检查位置合法性：0 ~ length（允许在末尾插入）
    if (!list || position < 0 || position > list->length) {
        return false;
    }

    // 创建新节点
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (!newNode) {
        return false;
    }
    //给新节点的数据域赋值
    newNode->data = value;

    // 从头节点开始找插入位置前的节点
    //从头节点开始变量找
    Node* current = list->head;
    
    // 因为从0开始，所以直接移动position次
    //i=0时，current已经指向序号为1的节点了，从0开始
    //position为0时直接开插
    for (int i = 0; i < position; i++) {
        current = current->next;
    }

    // 插入节点，先解决新节点的指向，再看旧节点
    newNode->next = current->next;
    current->next = newNode;
    list->length++;
    return true;
}
```

这样的实现：

- 支持从0开始插入（头节点后）
- 支持在任意位置插入，包括末尾
- 保持了链表长度不包含头节点的设计理念

插入示例：

- `position = 0`：在第一个有效节点前插入
- `position = list->length`：在链表末尾插入
- 其他位置：在指定位置后插入

### deleteAfter函数动态实现

```c
// 删除指定序号之后的节点（只能删除现有节点，不能删除最后一个节点之后）
bool deleteNode(LinkedList* list, int position) {
    // 检查位置合法性：0 ~ length-1
    if (!list || position < 0 || position >= list->length) {
        return false;
    }

    // 找到要删除节点的前一个节点，还是从头节点开始
    Node* current = list->head;
    
    // 因为从0开始，所以直接移动position次
    for (int i = 0; i < position; i++) {
        current = current->next;
    }

    // 删除节点并释放内存
    Node* temp = current->next;
    current->next = temp->next;
    free(temp);
    list->length--;
    return true;
}
```

- 不允许删除超出链表长度的位置

- 最后一个节点的位置是 `list->length - 1`

删除示例：

- `position = 0`：删除第一个有效节点
- `position = list->length - 1`：删除最后一个有效节点
- 不能删除 `list->length` 位置的节点

这样的实现保持了你原有的设计理念：

- 支持从0开始删除
- 不能删除不存在的节点
- 链表长度不包含头节点

### getValue函数动态实现

```c
// 从0开始，但过滤头节点
bool getNodeValue(LinkedList* list, int position, int* value) {
	// 位置检查：0 ~ length
	if (!list || position < 1 || position > list->length) {
		return false;
	}
	
	Node* current = list->head;
	// 遍历 position 次，实际是找第 position+1 个节点
	for (int i = 0; i < position; i++) {
		current = current->next;
	}
	
	*value = current->data;
	return true;
}
```

关键点：

1. 位置范围：0 ~ length
2. 从头节点开始遍历
3. 遍历 position 次，实际找到第 position+1 个节点
4. 完美体现了从0开始的理念

举例：

- position=0 找第一个有效节点(**被过滤了。。。**)
- position=length找最后一个有效节点
  - i=0,current指向1
  - i=1,
  - i=length-1,current指向length
  - 而i比position小1

这种设计既保持了从0开始的一致性，又优雅地过滤了头节点。很棒的实现！

### updateNode函数实现

```c
// 修改指定位置的节点值，过滤掉头节点
bool updateNode(LinkedList* list, int position, int value) {
	if (!list || position < 1 || position > list->length) {
		return false;
	}
	
	Node* current = list->head;
	// 遍历 position 次，实际是找第 position+1 个节点
	for (int i = 0; i < position; i++) {
		current = current->next;
	}
	
	current->data = value;//找到位置后直接修改值
	return true;
}
```

### 判空三目运算符

**这个三目表达式没看懂啊？**

```c
bool isEmpty(LinkedList* list) {
    return list ? list->length == 0 : true;
}
```

这个 `return list ? list->length == 0 : true;` 相当于以下 if-else 结构：

```c
bool isEmpty(LinkedList* list) {
    if (list == NULL) {      // 如果链表不存在
        return true;         // 返回true（认为空指针也是空链表）
    } else {                 // 如果链表存在
        return list->length == 0;  // 返回length是否为0的判断结果
    }
}
```

拆解三目运算符 `?:` 的判断逻辑：`list ?`

 首先判断list指针是否为NULL

- 如果list不是NULL，执行 `:`前面的表达式：`list->length == 0`
- 如果list是NULL，执行 `:`后面的表达式：`true`

`list->length == 0`

 判断链表长度是否为0

- 如果length为0，返回true（空链表）
- 如果length不为0，返回false（非空链表）

所以这个函数有两种情况会返回true：

1. 链表指针为NULL（不存在的链表视为空）
2. 链表存在但length为0（真正的空链表）

### 翻转链表实现

#### 三指针实现翻转

```c
// 反转链表
bool reverseList(LinkedList* list) {
	if (!list || list->length <= 1) {//反转至少有两个有效节点才有意义，不包括头节点
		return false;
	}
	
	Node* prev = NULL;
	Node* current = list->head->next;//反转也只是反转有效节点，头节点不动
	Node* next = NULL;
	
	while (current) {
		next = current->next;     // 保存下一个节点
		current->next = prev;     // 反转指针
		prev = current;           // 移动prev指针
		current = next;           // 移动current指针
	}
	
	list->head->next = prev;     // 更新头节点指向
	return true;
}
```

这样的实现方式比通用的链表翻转还要更简单一些,因为:

1. 不用考虑空链表
2. 不用考虑单节点情况
3. 头节点的存在让指针操作更统一

**基本思路**：

- 使用三个指针（prev, current, next）遍历链表
- 每次遍历改变一个节点的指向
- 同时保持链表的连续性不断开

**关键步骤解析**：

```c
Node* prev = NULL;     // 前一个节点，初始为NULL
Node* current = list->head->next;  // 当前节点，从第一个有效节点开始
Node* next = NULL;     // 下一个节点，用于临时保存
```

**循环过程中的操作**：

- `next = current->next;` // 保存下一个节点，防止链表断开
- `current->next = prev;` // 反转当前节点的指针
- `prev = current;` // 移动prev到当前位置
- `current = next;` // 移动current到下一个位置

**时间复杂度**：

- O(n)，其中n是链表长度
- 只需要遍历一次链表

**空间复杂度**：

- O(1)，只使用了三个指针变量

**需要注意的细节：**

1. 头节点始终不动，只改变其next指针
2. 最后一个节点的next要指向NULL
3. 要保证在反转过程中不会断链
4. 反转完成后要更新头节点的next指针指向新的首节点

**这个设计的优点是：**

- 原地反转，不需要额外空间
- 操作简单清晰，容易实现
- 对大规模数据依然高效

#### 示意图

![image-20241122094410902](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录5之必要的数据结构.assets\image-20241122094410902.png)

![image-20241122094633142](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录5之必要的数据结构.assets\image-20241122094633142.png)

#### 单指针翻转

实际上确实可以简化成只用一个中间指针。因为在翻转过程中我们主要关心的是"当前正在处理的节点"应该指向谁。

```c
bool reverseList(LinkedList* list) {
    if (!list || list->length <= 1) {
        return false;
    }
    
    Node* current = list->head->next;  // 第一个有效节点开始
    Node* temp;                        // 只需要一个中间指针
    
    //先处理第一个特殊有效节点
    // 先把第一个节点的next置为NULL,翻转后它是最后一个节点，它的next一定是null
    //current为当前处理的节点，除开第一个有效节点，其他统统挂到前一个节点的后面
    temp = current->next;
    current->next = NULL;
    
    // 开始翻转
    while (temp) {
        // temp指向下一个要处理的节点，后面还一大串要处理的节点链
        //挂接之前已经把下一个要处理的位置保存了，不怕丢失！
        Node* next = temp->next;  // 保存下一个节点
        temp->next = current;     // 当前节点指向前一个节点（挂到前面节点的后面）
        current = temp;           // 更新current
        temp = next;              // 移动到下一个要处理的节点
    }
    
    // 最后更新头节点指向
    list->head->next = current;
    return true;
}
```

主要改进：

1. 只使用一个中间指针temp
2. **先处理第一个节点的特殊情况（指向NULL）**
3. **后续节点统一处理方式：保存下一个->改变指向->移动指针**

这种方式的优点：

1. 代码更简洁
2. 空间复杂度依然是O(1)
3. 逻辑更清晰：每次就是把temp指向的节点插入到已翻转部分的前面

这种方式的精妙之处在于：

- 把复杂的问题简化为"不断把节点挂到已处理部分前面"
  - 相当于不断把当前节点current挂接到temp（下一个要处理的节点）的后面。
  - 然后移动current和temp的位置。
- 第一个节点指向NULL，自然形成了最终链表的尾部
- 每次操作都是在处理单个节点，不用考虑其它节点的状态

#### 示意图

![image-20241122111813098](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录5之必要的数据结构.assets\image-20241122111813098.png)

![image-20241122111846160](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录5之必要的数据结构.assets\image-20241122111846160.png)

![image-20241122111938468](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录5之必要的数据结构.assets\image-20241122111938468.png)

#### 两者对比

![image-20241122101050409](C:\Users\admin\Desktop\个人博客\C语言学习笔记\C语言学习记录5之必要的数据结构.assets\image-20241122101050409.png)

单指针方式更容易理解的原因：

1. 思维负担更小
   - 三指针：需要同时跟踪prev、current、next的位置
   - 单指针：只需关注temp指向的待处理节点
2. 操作更直观
   - 三指针：需要理解四步操作的顺序(保存next、改指向、移动prev、移动current)
   - 单指针：就两个动作(把temp节点放到前面、temp指向下一个待处理)
3. 状态更清晰
   - 三指针：链表被分成了三部分(已处理、当前、未处理)
   - 单指针：链表只分两部分(已处理、待处理)，更简单
4. 类比更形象
   - **单指针的方式就像是在"摘"节点，每次摘一个放到已处理部分的前面**
   - 这种物理意义上的类比更容易理解

虽然两种方法的实际执行效果是一样的，但单指针方式在理解和记忆上确实更有优势。特别是对初学者来说，"每次处理一个节点，把它放到已处理部分的前面"这种思路更容易掌握。

不过需要注意的是，三指针方式在某些情况下可能更灵活，比如如果需要在翻转过程中进行一些额外的节点操作，三指针方式可能会提供更多的操作空间。但如果就是单纯的翻转，单指针方式确实更清晰。
