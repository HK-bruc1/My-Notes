# 项目总结

**外设人家不一定接触过，所以只有业务逻辑和涉及片外外设的片上外设配置很重要。**

- 业务逻辑实现过程
- 底层的片上外设配置以及原理
- 基础知识很重要。

## 项目怎么做的

- **项目功能**
- **项目流程**
- **项目架构**

**项目功能**：

这是一个具有基本飞行姿态控制的四轴玩具飞行器项目，项目分为两个子版块，一个是飞机，一个是遥控器。

- **飞机部分的实现：**

在freertos的周期任务中，使用MPU6050采集六轴传感器数据，原始数据经过校准和滤波后，再通过四元数算法得到飞机的角度数据。然后通过遥控器使用2.4G模块将摇杆数据传输到飞机主控芯片上。最后再结合串级PID计算，驱动四个电机实现飞机姿态的控制**。**

- **遥控器部分的实现：**

也是在freertos的周期任务中，周期性发送2.4G数据包：包括ADC采集的摇杆数据和特定功能按键数据。然后OLED屏幕显示摇杆数值，还有遥控电量信息。

**项目流程和架构：**

开发流程就是使用cubemx初始化各外设，编写对应的底层驱动后。再实现对应的应用逻辑，放到主循环中进行测试。当各外设和应用逻辑测试完后，然后引入freertos使用周期任务进行整体测试，最后经过PID调参使产品能够实现稳定的飞行姿态控制。

## 项目使用了哪一些外设？

### 四个减速电机

- 你怎么使用的？
  - 怎么驱动的？
  - 封装了什么函数？
  - 具体到片上外设配置

#### 驱动电机的PWM配置

分别使用四个定时器用作一路PWM输出。4个配置是一样的。

PWM频率为18KHZ,驱动电机的经典选择。要想占空比的分辨率为1000，所以ARR为999。所以计算出PSC为3。

- PWM频率 = 定时器的频率/((ARR+1)x(PSC+1))
- PWM周期 = (ARR+1)x(PSC+1)/定时器频率

配置步骤：

1. 时钟使能
   1. 定时器和GPIO都是外设，首先需要通过RCC（复位和时钟控制）寄存器使能它们的时钟
2. GPIO配置
   1. PWM信号通过定时器的通道引脚输出，因此需要将对应的GPIO配置为**复用推挽输出**
3. 时基单元配置
   1. 时基单元决定了PWM信号的频率，需要设置定时器的时钟分频（PSC）、自动重载值（ARR）和计数模式。
   2. 总线频率与定时器对应分支总线频率的关系为： 当分频系数大于1时，定时器的频率为分支总线的两倍。
4. PWM模式配置
   1. PWM模式由定时器的输出比较（OC）单元控制，需要设置通道的工作模式、占空比和输出极性。
   2. PWM（脉冲宽度调制）模式1：
      1. **计数器值（CNT） < 捕获/比较寄存器值（CCR）时**：输出有效电平。
      2. **计数器值（CNT） >= CCR时**：输出无效电平。
5. 定时器启动
   1. 使用定时器

使用HAL的两个API：

- **HAL_TIM_PWM_Start**：用于启动PWM信号的输出。
- **__HAL_TIM_SetCompare**：用于设置PWM的占空比，通过调整CCR值实现

**[封装了一个电机控制函数](###电机控制)**



### MPU6050(硬IIC)

- 你怎么使用的？
  - 与飞机主控的通讯方式
    - 针对通讯方式你封装了什么函数？
  - MPU6050本身封装了什么函数？
  - 具体到片上外设配置
- 完全看手册

#### 怎么使用的？

从官方手册上看，MPU6050主要使用IIC协议通信，还有一些比较重要的引脚：

- SDA (I²C 数据线)；SCL (I²C 时钟线)；

- AD0 (IIC器件地址选择，连接到 GND (默认)：I²C 地址为 `0x68`，连接到 VCC：I²C 地址为 `0x69`)；

#### 针对通信协议你封装了什么函数？具体怎么配置的？

##### 配置

初始化过程分为 **GPIO 口配置** 和 **IIC 硬件控制器配置** 两个方面。

**GPIO 口配置**

1. **使能 GPIO 端口时钟:**
   - 找到并使能与您要使用的 I2C 引脚相连的 GPIO 端口的时钟。

2. **配置 GPIO 引脚模式:**
   - 将对应的 SDA 和 SCL 引脚配置为**复用功能 (Alternate Function)** 模式。

3. **配置 GPIO 引脚输出类型:**
   - 将 SDA 和 SCL 引脚的输出类型配置为**开漏 (Open-Drain)**。

4. **配置 GPIO 引脚上拉电阻:**
   - 使能 SDA 和 SCL 引脚的内部或外部上拉电阻。

5. **配置 GPIO 引脚速度 (可选):**
   - 根据需要选择合适的驱动速度。

6. **配置 GPIO 引脚复用功能选择:**
   - 将 SDA 和 SCL 引脚的复用功能选择设置为连接到您要使用的 I2C 外设。

**IIC 硬件控制器配置**

1. **使能 I2C 外设时钟:**
   - 使能您要使用的 I2C 外设的时钟。

2. **禁用 I2C 外设 (如果已使能):**
   - 在配置参数之前，通常需要先禁用 I2C 外设（**控制器本身的使能**）。

3. **配置 I2C 速度模式:**
   - 根据您的需求选择 I2C 速度模式，例如 "Standard Mode"。

4. **配置 I2C 时钟速度 (频率):**
   - 根据您的系统时钟和目标 I2C 时钟频率（例如 100 kHz），配置 I2C 控制器的时序寄存器。这通常涉及到计算并设置时钟分频因子和相关的时序参数。
   - Fast Mode模式下可以设置时钟信号的占空比
     1. 低电平时间约为高电平时间的 2 倍
     2. 低电平时间约为高电平时间的 16/9 倍，接近于 1:1 的占空比。
5. **使能 I2C 外设:**
   - 完成所有配置后，使能 I2C 外设。
6. **主模式下，从模式的特性就不用配置了，默认即可。**



##### **IIC通信相关API**

```c
HAL_I2C_Mem_Read(&hi2c1,MPU_IIC_ADDR << 1 ,reg_addr,I2C_MEMADD_SIZE_8BIT,byte,1,HAL_MAX_DELAY);
HAL_I2C_Mem_Write(&hi2c1,MPU_IIC_ADDR << 1 ,reg_addr,I2C_MEMADD_SIZE_8BIT,&byte,1,HAL_MAX_DELAY);
```

参数说明：

- **hi2c**指向I2C外设句柄的指针（例如：`&hi2c1`），用于指定使用哪一个I2C接口。
- **DevAddress** **设备的I2C地址**。注意在大多数例子中，设备地址需要左移1位（`MPU_IIC_ADDR << 1`），这是因为HAL库要求传入的是8位地址格式（包括读写位）。
  - HAL库中的I2C API要求使用7位地址左移1位传入，然后内部会根据调用的函数自动在地址最低位填入读写位，最低位会被设置为0（写操作），最低位会自动置为1（读操作）。
- **MemAddress**内部寄存器地址或内存地址（例如：`reg_addr`），用于**指定设备内部要写入数据的寄存器或存储单元。**
- **MemAddSize**内部地址的大小，常用的宏有 `I2C_MEMADD_SIZE_8BIT` 和 `I2C_MEMADD_SIZE_16BIT`。该参数用于告诉底层驱动如何解析内部地址。
- **pData**指向数据缓冲区的指针（例如：`&byte`），存放需要写入到设备的数据。
- **Size** 待写入的数据字节数（例如：`1`）。在本例中仅写入一个字节，若需要传输多个字节，可传入相应的长度。
- **Timeout** 超时时间（例如：`HAL_MAX_DELAY`）。设置为`HAL_MAX_DELAY`时表示等待操作完成而不主动超时，也可以设置为具体的毫秒数。

##### MPU6050方面封装

**MPU6050方面封装了什么函数？**

利用HAL库的两个API，封装了：

- 向MPU6050内部寄存器写一个字节，写多个字节
- 向MPU6050内部寄存器读一个字节，读多个字节
  - 区别在于size是作为参数传入还是指定为1。

后面的MPU6050的配置都是在这四个函数的基础之上封装的：

- 陀螺仪角速度测量的满量程设置函数
  - 往某个寄存器中写一个字节数据进行配置
- 设置加速度计的满量程函数
  - 往某个寄存器中写一个字节数据进行配置
- 设置低通滤波器的带宽（截至频率，低于他的才能过）
  - 低通滤波器的作用就是将高于设定截止频率的信号成分过滤掉，只保留低于该频率的信号。这样可以有效减少高频噪声的干扰，提高信号的稳定性和可靠性。
- 配置MPU6050的采样率函数
  - 为了与采样率相匹配，**低通滤波器的截止频率被设置为采样率的一半**，即 `rate / 2`。这样可以滤除超过采样率一半的频率成分，符合奈奎斯特采样定理。
  - 这里顺带设置低通滤波的截止频率
- MPU6050的初始化函数
  - I2C接口初始化
  - 复位传感器，复位后延时一段时间（例如 100ms），以确保复位完成。
  - 唤醒传感器
  - 设置传感器量程
    - 陀螺仪：调用函数设置陀螺仪满量程为 ±2000 °/s（参数 3，对应寄存器中 bit4-bit3 配置）。
    - 加速度计：设置加速度计的量程为 ±2g（通常传入参数 0）。
      - **理想状态下，z轴受到一个重力加速度**
  - 采样率设置
    - 2ms采集一次
  - 使传感器工作

- **最后分别封装了获取加速度和角速度的原始数据函数**
  - 六轴传感器数据，每个轴对应两个寄存器，角速度和加速度需要分别连续读取6个寄存器，MPU6050 的每个寄存器都是 **8 位（1 字节）**。调用连续读取函数，参数传递6。
  - 顺序是XYZ,依次拿到高8位，低8位。
  - 使用6个u8类型的数组就可以存下，
  - 使用位运算和与运算就可以合并为XYZ的16位加速度和角速度原始数据。

**各寄存器地址都是从手册中获取的，在头文件中使用宏定义声明。**



### 2.4G模块(硬SPI)

- 你怎么使用的？
  - 与飞机主控的通讯方式
    - 针对通讯方式你封装了什么函数？
  - 2.4G本身封装了什么函数？
  - 具体到片上外设配置
- **这个完全看手册**

#### 怎么使用的？

从手册上看，2.4模块（SI24R1）使用四线SPI协议通信。还有一些比较重要的引脚：

- SPI 通信接口引脚 
  - MOSI：用于将命令和数据从 MCU 发送到 NRF24L01
  - MISO：用于将状态和接收到的数据从 NRF24L01 传回 MCU
  - SCK：SPI 时钟线，由主控制器（MCU）产生，同步 SPI 总线上的数据传输
  - CSN：SPI 片选信号线，低电平有效。当 MCU 要与 NRF24L01 通信时，需要将此引脚拉低，通信结束后再拉高
    - **注意时序**：必须在 SCK 有效信号之前将 CSN 拉低，在 SCK 停止后才能将 CSN 拉高。
- 控制与状态引脚
  - **CE:** 芯片使能引脚，**非常关键**。它用于激活 NRF24L01 的 **RX（接收）模式** 或 **TX（发送）模式**。
  - 当 CE 为高电平时，如果 NRF24L01 被配置为接收模式 (PRIM_RX=1)，它会开始监听空中信号；如果被配置为发送模式 (PRIM_RX=0)，并且发送 FIFO 中有数据，它会开始发送数据。
  - 当 CE 为低电平时，NRF24L01 进入 **Standby-I 模式** 或 **Power Down 模式**（取决于寄存器配置），功耗较低，不进行主动收发。
  - **这个引脚由 MCU 控制，用来精确控制收发的启动时机。**
- **IRQ (Interrupt Request):** 中断请求引脚，低电平有效。这是 NRF24L01 向 MCU 发送状态通知的信号。当以下三种事件之一发生时，IRQ 引脚会被拉低：
  - **RX_DR:** 成功接收到数据 (Data Ready)。
  - **TX_DS:** 成功发送数据并收到 ACK（如果开启了 Auto-ACK 功能）。
  - **MAX_RT:** 达到最大重发次数（发送失败）。 MCU 可以通过**轮询 STATUS 寄存器**或者将此引脚连接到 **MCU 的外部中断**输入引脚来检测这些事件。使用中断方式可以大大提高 MCU 的效率。收到中断信号后，MCU 需要通过 SPI 读取 STATUS 寄存器来判断具体是哪个事件触发了中断，并写相应的位来清除中断标志，使 IRQ 引脚恢复高电平。
  - **后面优化就没有使用这个引脚转为判断模块内部状态寄存器**

#### 难点

在发送一个字节数据包时，会死等IRQ来**判断数据是否发送完成并收到ACK**或者**达到最大发送次数**。这种方式会容易卡住？

死等万一因为IRQ引脚接触不良的话，检查不到拉低，FIFO不及时清除的话，那么持续发送数据就会被堵塞。

**但是一直轮询2.4G模块中状态寄存器的状态是合适的，因为模块内部的状态寄存器满足条件是一定会置位，这个比较准确。**



**为什么不使用中断？**

**当时的考虑：**

多个数据包的连续发送任务是在freertos的周期性任务中，如果使用中断的话，发送一个字节后，CPU会继续填充数据到FIFO中，会覆盖前面的数据，而前面的数据是有可能重发的。所以当时的考虑就是让CPU轮询数据包到达的状态清除FIFO之后在继续发送。

#### 针对通信协议你封装了什么函数？具体怎么配置的？

**配置步骤与流程：**

1. 使能 SPI 外设时钟和 GPIO 时钟
2. 配置 GPIO 引脚
   1. 配置引脚的模式、速度、上下拉等属性
   2. 将 GPIO 引脚配置为 SPI 的复用功能
3. 配置 SPI 外设
   1. SPI协议的帧格式：通常选择 **Motorola**
   2. Data Size：选择 **8 Bits**。NRF24L01的寄存器和数据都是以字节（8位）为单位进行传输的，所以这里必须选择8位。
   3. **First Bit:** 选择 **MSB First** (Most Significant Bit First)。**在SPI通信中，通常高位在前进行传输，NRF24L01也是如此。**
   4. NRF24L01的最大SPI时钟频率通常在10MHz左右
      - 总线频率是72MHZ,所以PSC选择8分频，将时钟频率拉到9M
   5. 选择时钟极性和相位
      - 根据手册看，支持SPI的00模式
      - 空闲时钟为低电平，数据在第一个跳变沿被采集
   6. 选择软件方式控制NSS引脚
   7. 通常在SPI层面不启用CRC校验，NRF24L01有自己的CRC机制。
4. 使能 SPI 外设



##### 通信相关的封装

**为了NRF24L01 进行命令交互时，会非常方便。二次封装了SPI收发一体函数：**

HAL 库的 `HAL_SPI_TransmitReceive` 函数本身是支持同时发送和接收的，但它的参数形式可能对于某些只需要交换一个字节的场景来说显得稍微繁琐一些。

**关键在于要不要返回值，当发送数据时不要，接收数据时就要。**



##### NRF24L01方面的封装

利用这个二次封装的函数，实现NRF24L01方面的封装：

- 向NRF24L01内部寄存器写一个字节，写多个字节
- 向NRF24L01内部寄存器读一个字节，读多个字节
  - 读写多个字节使用循环实现。IIC的API可以直接填入字节数，由于二次封装的函数返回值比较简洁，所以用循环了。

后面的NRF24L01寄存器配置都是基于这四个函数实现：

- 发送模式的初始化函数
  1. 进入待机模式，CE拉低
  2. 配置发送和接收地址
     1. 配置本地发送数据的地址。
     2. 为了能够接收到接收端的自动应答 (ACK) 包，通常将接收通道 0 的地址设置为与发送地址相同。
        1. 机制就是将发送方的发送地址作为ACK的目标地址
  3. **使能自动应答和接收通道:**
     - 激活接收**通道 0** 的自动应答功能。
     - 允许接收**通道 0** 接收数据（包括应答包）。
  4. 配置自动重发
     1. 重发的延迟时间和重发的次数
  5. **选择射频通道**
     1. 接收方和发送方要在同一个频道上才能通信
  6. **配置控制寄存器**
     1. 使能 CRC 校验，并设置为 16 位 CRC 校验。
     2. 使芯片上电。
     3. 将芯片配置为发送模式。 
  7. **使能发送模式:** 通过将 CE (Chip Enable) 引脚拉高，使NRF24L01从待机模式进入发送模式。如果发送 FIFO 中有数据，则会开始发送。
- 接受模式的初始化函数
  - **不需要设置发送地址：**
    - 在 **接收模式** 中，通常不需要像发送模式那样显式地设置 TX_ADDR 寄存器。接收设备会监听来自任何配置了正确接收地址的发送设备的信号。发送设备会使用自己的发送地址作为目标地址，接收设备只需要配置好自己的接收地址即可。
  - **需要设置接收通道的有效数据宽度：**
    - 在 **接收模式** 中，设置接收通道 0 的有效数据宽度。代码中将其设置为 `TX_PLOAD_WIDTH`，这意味着**接收端期望接收到的数据包的有效载荷长度与发送端发送的数据长度相同**。
  - 其他设置一样。
- 发送一个字节数据包函数
  - 通过内部状态寄存器的标志位判断是否发送完成并收到ACK或者达到最大重发次数
  - 如果是前者：标志位置1后，再写入1就可以清除。发送完成FIFO会自动清空
  - 如果是后者：除了清除标志位，还有清除FIFO,不然无法继续发送。
- 接收一个字节数据包函数
  - 还是通过内部状态寄存器判断是否收到
  - 收到则清除标志位
  - 把数据读走，然后清空接收FIFO
- 自检函数
  - 往寄存器中写几个字节然后再读取出来判断模块是否工作正常
  - 在初始化发送模式和接收模式之前



### OLED屏幕（软三线SPI）

- 你怎么使用的？
  - 与飞机主控的通讯方式
    - 针对通讯方式你封装了什么函数？
  - 2.4G本身封装了什么函数？
  - 具体到片上外设配置
- 显示汉字，字符
- 显示原理

#### 怎么使用的？

**通过手册得知可以使用三线SPI的00模式。**

这里使用的是软件模拟三线SPI协议，重点关注几个引脚：

- **CS (Chip Select)：** 片选信号。在SPI通信中，CS引脚用于选择与哪个从设备进行通信。当CS引脚被拉低（通常是低电平有效）时，主设备才与该从设备进行通信。
- **RES (Reset)：** 复位信号。这个引脚用于将OLED模块复位到初始状态。
- **D/C (Data/Command)：** 数据/命令选择信号。这个引脚用于告诉OLED模块当前通过数据线传输的是数据还是命令。**通常，高电平表示数据，低电平表示命令。**
- **CLK (Clock)：** 时钟信号。SPI通信需要一个时钟信号来同步数据的传输。在你的命名中是CLK，通常也称为SCLK (Serial Clock)。
- **DIN (Data In)：** 数据输入信号。在SPI通信中，主设备通过这个引脚将数据发送给从设备。通常也称为MOSI (Master Out Slave In)。

OLED通常不需要主动向MCU发送数据，所以你只需要实现主设备发送的功能即可。



**为什么选择软件模拟三线SPI？**

软件模拟的三线SPI协议会比软件模拟的IIC协议更快一些。

**协议开销更小：**

- **SPI：** 三线SPI协议的开销相对较小。一旦片选信号 (CS) 拉低选中设备，数据就可以连续地通过时钟线 (CLK) 和数据线 (DIN) 进行传输。**每个字节的传输只需要8个时钟周期**。你代码中的实现就体现了这一点。
- **IIC：** IIC协议的开销相对较大。每次传输数据都需要发送起始信号、设备地址（包括读写位）、数据字节，并且接收方需要发送应答信号 (ACK)。发送停止信号结束一次传输。即使是只发送数据，也需要包含设备地址和控制字节等额外信息，这增加了传输的字节数和所需的时钟周期。



#### 针对通信协议你封装了什么函数？具体怎么配置的？

**三线SPI的三个引脚的GPIO初始化：**

- 都配置为推挽输出即可

**封装了一个三线SPI发送一个字节数据/命令的函数（可以看出是时钟极性和相位00模式）**

- 先通过参数判断是发送命令还是数据从而决定D/C引脚的电平
- 直接片选拉低
- 逐位发送数据 (8位循环):
  - 在发送每一位之前，先将时钟线拉低。
  - 通过判断当前数据的最高位是否为1，来设置数据线 `OLED_SDIN` 的电平。
  - 将时钟线拉高，在上升沿时，OLED通常会采样数据线上的电平，从而接收到一位数据。
  - 将数据左移一位，以便在下一次循环处理下一位。
- 释放从设备 (`OLED_CS_Set()`)
  - 在发送完一个字节后，将片选信号拉高，结束本次数据传输。
- 恢复D/C电平 
  - 默认为数据模式

##### **OLED方面的封装**

利用三线SPI的发送一个字节函数的基础上封装了如下函数：

- **OLED的GPIO引脚初始化函数（自动实现）**
  - 包括DC,CS,RES引脚
- OLED屏幕初始化函数
  - OLED屏幕所用到的IO初始化（**自动实现**）
  - 硬件复位
  - 底层标准设置驱动移植
  - 清屏函数
- 清屏函数
  - 按照页数纵向水平刷新
  - 页循环（0~8），每一页根据变量设置页地址，每页设定列的起始地址，到哪里结束，是由你后续写入的数据量决定的。
  - 每一个页循环中，有128列，纵向刷屏的话，需要128个u8元素
  - 清屏全部熄灯，反复写入0x00

- 确定显示起始位置函数  哪页的哪列（**模数据也是u8，精确到列就行**）

  - 由于OLED的列地址通常需要用两个字节来表示（因为列数可能超过255，例如128列就需要7位来表示，而一个字节只有8位），所以我们需要将**列号拆分成高位和低位进行设置**。
  - 列地址就是分别取列号（**有可能大于255**）的高4位和低4位组成的。

- 显示一个字符函数（`u8 page,u8 list,u8 ch,u8 size`）

  - 16x16像素大小的字符，实际占用像素为16x8,高不变，宽减半。
    - 如果大小为16，那么就要占用两页，一页才8行，宽只需要8列，也就是8个u8元素
    - 那么一个字符的模数组元素就要16个u8元素。
    - 模数据数组是u8类型
  - 计算目标字符与字符数组中第一个元素的偏移量
    - 根据偏移量就可以计算出目标字符在模数组中的起始位置
    - 那就是先传入8个u8，再换页传入8个u8
    - `F16X16[n*16+i*8+j]` i为页数  j为列数
  - size/8计算出占用多少页，来确定页循环的次数，每一个循环设置页起始地址即可。

- 显示一个的汉字（`u8 page,u8 list,u8 *hz,u8 size`）

  - 计算要显示的汉字与字库数组中的首个汉字的偏移个数
  - 汉字占用两个字节，*`hz==table[2*n]  && *(hz+1)==table[2*n+1]`
    - 字库数组是一维字符数组，存的是字符串，拆开对比两个字节是否相等
  - 拿到n就是偏移个数
  - 如果大小为16，那么像素实际占用就是高为16，宽为16。就是占用两页，每一个页需要16列，也就是16个u8元素。就是说一个汉字占用模数组元素就要32个u8元素。
  - size/8计算出占用多少页，来确定页循环的次数，每一个循环设置页起始地址即可。
  - `hz16[n*32+16*i+j]`  i为页数  j为列数

  

- 显示可设置大小的字符和汉字混合形式函数（`u8 page,u8 list,u8 *str,u8 size`）

  - 解引用判断是字符还是汉字

    - 通过ASCII码，汉字的编码，前一个字节都是大于ASCII码
    - 如果在ASCII码范围内就调用显示一个字符函数
      - 指针往后移动一个位置u8
      - 更新列的起始显示位置，如果大小是16，+8  32，+16

    - 如果是汉字编码范围就调用显示一个汉字函数
      - 指针往后移动两个u8位置
      - 更新列的起始显示位置，如果大小是16，+16  32，+32

  - 暂时不会换页，使用取余实现回写。

  - 换页的话：当列不够显示时就换页

  - ```c
    //换页
    //				if(list >= 127-16)//不能够显示一个字符
    //				{
    //					page += 2;
    //					list = 2;
    //				}
    ```

- 画矩形条函数（页号，列号）

  - 调用：确定显示起始位置函数  哪页的哪列
  - 使用循环即可，点亮一列就是0xff

### 摇杆数值怎么采集的（ok）

- 采集原理
- 滤波处理

#### 采集原理

左右两个遥杆的上下左右分别使用ADC的一个通道采集，这里使用了ADC的2，3，1，6通道做ADC采集并使用DMA搬运数据。**整个ADC连续采集的过程是这样的：**

1. ADC启动**连续扫描**模式，**按顺序**对通道1→2→3→6进行转换
2. 每当一个通道转换完成，结果放入ADC_DR寄存器
3. ADC_DR中出现新数据会触发DMA请求
4. DMA将数据从ADC_DR传输到内存缓冲区的当前位置
5. DMA自动更新内存地址指针，准备存储下一个通道的数据
6. 四个通道完成一轮后，由于设置了循环模式，DMA会自动重置目标地址到缓冲区起始位置
7. 这个过程在不干预的情况下会持续进行

#### 配置步骤

1. 时钟配置
   1. 使能GPIO的时钟（ADC通道对应的GPIO）
   2. 使能ADC的时钟
   3. 根据需要配置ADC时钟分频
      1. C8T6的ADC时钟频率不能超过14MHZ
2. GPIO配置
   1. 将ADC通道对应的GPIO配置为模拟输入模式
   2. 模拟信号，不需要上拉或下拉电阻
3. ADC基本参数配置
   1. 配置ADC工作模式：独立模式（非双ADC模式）
   2. 配置为扫描模式（多通道采集）
   3. 选择连续转换（需要不断地采集）
   4. 配置触发方式：软件触发
      1. `HAL_ADC_Start_DMA`
   5. 配置数据对齐方式：通常为右对齐
   6. 设置需要采集的通道数为4
4. ADC通道配置
   1. 设置通道转换顺序：CH1→CH2→CH3→CH6
   2. 为每个通道配置适当的采样时间（都是7.5周期）
5. 配置DMA（因为这个不需要等标志位做事情，所以CPU不参与也是可以的）
   1. 配置DMA通道（ADC1对应DMA1_Channel1）
   2. 设置DMA传输参数：
      1. 外设到内存（数据传输方向，始终是从ADC寄存器读取数据到内存）
      2. 半字传输（ADC数据寄存器（ADC_DR）是16位的，转换结果存储在低12位）
         1. ADC转换结果是12位的（取值范围为0-4095）
      3. 内存地址自增（每次传输后内存地址自增，以便存储不同通道的数据），依次存储在数组中
   3. 设置**循环模式**以持续采集数据
   4. 设置DMA传输的优先级
      1. 对于需要实时响应的遥控器，建议使用高优先级

#### 相关API

通过`HAL_ADC_Start_DMA(&hadc1, (uint32_t *)&ADC_Value[0], 4);`启动后，`ADC_Value`数组中的值会实时更新。这是因为DMA工作在循环模式下，当ADC完成一轮采样后，数据会自动传输到这个数组中。

当4个通道全部采样完成后，由于DMA在循环模式下，它会自动重置目标地址指针到`ADC_Value[0]`

ADC继续下一轮采样，如此循环。





## 业务逻辑（重要因为外设少）

### 摇杆ADC做了什么处理（ok）

配置完后直接使用相关API开启ADC采集，然后打印数组中ADC的值。可以看到摇杆的极性（上小下大，右小左大）和（0~4095）范围。

1. **摇杆扫描函数**
   1. 将ADC的值转换为 1000-2000的范围，并且处理极性
      1. 分辨率为1000
      2. ADC乘以四分之一，再用2000去减（2000~1000上下）
      3. 如果是0~1000的话，处理极性时会出现负数，处理比较麻烦。
2. 为了让ADC值平滑变化，**滑动窗口滤波函数**
   1. ADC回达到目标值，但是不会那么快
   2. 四个ADC值都要做滑动滤波，取最近10次数据的平均值。
   3. 实现原理
      1. 定义一个结构体，包含sum累加值，以及一个10大小的数组，这两者用来算最近10次数据平均值的
      2. 有一个count=0用来当数组索引
      3. 先丢掉数组中的一个旧数据，sum也减去值
      4. 将新值填充到旧位置上，sum加起来
      5. 然后除以10就可以得到最近10次数据的平均值
      6. 然后count++
      7. 每10次索引从头开始
   4. **这个函数是在摇杆扫描函数中调用**
3. 中点校准：油门最低校准，其他中点校准
   1. 为什么进行校准？
      1. 对于姿态摇杆来讲，会自动回中。摇杆值应该是1500，由于误差和器件损耗的问题，导致回中后，值不是1500，这会造成人不控制姿态时，会有漂移现象。
      2. 对于油门摇杆来讲，拉到最低应该是0值，由于误差和器件损耗的问题，可能拉到最低后，值不是0。这会导致油门拉到最低时，螺旋桨可能还在转。
   2. 效果
      1. 不可能改变姿态中点和油门最低点的ADC采样值。
      2. 只能计算出误差值，然后使用ADC采样值减去误差值达到校准的目的
   3. 实现
      1. 做一个遥控器上的功能按键扫描，长按触发校准逻辑
         1. 按照freertos调用的周期计算
      2. 创建一个全局的误差值结构体，用于存放误差值
      3. 累加50次摇杆采样结果然后计算均值最后减去中点值和油门最低值得到的就是**误差值**
   4. **这个函数在摇杆扫描函数中调用，采样值会直接减去误差值，初始校准前误差值是0**
4. 最大值、最小值限幅
   1. 为了稳妥起见，防止出现异常值，按键微调的时候，可能会出现异常值，所以限幅
   2. 比如一直减去10的话，ADC值就会超过1000~2000的范围
   3. 使用三元运算符实现，ADC的值大于1000的话保持原值，小于1000就限定到1000
   4. **这个函数是在摇杆扫描函数中调用**
5. 中点限幅
   1. 中点校准之后还是有些许偏差，只要在中间附近，就认为是中值1500
   2. 姿态摇杆会回中，校准之后，偏差不是很大，范围窗口可以给小一点，比如上下相差10就可以认为是中点，修改为1500
   3. 校准之后中点才好限幅，不然窗口范围都不知道给多大才好。
   4. **考虑到油门不会回弹，手动拉到完全的中间很难，范围给大一点**
   5. 这个函数是在**摇杆扫描函数**调用



#### 四个微调按键的功能封装

**经过一系列校准和限幅操作之后，还会有偏飞现象吗？**

因为代码烧录进去之后，对于**中点限幅的范围**就写死了，随着器件的使用，中点校准后（因为是取的是平均值，假设采样值变化很大，均值就会不同），误差逐渐放大。导致超出了中点限幅窗口范围，就会有偏飞现象。这个时候可以通过微调按键扫描函数将误差值做修改，使其进入到中点限幅的窗口范围内，就可以进行中点判定了。

#### 遥控的微调按键扫描的实现

- 微调按键和功能按键

微调按键的按键**扫描函数**实现：

- 读取按键引脚的GPIO电平

- 使用一个标志位变量，轮询各按键的按下状态，如果按下
- 软件消抖之后还是按下状态就进入标志位置位并按键处理逻辑
  - 对中点校准后的误差值进行微调操作，体现在最终ADC采样值上。
  - 每次加10或者减10
- 松开之后再把标志位置回
- 这样实现了单次按下一次触发的效果

**这个函数是放在freertos的周期任务中执行的。**

#### 微调按键逻辑优化

在微调按键逻辑中把修改后的偏差值存入到AT24C02中，开机就把误差值结构体赋值，这样的话调好之后短时间内就不用调了。

#### AT24C02的实现（软IIC）

256 字节的存储器。可反复擦写 10 万次，用于存储微调按键，可频繁存储的地方都用 EEPROM。对于小量数据的频繁更新（几十到几百字节），AT24C02更适合，因为它可以按字节擦写，不需要擦除整个扇区

对于小数据量、高频率写入的应用，AT24C02可能更合适；对于大数据量、中等频率写入的应用，W25Q64配合适当的磨损平衡策略会更好。

- 使用什么通信协议？
- 针对通信协议封装了什么函数？
- 针对AT24C02封装了什么函数？

使用IIC通信，有几个比较重要的引脚：

- IIC的数据线和时钟线，外接上拉电阻
- WP引脚：写保护引脚连接到地(GND)，这意味着写保护功能被禁用，允许向EEPROM写入数据。

**这里使用软件模拟IIC驱动**

**针对通信协议封装了什么函数？**

1. IIC所用IO口初始化配置
   1. 使能GPIO的外设时钟
   2. 将对应GPIO口的模式设置为开漏输出模式（有外部上拉电阻）
   3. 设置时钟线和数据线的空闲电平（**都拉高**）
2. IIC的起始信号函数
3. IIC停止信号函数
4. IIC发送应答/不应答信号函数
5. IIC检测应答/不应答信号
6. IIC发送一个字节数据函数
7. IIC接收一个字节数据函数



**针对AT24C02封装了什么函数？**

1. AT24C0X的初始化
   1. **IIC所用IO口初始化配置**
2. 往at24c0x的某个地址空间写一个字节数据
3. 从at24c0x的某个地址空间读一个字节数据
4. 从AT24C0x的某个地址空间开始连续读多个字节数据
5. 往AT24C0x的某个地址空间开始页写
6. 往AT24C0X的某个地址空间开始连续写可以跨页（**自定义**）







### MPU6050的零偏校准和滤波算法

- 初始数据有偏差
  - 理想值是什么？
- 数据有噪音，应对抖动变化剧烈

- 两种滤波算法的解释以及应用原因？
- 六轴传感器的数据是哪一些？

#### 零偏校准函数

**MPU6050的原始数据格式**：

六轴传感器数据，每一个轴16位数据，由两个寄存器拼凑组成。

理想状态下：XY轴的加速度应该是0，假设MPU6050的Z轴垂直向下，那么它会受到地球的重力加速度，大小约为 +1 g。对应的原始数据值应该接近 **+16384** (1 g * 16384 LSBs/g)。如果Z轴垂直向上，那么值会接近 **-16384**。

静止状态下：XYZ的角速度应该是0

**零偏校准的效果**：使三轴角速度和三轴加速度接近理想状态值。

**实现思路：**

使用一个数组存放累加值用于计算平均值。校准前会先判断是否处于静止状态，利用角速度前后的差值，如果相差正负5度以内，就算静态状态。

**为什么选用角速度作为判断标准？**

角速度稳定一点，加速度容易受到干扰，而且数值太大，不太好计算

使用一个循环连续判断30次角速度数据，每个轴的角速度都满足条件后跳出循环

再获取356次MPU6050的数据，过滤掉前100次，累加后面256次的值，再除以256得到六个轴的误差平均值。将其存入一个全局数组中。

这个函数在开机后MPU6050初始化后，会调用一次。获取MPU6050六轴原始数据时，获取到的数据会减去这个误差值。

#### 获取MPU6050六轴原始数据时的滤波

获取MPU6050六轴原始数据时，加速度和角速度容易受到噪音干扰，其中加速度非常明显。随便动一下飞机的话，加速度数值变化很大，很不利于控制。如果使用噪声较大的原始数据进行PID控制，会导致控制指令频繁波动，使飞行器抖动不稳。

对加速度进行简易一维卡尔曼滤波，推导原理不需要知道，就是把三轴数据传递进去，经过一系列计算过再赋回原值。

对角速度进行简单的一阶低通滤波：

- 原理：使用一个数组保存上一次的角速度值，然后新角速度值 = 大系数x上一次角速度值 + 小系数x现在的角速度值

### 解析校验接收到的遥控数据

数据帧格式来自上位机的标准通信协议：

- 固定的两个字节帧头
- 固定的一个功能字
- 有效数据长度固定为20
- 四个ADC采集的摇杆值u16，加上六个功能按键值u16
- 校验和（四个字节）
- 总计一个数据包有28个字节。

解析前的校验步骤：

- 判断帧头
- 判断功能字
- 再算一次校验和
- 获取四个ADC采集的摇杆值

### 失联逻辑

单独作为周期函数调用。

- 没有失联的情况下，就进行飞机解锁逻辑的判断
  - 没有失联的情况下，飞机解锁逻辑才有意义。

- 否则处于失联状态的话，数据解析函数会累加connect_flag值
  - 没有收到2.4G数据时，变量会累加，超过一定值就会进入到失联逻辑

首先把姿态摇杆数据全部归中，让飞机保持平稳。

油门开始缓慢下降，因为此函数是是在周期性执行的，可以实现每进入一次失联逻辑，油门值就减去50

油门值低到一定程度，就直接油门拉到最低，这个时候不是已经在地上了就摔下来。

此时再进行一次[自检逻辑](###飞机2.4G自检设计)

#### 飞机的状态解锁设计

刚开机联通时，飞机是不动的，需要解锁。不然很危险。遥控板只负责发送数据，对数据的判断留在飞控板上。比如飞机解锁。

### 飞机2.4G自检设计

就是测试2.4G模块是否正常：

- 就往当前2.4G模块的寄存器中写几个字节，写在FIFO中，再读取出来，检查是否一样。
- 因为没有切换到发送模式，即使FIFO中有数据，也不会发送

自检函数通过以后才会初始化为发送模式

### PID串级控制（计算）

- 解释原因
- 内环
- 外环

- 先判断飞机有没有解锁
- 解锁后进入第二阶段
  - 把PID上一次计算的值给清除掉
  - PID系数不动
- 外环：赋值角度的测量值
  - MPU6050计算后的欧拉角
- 内环：赋值角速度的测量值
  - MPU6050的测量值

### 怎么实现姿态控制的呢？

#### 电机控制逻辑

1. 首先四个电机的PWM值为0，判断飞机的解锁状态
2. 判断油门动了 > 1100,进入正式控制
   1. 传递过来的油门摇杆值
3. 油门值转成pwm的范围值   油门值 - 1000
   1. PWM的值限定到0~900
   2. 剩余的100留给PID计算的结果
   3. 如果在0~900之间则不需要
4. 四个电机加上分别3个PID的值
   1. 四个电机的转速就有差别了，从而就实现了姿态控制
   2. 三个PID的值在不同电机的上正负关系不一样。

#### 姿态控制

姿态摇杆的值离中点的偏移量会作为串级PID计算的期望值，然后MPU6050测量的值作为实际输入值。

串级PID计算会根据PID的三个参数逐渐缩小与期望值的差距。飞机会从一个角度向另一个角度变化，这个变化是一个过程。



### freertos任务调度设计

- 优先级
- 可能造成同步与互斥的事件，放在一起了，避免出现这个问题。

![image-20250408024234116](./项目总结.assets/image-20250408024234116.png)

![image-20250408024248086](./项目总结.assets/image-20250408024248086.png)

如果拆开的话，就需要考虑同步互斥了。

- 控制飞机的任务最重要，被打断影响很严重。
  - MPU6050的采样频率是2ms。
- 收的周期一定要小于等于发的周期。不然可能收的不及时。
  - 使用绝对延迟，不然会越拉越远，导致收发不及时。



## 移植FreeRTOS

关于FreeRTOS的移植，有哪一些必要的文件需要移植

**FreeRTOS 核心文件**

这些是 FreeRTOS 的通用代码，不需要针对 STM32F103 进行修改，通常位于 FreeRTOS/Source 目录下。主要包括：

- tasks.c：**任务管理**的核心实现。
- list.c：**链表操作**的基础支持。
- queue.c：**队列功能**的实现。
- timers.c：**软件定时器支持**。
- event_groups.c：**事件组功能**（可选，视应用需求而定）。 这些文件提供了 FreeRTOS 的基本功能，必须包含在项目中。

**移植层文件**

移植层文件与具体的处理器架构和编译器相关。对于 STM32F103（基于 Cortex-M3 内核），需要使用以下文件，位于 FreeRTOS/Source/portable/GCC/ARM_CM3 目录下：

- port.c：Cortex-M3 特定的移植实现。
- portmacro.h：与 Cortex-M3 和 GCC 编译器相关的宏定义。 这些文件确保 FreeRTOS 能够适配 STM32F103 的硬件架构，是移植的关键部分。

**内存管理文件**

FreeRTOS 提供了多种堆内存管理方案，位于 FreeRTOS/Source/portable/MemMang 目录下。你需要选择并包含其中一个文件，例如：

- heap_4.c：推荐使用的内存分配方案，支持内存碎片管理。 根据你的应用需求，也可以选择其他方案（如 heap_1.c 或 heap_5.c），但只需包含一个。

**配置文件**

FreeRTOSConfig.h：FreeRTOS 的配置文件，需要手动创建或从示例中复制到你的项目目录中。

- 这个文件定义了 FreeRTOS 的运行参数，例如任务优先级数量（configMAX_PRIORITIES）、时钟频率（configCPU_CLOCK_HZ）、tick 频率（configTICK_RATE_HZ）等。
- 你需要根据 STM32F103 的硬件特性和应用需求调整这些配置。

