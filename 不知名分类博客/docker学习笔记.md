# docker学习笔记

## 传统部署方式痛点

1. **环境一致性问题**（保持程序能在相同的环境下运行很难而且配置容易出错）：
   - **麻烦点**：开发环境、测试环境和生产环境之间存在差异，导致在一个环境中正常运行的应用在另一个环境中可能会出现问题。
   - **痛点**：环境配置复杂且容易出错，难以确保不同环境的一致性。
2. **依赖管理**（很难在不同的系统上找到相同版本的依赖）：
   - **麻烦点**：应用程序的依赖项（如库、框架、工具）管理复杂，版本冲突和依赖缺失问题频发。
   - **痛点**：依赖关系错综复杂，手动配置和管理费时费力。
3. **部署速度慢**（部署程序就不能单部署程序，项目配套的工具都要部署而且配置，为项目部署MySQL和redis等。还要给他们测试是否能连接程序等。）：
   - **麻烦点**：传统部署往往需要手动操作，过程繁琐且耗时。
   - **痛点**：频繁的代码发布和更新过程缓慢，影响开发效率和响应速度。
4. **扩展性差**（要加新功能又需要重新部署和测试）：
   - **麻烦点**：传统部署方式下，扩展应用程序需要复杂的配置和手动操作，难以快速响应负载变化。
   - **痛点**：扩展和缩减资源困难，影响应用的灵活性和可扩展性。
5. **在没有图形化的操作系统上，安装和配置比较困难和耗时。**

## docker解决的问题

1. Docker 使用容器技术，将应用及其依赖环境打包在一个镜像中，确保开发、测试和生产环境的一致性。**大大减少了“在我机器上可以运行”的问题。**
2. Docker 镜像可以快速构建和启动，容器的部署和启动时间通常比传统虚拟机快很多。
3. Docker 容器是轻量级的，不需要虚拟机的全部开销，可以在同一台物理机上运行更多的容器。
4. Docker 容器的轻量级和便捷的管理工具（如 Kubernetes 等）使得应用扩展变得简单和高效。

## 安装docker

### 为什么安装yum工具？

在centos系统中的默认包管理器，负责安装、更新和管理软件包是yum。就像Windows中有**Chocolatey**作为包管理工具。

### 配置yum源

配置 Docker 的 YUM 源实际上就是为 YUM 提供一个新的软件包仓库的地址，使得 YUM 可以从这个新的仓库中查找并下载 Docker 相关的软件包。这一步相当于告诉 YUM 工具，有一个新的位置可以用来查找和安装软件包。

### 安装docker以及启动和校验

[root@iZt4n93jla5g1qmwr3l2s9Z ~]# docker images Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?（列出系统中的docker镜像，提示为没有启动docker服务）

```Bash
# 启动Docker
systemctl start docker

# 停止Docker
systemctl stop docker

# 重启
systemctl restart docker

# 设置开机自启
systemctl enable docker

# 执行docker ps命令，这条命令会列出正在运行的 Docker 容器。如果 Docker 已经正确安装并启动，这个命令将列出当前正在运行的容器。如果不报错，说明安装和启动 Docker 成功。
docker ps
```

## 配置docker镜像加速

Docker 镜像加速的原理是通过配置一个镜像加速器，使 Docker 拉取镜像时从加速器下载而不是直接从 Docker Hub 下载。这种方式可以显著提升下载速度，尤其在国内网络环境下非常有用。配置加速器需要修改 Docker 的配置文件并重启 Docker 服务。（定期从官方镜像仓库拉取的国内副本设置后可以直接从副本仓库拉取实现加速。）

## docker的原理理解

**docker容器化时选择容器的基础镜像应该与开发环境一致，而不是宿主操作系统一致。这样可以确保容器内部的运行环境与开发时的环境相同，避免在不同环境中运行时出现不一致的问题：**

1. **确保一致性**：
   - 开发环境和运行环境一致，可以减少“在我的机器上可以运行”的问题。**所有的依赖、配置和库都是在相同的环境中运行的。**
2. **简化调试**：
   - 如果容器内部的环境与开发环境一致，调试和修复问题会更加容易，因为开发人员熟悉该环境。
3. **跨平台运行**：
   - Docker 容器化的一个关键优势是**可以在不同的宿主操作系统上运行，只要宿主操作系统支持 Docker。**容器的内部环境与宿主操作系统无关，主要依赖于所选的基础镜像。

**容器化和跨平台运行 JAR 包的原理在某些方面是相似的，都涉及到在不同操作系统上运行一个标准化的运行环境，从而消除操作系统之间的差异。**

1. **环境标准化**：
   - **容器化**：**容器镜像包**含了应用程序运行所需的所有组件和依赖项，因此无论在什么操作系统上运行，只要有 Docker 环境，应用程序的运行环境都是一致的（容器内部环境固定后与开发环境一致）。
   - **跨平台运行 JAR 包**：JAR 包包含了 Java 应用程序及其依赖，JVM 提供了一个标准化的运行环境，因此无论在什么操作系统上运行，只要有 JVM，Java 应用程序的运行环境都是一致的。
2. **依赖独立**：
   - **容器化**：容器镜像封装了所有的依赖项（如库、配置文件等），不依赖于宿主操作系统的具体配置。
   - **跨平台运行 JAR 包**：JAR 包及其**依赖通过 JVM 运行**，不依赖于宿主操作系统的具体配置。
3. **跨平台运行**：
   - **容器化**：Docker 容器可以在任何支持 Docker 的操作系统上运行，通过共享宿主操作系统的内核，但容器内的环境是隔离的和独立的。
   - **跨平台运行 JAR 包**：JAR 包可以在任何支持 JVM 的操作系统上运行，通过 JVM 提供的抽象层，屏蔽了操作系统的差异。

### 不同点

1. **实现方式**：
   - **容器化**：通过容器技术（如 Docker）来创建独立的运行环境，容器与宿主操作系统共享内核，但用户空间独立。
   - **跨平台运行 JAR 包**：通过 JVM 来提供运行环境，JVM 本身是跨平台的，屏蔽了底层操作系统的差异。
2. **依赖的环境**：
   - **容器化**：需要宿主操作系统上安装 Docker 引擎。
   - **跨平台运行 JAR 包**：需要宿主操作系统上安装 JVM。

### 总结

可以说，容器化与跨平台运行 JAR 包的核心理念是相似的：通过标准化的运行环境来消除操作系统之间的差异，简化跨平台的部署和管理。容器化通过 Docker 容器镜像提供这种标准化的环境，而 JAR 包通过 JVM 提供这种标准化的环境。

因此，容器化在一定程度上确实消除了操作系统的差异，类似于 JVM 消除了 Java 程序跨平台运行的差异，从而简化了跨环境的部署和管理。

### 细节补充

- **共享内核**：容器共享宿主操作系统的内核，容器内的应用程序依赖于宿主系统的内核来执行系统调用和资源管理。

- ### 跨平台支持的误解

  - **跨平台支持**指的是在一个平台上能够运行另一平台的容器，例如在 Windows 上运行 Linux 容器。这是通过 WSL 2 实现的，而不是直接跨平台运行。
  - **Windows 容器的跨平台部署**：并不意味着 Windows 容器可以在 Linux 上运行。Windows 容器依赖于 Windows 内核，必须在 Windows 宿主操作系统上运行。

- Docker 容器可以在任何支持 Docker 的相同操作系统类型的环境中运行时，我们指的是：

  - **相同操作系统类型**：Docker 容器的可移植性是基于相同操作系统类型的。换句话说，Windows 容器只能在 Windows 宿主操作系统上运行，而 Linux 容器只能在 Linux 宿主操作系统上运行。因此，在选择容器部署环境时，需要确保目标环境与容器的操作系统类型匹配。**（因为要共享内核，而不同操作系统的内核实现有所不同）**
  - Docker 容器在**相同操作系统类型的环境中**的可移植性和一致性，从而使得开发、测试和部署过程更加流畅和可靠。

- 这么来看JAR 包是一种真正的跨平台和跨操作系统的部署方式。Java 的跨平台性是其设计之一，这意味着您可以在任何支持 Java 运行时环境（JRE）的系统上运行相同的 JAR 文件，而无需担心操作系统的差异。

- **不打包软件啊。。。要是打包连项目用的软件一起打包该多逆天。估计等待时间就要很久。**是的，无论您选择使用 JAR 包部署还是 Docker 容器部署，都需要确保您的宿主服务器上已经配置了 Redis 和 MySQL。在任何一种部署方式下，都需要确保 Redis 和 MySQL 数据库能够被您的应用程序访问，并且设置正确的连接信息（如主机名、端口号、用户名、密码等）。这样您的 Spring Boot 项目才能正确地与 Redis 和 MySQL 进行交互。







