# 32单片机前导

## ARM的Cortex_M4是什么？

ARM Cortex-M4是ARM公司开发的一款**32位RISC处理器内核**，属于Cortex-M系列，主要面向嵌入式系统应用。以下是它的主要特点：

**性能和效率：**

- 支持最高168MHz的时钟频率
- 采用3级流水线架构
- 哈佛结构（指令和数据使用独立总线）

**关键功能：**

- 包含硬件除法单元和DSP指令集
- 支持单精度浮点运算（FPU是可选的）
- SIMD（单指令多数据）指令支持
- 内置中断控制器（NVIC）

**主要应用领域：**

- 工业控制系统
- 消费电子产品
- 汽车电子
- 医疗设备
- 智能家居设备

**与其他Cortex-M系列的区别：**

- 比Cortex-M0/M0+更强大的处理能力
- 比Cortex-M3增加了DSP和可选的FPU功能
- 在性能和功耗之间达到较好的平衡

它特别适合需要数字信号处理或实时控制的应用场景，比如电机控制、音频处理等。

## 跟STM32有什么关系？

STM32和Cortex-M4的关系可以这样理解：

**核心架构关系：**

- STM32是意法半导体(ST)基于ARM Cortex-M**核心**开发的**微控制器产品系列**
- STM32F4系列就是使用了Cortex-M4作为CPU内核
- 可以说Cortex-M4是"大脑"，而STM32是包含这个"大脑"的完整芯片

**具体组成：**

- ARM公司提供Cortex-M4内核的设计
- ST公司在此基础上添加：
  - 片上外设（GPIO、定时器、ADC等）
  - 存储器（Flash和RAM）
  - 时钟系统
  - 电源管理单元

**产品系列：**

- 使用Cortex-M4内核的STM32主要有：
  - STM32F4系列（最常用）
  - STM32F3系列
  - 部分STM32L4系列

**商业关系：**

- ST公司向ARM支付授权费用
- 获得Cortex-M4内核的使用权
- 基于此开发自己的微控制器产品

简单来说，就像电脑中CPU和整机的关系 - Cortex-M4相当于CPU，而STM32则是一台完整的电脑，包含了CPU和其他必要组件。

**相当于就是CPU芯片和基于芯片开发的开发板关系吗？**

不完全是这样。让我解释得更清楚一点：

**层级关系：**

- Cortex-M4：是CPU内核**设计，相当于"图纸"**
- STM32：是一个完整的微控制器芯片
- STM32开发板：是基于STM32芯片制作的电路板

**可以用这样的层级关系来理解：**

```c
Cortex-M4（CPU内核设计）
    ↓
STM32（完整芯片，包含内核和外设）
    ↓
STM32开发板（包含芯片和外围电路）
```

**举个具体例子：**

- Cortex-M4 = Intel的CPU架构（如x86）
- STM32 = Intel的实体CPU芯片（如i5处理器）
- STM32开发板 = 完整的电脑主板

**主要区别：**

- STM32已经是一个实体芯片，不仅包含Cortex-M4内核，还包含了：
  - 外设接口
  - 存储器
  - 时钟系统
  - 电源管理
- 开发板则是在STM32芯片基础上增加了：
  - 供电电路
  - 晶振
  - 按键
  - LED
  - 各种接口电路

所以准确地说，是"CPU架构→微控制器芯片→开发板"的关系。

**所以说他是经过ARM公司验证的，其他公司可以基于这个去开发自己的芯片对吗？那也就是说ARM其实是自己开发过对应的芯片验证的，只不过把这一套设计方案公开卖钱而已？**

让我来纠正一个常见的误解：

ARM的商业模式：

- ARM公司本身不生产芯片
- 他们**专注于处理器设计和IP开发**
- 通过多种方式验证其设计：
  - 软件仿真验证
  - FPGA原型验证
  - 与合作伙伴协同验证

验证过程：

- ARM会先做**内部验证**
- 然后与首批客户（通常是大公司）合作进行**流片验证**
- 例如：可能会和三星、台积电等公司合作**验证工艺适配性**

为什么ARM选择这个模式：

- **专注于设计创新**
- 避免与客户竞争
- 降低运营成本
- 让更多公司能用上先进的CPU设计

客户获得的好处：

```
- 无需从零开始设计CPU
- 可以专注于自己的差异化设计
- 节省研发时间和成本
- 降低设计风险
```

这就像餐饮连锁的模式：

- ARM = 开发菜品配方的总部
- 客户 = 开店的加盟商
- ARM不开店，只卖配方和运营方案
- 每个加盟商可以根据当地特色做调整

所以ARM不是"做出来再卖方案"，而是"专门设计和验证方案"的公司。这是一个非常成功的商业模式，让ARM能专注于设计创新，而让制造商专注于生产和市场差异化。

**我记得ARM业务也有芯片吧？处理器？**

ARM公司本身确实不直接生产和销售芯片，您可能把ARM架构的处理器和ARM公司搞混了。我来解释一下：

常见的ARM架构处理器：

- 高通的骁龙系列（用ARM架构）
- 苹果的A系列、M系列（用ARM架构）
- 三星的Exynos系列（用ARM架构）
- 联发科的处理器（用ARM架构）

ARM的主要业务：

- CPU架构设计
- GPU设计（Mali系列）
- 相关IP授权
- 技术支持服务

容易混淆的原因：

```c
我们常说：
"这是ARM处理器" → 实际是"基于ARM架构的处理器"
"ARM芯片" → 实际是"使用ARM设计的芯片"
"ARM手机" → 实际是"使用ARM架构处理器的手机"
```

**具体例子：**

- iPhone 15用的处理器：
  - 人们说"用的是ARM处理器"
  - 实际是"苹果自研的基于ARM架构的A17处理器"

所以ARM公司的确没有直接生产处理器，只是因为ARM架构太普及了，导致很多人直接把使用ARM架构的处理器叫做"ARM处理器"。这种叫法虽然不够准确，但已经被广泛接受了。

## 芯片和内核的区别

好的，让我用通俗的方式解释内核和芯片的关系：

**内核（Core）：**

- 是CPU的核心计算单元
- 负责执行基本运算和逻辑操作
- 包含关键部件：
  - 运算单元（ALU）
  - 控制单元
  - 寄存器组
  - 缓存等

**芯片（Chip）：**

- 是一个完整的集成电路
- 包含内核和其他必要组件：
  - CPU内核
  - 存储器（RAM/ROM）
  - 外设接口
  - 总线系统
  - 电源管理单元

**举个例子：**

```
手机处理器的层级：
内核（Cortex-A78）
    ↓
CPU（包含多个内核+ 缓存等）
    ↓
SoC芯片（CPU + GPU + 其他组件）
```

**具体应用场景：**

- 高通骁龙8 Gen 3：
  - 内核：使用ARM Cortex-X4等内核
  - 芯片：集成了这些内核，并加入：
    - GPU（图形处理）
    - NPU（AI处理）
    - ISP（图像处理）
    - 调制解调器
    - 其他功能模块

**形象比喻：**

- 内核 = 发动机的气缸
- CPU = 完整的发动机
- 芯片 = 整个动力系统（发动机+变速箱+控制系统）

这就像是从"零件→部件→整机"的关系，每一层都在前一层的基础上增加更多功能。

**ARM设计的内核是没有实体的吧？由芯片公司生产商生成符合各自需求的实体CPU芯片吧？**

对，你理解得很准确！让我具体解释一下这个过程：

**ARM提供的内核设计：**

- 是RTL级代码（硬件描述语言）
- 包含详细的实现规范
- 提供验证平台
- 还没有物理实现

**芯片公司的工作：**

```c
ARM的设计
    ↓
工艺适配（比如台积电5nm）
    ↓
添加自己的设计（缓存、总线等）
    ↓
物理设计（版图设计）
    ↓
流片生产（在晶圆厂制造）
```

**举个例子：**

- 高通骁龙8 Gen 3：
  - 使用ARM的Cortex-X4内核设计
  - 高通自己决定：
    - 制造工艺（台积电4nm）
    - 缓存大小
    - 运行频率
    - 功耗控制
    - 其他定制化设计

**为什么这样做：**

- 让不同公司能根据自己的需求：
  - 选择合适的制造工艺
  - 优化性能和功耗
  - 添加特色功能
  - 控制成本

这就像是ARM提供了"设计图纸"，各家公司基于这个图纸，结合自己的需求和工艺，制造出实体的芯片产品。

## 裸机开发与系统开发

**芯片是裸机开发效率高还是系统开发效率高？两者的应用场景**

### **裸机开发（Bare-metal Programming）**

裸机开发是指直接操作硬件，没有运行操作系统，程序直接运行在芯片上。

#### **效率**

- **开发效率**：对简单项目效率较高，因为没有复杂的系统抽象层，直接操作寄存器即可实现功能。
- **执行效率**：更高，因为没有操作系统的调度和资源占用，程序可以完全掌控硬件资源，实时性强。

#### **适用场景**

1. **资源受限的芯片**：如8位/16位MCU，RAM和ROM较小，无法承载操作系统。
2. **高实时性要求**：如工业控制、信号处理、硬实时任务（如电机控制、传感器采集）。
3. **功耗敏感场景**：操作系统可能增加不必要的功耗，裸机程序可以实现更精准的功耗控制。
4. **简单功能的嵌入式系统**：如单一功能的设备（LED控制、简单通信模块）。

#### **优点**

- 程序占用资源少。
- 程序启动速度快，运行效率高。
- 对硬件的控制灵活、粒度细。

#### **缺点**

- 开发复杂度较高，需要深入了解硬件和寄存器。
- 难以扩展或移植，代码复用性低。
- 缺乏系统服务（如文件系统、网络协议栈）。

### **系统开发（基于RTOS/OS）**

系统开发指在一个嵌入式操作系统（如FreeRTOS、Zephyr、Linux等）上进行开发，程序通过操作系统接口与硬件交互。

#### **效率**

- **开发效率**：高，特别是对于复杂项目，操作系统提供了任务调度、内存管理、中断处理等机制，开发者专注于高层逻辑。
- **执行效率**：可能略低于裸机，因为操作系统会消耗部分资源（CPU、内存）。

#### **适用场景**

1. **复杂系统**：需要同时运行多个任务或具有复杂功能（如通信协议、文件系统、GUI）。
2. **高可扩展性需求**：如物联网设备、智能家居产品。
3. **需要标准接口**：如支持TCP/IP网络通信、USB协议等。
4. **开发周期要求快**：操作系统生态提供丰富的库和驱动，减少了开发时间。

#### **优点**

- 提供任务调度和多线程支持，易于实现复杂功能。
- 易扩展，代码可移植性高。
- 提供丰富的系统服务（文件系统、网络协议、时间管理等）。

#### **缺点**

- 系统资源开销大，需要更高性能的芯片。
- 实时性可能不足，尤其是基于通用操作系统的开发。
- 需要学习和调试操作系统相关问题。

### **总结对比**

| **对比维度**   | **裸机开发**                         | **系统开发**                       |
| -------------- | ------------------------------------ | ---------------------------------- |
| **开发复杂度** | 高，需要理解硬件底层                 | 相对低，依赖系统提供的抽象接口     |
| **实时性**     | 高，完全掌控硬件                     | 较低，受调度机制影响               |
| **资源需求**   | 低，可运行在资源受限的芯片上         | 高，需要更多RAM和Flash             |
| **应用场景**   | 单一功能、资源受限设备、高实时性需求 | 功能复杂、多任务系统、快速开发需求 |

## ARM和RAM公司的业务的区别

ARM 和 RAM 的确属于不同的业务类型，简单来说，ARM 专注于**芯片设计（尤其是CPU内核架构）**，而 RAM 是典型的**芯片制造或供应商**（假设这里你指的是存储芯片制造商，如 DRAM 或 SRAM 厂商）。以下是更详细的区别：

### **ARM（现为 Arm Ltd.）的业务**

- **核心业务**：Arm 专注于设计**微处理器架构**，尤其是低功耗、高性能的处理器架构（如 Cortex-M、Cortex-A 和 Cortex-R 系列）和指令集（如 ARMv7、ARMv8、ARMv9）。
- 业务模式：
  - Arm 不制造芯片，而是以**知识产权（IP）授权**的形式，将其设计授权给芯片制造商（如高通、三星、苹果、联发科等）。
  - 客户购买 Arm 的 IP，结合自己的设计需求，制造出最终的芯片。
- 产品类型：
  - **处理器核心**：Cortex 系列、Neoverse（针对数据中心）等。
  - **GPU**：Mali 系列。
  - **其他IP**：如互连技术（CoreLink）、系统控制器（System IP）等。
- 应用领域：
  - 手机、平板、智能手表、物联网设备、汽车电子、高性能计算。

------

### **RAM 的业务**

假设你提到的 **RAM** 是指**存储芯片供应商**，例如三星（Samsung）、海力士（SK Hynix）、美光（Micron）等。

- **核心业务**：RAM 厂商专注于**存储芯片的研发与制造**，包括 DRAM（动态随机存取存储器）和 SRAM（静态随机存取存储器）。
- 业务模式：
  - 这些公司**通常自行设计并制造存储芯片，直接供货给设备制造商**（如手机厂商、服务器厂商）或芯片集成商。
- 产品类型：
  - **DRAM**：用于PC、服务器、移动设备的系统内存。
  - **SRAM**：嵌入式存储器，用于高性能处理器或SoC中。
  - **闪存（NAND、NOR）**：非易失性存储器，用于SSD、U盘等设备。
- 应用领域：
  - 存储设备、手机内存、服务器内存、高性能计算的存储部分。

### **两者的关键区别**

| **维度**     | **Arm（架构设计商）**            | **RAM厂商（存储芯片制造商）**      |
| ------------ | -------------------------------- | ---------------------------------- |
| **核心产品** | CPU/GPU/SoC架构设计（IP授权）    | 存储芯片（DRAM、SRAM、NAND等）     |
| **业务模式** | IP授权，客户制造芯片             | 自主研发、设计并制造存储芯片       |
| **客户**     | 芯片厂商（如高通、苹果、联发科） | 消费电子、数据中心、服务器厂商     |
| **制造工艺** | 不涉及制造，专注设计             | 涉及从设计到制造的完整流程         |
| **应用范围** | 计算核心，应用在处理器、控制器等 | 存储硬件，应用在计算设备的内存部分 |

------

### **简单总结**

- **Arm**：设计并授权微处理器架构和相关技术，是全球领先的IP供应商。**它的客户是芯片制造商**。
- **RAM 厂商**：生产和销售存储芯片（如内存条、嵌入式RAM），直接服务于终端设备制造商或数据中心。

两者共同服务于电子产业，但分别覆盖计算核心和存储部分，是互补的角色。

## 单片机最小系统

### **单片机最小系统的组成**

1. **单片机核心（MCU本体）**

   - 包括 CPU、存储器、输入/输出接口等。

   - 类比：人的大脑

     - **CPU** 相当于大脑中的**逻辑和控制中心，负责决策和处理**所有的计算任务。
     - **存储器（RAM/Flash）** 相当于短期记忆（RAM）和长期记忆（Flash），用于存储即时需要的信息和永久知识。
     - **I/O接口** 类似于大脑与外界交互的“神经网络”，接收感官输入（外部信号），并发出指令（控制输出）。
   
2. **时钟电路（重点）**

   - 提供系统运行的基准时间信号。

   - 类比：心脏

     - 心脏通过跳动为身体提供节奏，同样，单片机的时钟电路（晶振或内部时钟）提供运行的时序，让所有功能模块**按节奏工作**。

3. **电源电路（重点）**

   - 提供单片机运行所需的电力。

   - 类比：血液循环系统

     - 血液输送能量和氧气，而**电源为单片机提供电压和电流，是其运行的基础。**

4. **复位电路（重点）**

   - 让单片机启动时进入一个已知的初始状态。

   - 类比：人体的清醒机制或“重启”功能

     - 比如当人昏迷或睡眠时，经过一定刺激（如喝水或休息）重新清醒，复位电路类似于这种“重启”功能，确保系统开始时是清晰而非混乱的状态。

   - ![image-20241125162123864](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\STM32单片机前导.assets\image-20241125162123864.png)

   - 从这个原理图来看，有2种复位方式:

     1. 手动复位：通过按键K5进行复位操作。当按下K5按键时,将RESET信号接地（**电平被拉低**）,触发复位。
     2. 上电复位：通过RC电路(由电阻R和电容C14组成)实现。当电源刚接通时,C14会先充电,在充电过程中会产生一个复位脉冲,确保系统在上电时能正常复位初始化。电容C14的值是0.1μF。

     这是一个比较典型的复位电路设计,**既保证了系统能在上电时自动复位,又提供了手动复位的功能**,增加了系统的可靠性和灵活性。

   - **也就是说电容充电过程中是复位的？充满了就会保持高电平从而退出复位状态？ 所以每一次接通电源都可以上电复位一次？后面需要手动按键？**

     1. **上电复位过程:**

     - 刚接通电源时,电容C14从0V开始充电
     - 充电过程中RESET保持低电平,系统处于复位状态
     - 当电容充满后,RESET变为高电平,系统退出复位状态开始正常工作

     2. **后续复位操作:**

     - 系统正常工作时,电容保持充满状态,RESET维持在高电平
     - 如果需要再次复位,只能通过按K5按键将RESET拉低
     - 松开K5后,电路恢复高电平,系统重新开始工作

     所以是的:

     - 每次重新接通电源,都会自动触发一次上电复位
     - 在系统运行过程中如果需要复位,就需要手动按K5

     这样的设计确保了系统每次启动都能正确初始化,同时也提供了手动复位的选择。

   - **是否复位取决于RESET的电平是否为低,而不是高**

   - **上电时默认是低电平(复位状态),而不是高电平**

   - **需要等电容充电后,RESET才会变为高电平,系统才会退出复位状态**

   

5. **输入设备**

   - 用于接收外部信号（如按键、传感器输入）。

   - 类比：人的感官

     - 眼睛、耳朵、皮肤等感官器官接收外界信号，并传递到大脑进行处理。

6. **输出设备**

   - 单片机通过这些设备控制外部硬件（如LED、蜂鸣器、显示屏）。

   - 类比：人的肢体或发声器官

     - 就像手、脚执行任务，口发出声音，**单片机通过输出设备完成对外界的影响**。

7. **通信接口**

   - 单片机与外界（或其他单片机）交换信息的通道（如UART、SPI、I2C）。

   - 类比：人的语言和交流能力

     - 语言是人与人之间的通信工具，**通信接口则是单片机之间或与其他设备的“语言”。**

### **单片机最小系统整体类比**

可以将最小系统看作一个简化的人体：

- **大脑（MCU核心）**：控制整个系统，负责决策和逻辑运算。
- **心脏（时钟）**：提供生命的节奏（时序）。
- **血液循环（电源）**：为系统提供持续的能量。
- **感官（输入设备）**：接收外界信号并传递给大脑。
- **肢体（输出设备）**：执行大脑指令，对外界产生影响。
- **语言系统（通信接口）**：与外界交流、协作。

------

### **形象总结**

- 单片机最小系统相当于一个简单的人体，可以感知（输入）、思考（处理）、行动（输出）并与外界交流（通信）。
- 像人一样，最小系统的各部分必须协调工作才能正常运转。缺少任何一个关键部分，系统都无法完整运行，例如缺少“心脏”（时钟），整个系统就无法按时序运作。

这样类比，可以更直观地理解单片机最小系统的组成及其重要性。



## STM32F4xx的三种启动方式

**主闪存存储器启动 (Boot0=0)：**

- 从Flash启动运行用户程序
- 产品正常工作时的默认方式
- 程序存储在内部Flash,掉电不丢失
- 实例：
  - 设备上电正常运行时
  - 产品发货后的工作状态

**系统存储器启动 (Boot0=1, Boot1=0)：**

- 启动内置Bootloader程序
- 用于程序下载和固件更新
- 实例：
  - 通过串口下载程序
  - 通过WiFi无线更新固件
  - 使用ISP方式远程升级
  - 产品返厂维修重新烧录程序

**SRAM启动 (Boot0=1, Boot1=1)：**

- 从内部SRAM启动运行程序
- 主要用于程序调试和测试
- 掉电程序丢失
- 实例：
  - 开发调试阶段
  - 需要高速运行的特殊应用

特别说明下载方式与启动方式的对应关系：

**STLink下载器：**

- 通过JTAG/SWD接口直接操作Flash
- 类似51单片机的烧录器方式
- 主要用于开发阶段

**串口/WiFi下载：**

- 使用系统存储器启动方式
- 通过Bootloader实现程序更新
- 适合产品后期维护升级
- 可以实现远程在线更新

**在实际应用中通常：**

- 正常运行时使用主闪存启动
- 需要更新程序时切换到系统存储器启动
- SRAM启动较少使用

**所以开发阶段使用的是STLink和烧录工具居多，产品出来后，到用户手中后，改用wifi下载程序？**

**开发阶段：**

- 主要使用STLink下载器(JTAG/SWD接口)
- 因为开发时需要：
  - 频繁下载程序
  - 单步调试功能
  - 实时观察变量
  - 断点功能等
- 类似51单片机使用烧录器的方式

**产品发布后：**

正常运行：

- Boot0=0，使用主闪存启动方式
- 运行用户程序

需要更新程序时：

- 通过WiFi远程切换到系统存储器启动模式
- 使用ISP方式更新程序
- 优点是：
  - 用户不需要拆机
  - 不需要专业工具
  - 可以远程批量更新
  - 维护方便

这种方式在物联网产品中特别常见：

- 开发时用STLink调试开发
- 产品出厂后通过WiFi实现远程固件升级(OTA升级)
- 既保证了开发效率，又提供了便捷的升级维护方式

## 两者的调试方式的区别

**STM32F4xx使用STLink下载器外设可以实时调试，但是51使用烧录工具不能实时调试，这就是两者的区别？**

你提到的差异确实是 STM32 和 51 系列单片机开发中的一个显著区别，但这个区别不仅仅在于工具的不同，还涉及到芯片架构和调试机制。

### STM32 (以STM32F4xx为例)

1. **调试工具和机制**
   STM32支持**SWD（Serial Wire Debug）\**或\**JTAG**接口，可以与STLink等调试器结合使用。这种调试接口允许：
   - **实时调试**：**设置断点、单步运行、变量查看和修改等操作都可以直接在运行过程中进行。**
   - **片上调试资源**：STM32芯片内部集成了调试模块（如CoreSight架构的Debug模块），可以在不干扰主程序运行的情况下采集信息。
   - **内存查看**：实时查看和修改寄存器、外设寄存器和内存内容。
2. **芯片设计**
   STM32属于Cortex-M架构，内置调试支持模块（如ITM、DWT等），这些模块专为调试和跟踪任务设计。
3. **调试器功能**
   **STLink下载器不仅是下载工具，还是调试器，具备实时通信能力**。**开发环境（如Keil、IAR、STM32CubeIDE）结合这些工具可以实现实时调试。**

------

### 51单片机

1. **烧录工具和机制**
   传统的51单片机（如STC系列）通常只提供ISP（In-System Programming）接口或UART接口，**用于程序下载，而缺乏专门的调试接口。**
   - **烧录工具**：主要作用是将程序写入Flash，之后通过复位启动运行。
   - **无实时调试支持**：下载后程序直接运行，**调试需要通过打印（如串口调试）或LED指示等手段，无法在运行中直接修改或观察程序状态。**
2. **芯片设计**
   传统的51单片机架构简单，通常没有集成硬件调试模块。如果需要调试，通常只能使用仿真器（如Keil的MON51或ULINK仿真器），但很多情况下硬件仿真器并不常见或被简化。
3. **开发工具差异**
   使用烧录工具时，功能单一（下载代码），不具备调试能力。调试功能依赖于其他仿真工具或软件模拟。

------

### 总结

- **STM32**由于硬件架构和调试器的设计，可以通过STLink实现高效的实时调试，**适合现代复杂项目的开发。**
- **51单片机**由于架构和工具的限制，实时调试能力有限，**更适合简单应用或需要低成本方案的项目。**

如果希望在51平台上实现类似STM32的调试体验，可以考虑使用支持调试功能的仿真器，但通常成本较高且操作复杂。



