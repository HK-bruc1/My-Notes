# 32单片机学习记录6之中断

## 背景1

**STM32F407芯片开发板，我是用if或者while高速轮询SR状态寄存器的状态，来确定是否可以从DR中读取数据，那么在主函数中，我是无法运行流水灯程序的，我的流水灯是通过计数思想通过主函数while（1）实现的。由于我的高速轮询，会卡住CPU从而无法运行流水灯**

问题确实反映了一个常见的嵌入式系统编程挑战：**忙等待（busy waiting）**会占用CPU资源，导致主循环中其他任务（比如你的流水灯程序）无法正常运行。这是因为在高速轮询时，CPU一直在执行查询状态寄存器的代码，导致没有时间去处理其他任务。

**中断机制**

最推荐的方法是使用 **中断** 来替代高速轮询。STM32 的外设（如串口、I2C、SPI 等）通常都支持中断模式，**使用中断可以在数据准备好时触发事件，而不需要CPU主动查询状态。**

- **优点**：中断不占用主循环的CPU时间，数据处理可以独立完成。

- **实现步骤**：

  1. 初始化对应外设的中断（如使能 USART 的 RXNE 中断）。

  2. 在中断服务函数中读取数据。

  3. 在主函数中可以正常运行流水灯程序。

示例代码（假设使用 USART）：

```c
// 中断处理函数
void USARTx_IRQHandler(void) {
    if (USART_GetITStatus(USARTx, USART_IT_RXNE) != RESET) {
        uint8_t data = USART_ReceiveData(USARTx); // 读取数据
        // 处理接收到的数据...
    }
}
```

主函数：

```c
int main(void) {
    // 初始化USART、流水灯等
    USART_ITConfig(USARTx, USART_IT_RXNE, ENABLE); // 开启RXNE中断

    while (1) {
        // 主函数运行流水灯程序
        RunLEDs();
    }
}
```

## 背景2

**串口通信中，使用if还是while高速轮询两种方式的区别，以及数据丢失的风险并举例**

在STM32F407的串口通信中，如果不使用中断并且仅依赖轮询（使用if或while循环），确实会存在数据丢失的风险，尤其是在高速或数据量大的通信场景下。这是因为：

1. 轮询方式的局限性
   - 在轮询模式下，MCU需要不断检查串口状态，这会消耗大量CPU资源
   - 如果程序在检查串口状态的过程中处理其他任务，可能会错过新到达的数据
2. 数据缓冲区溢出
   - 串口硬件的数据寄存器（USART_DR）和状态寄存器（USART_SR）有限
   - 如果数据到达的速度快于程序读取的速度，就会导致新的数据覆盖旧的数据
   - 当硬件缓冲区（FIFO）填满时，后续的数据将会丢失
3. 实时性问题
   - 轮询方式的响应延迟较高
   - 当有大量其他任务或复杂计算时，串口数据检查可能会被延迟

**if 轮询方式：**

```c
void processDataWithIf() {
    // 仅检查一次串口状态
    if(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) != RESET) {
        // 读取单个数据
        uint16_t data = USART_ReceiveData(USART2);
        
        // 处理数据的耗时操作
        processData(data);
        
        // 风险：如果处理过程耗时较长，
        // 期间可能有新数据到达但未被检测,因为后面程序步骤多，来一圈时间长
    }
}
```

风险特点：

- 单次状态检查
- **处理数据期间可能完全丢失后续数据**
- 适用于低速、数据量小的场景
- **丢失数据的概率最高**

while 轮询方式：

```c
void processDataWithWhile() {
    // 持续检查串口状态，直到无可读数据
    while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) != RESET) {
        // 读取所有可用数据
        uint16_t data = USART_ReceiveData(USART2);
        
        // 处理数据
        processData(data);
        
        // 风险：即使使用while，仍可能在处理数据期间
        // 有新数据到达但未及时读取
    }
}
```

风险特点：

- 连续检查串口状态
- 尝试读取所有可用数据
- **相比 if 方式风险略低**
- **但仍无法完全避免数据丢失**
  - 第一个数据接收并处理后
  - 程序执行其他任务
  - 新数据到达
  - **但在下一次轮询之前，硬件缓冲区可能已经溢出,到达多次新数据未即使读取导致覆盖而数据丢失**

具体数据丢失风险示例场景

假设串口通信场景：

- 波特率：115200
- 数据传输频率：高
- 单片机其他任务：复杂计算

if 方式丢失数据示例：

```c
void criticalScenario() {
    // 第一次接收数据
    if(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) != RESET) {
        uint16_t firstData = USART_ReceiveData(USART2);
        
        // 耗时的数据处理
        complexCalculation(); // 假设耗时 10ms
        processFirstData(firstData);
    }

    // 在复杂计算期间：
    // 1. 新数据到达
    // 2. 硬件FIFO可能已满
    // 3. 新数据被覆盖或丢失
}
```

while 方式丢失数据示例：

```c
void criticalScenario() {
    // 读取当前所有可用数据
    while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) != RESET) {
        uint16_t currentData = USART_ReceiveData(USART2);
        
        // 处理当前数据
        processCurrentData(currentData);
    }

    // 执行其他耗时任务
    longRunningTask(); // 假设耗时 20ms

    // 在longRunningTask期间：
    // 1. 可能有多个新数据到达
    // 2. 硬件FIFO可能溢出
    // 3. 部分数据仍可能丢失
}
```

**风险对比**

if 方式：

- 丢失数据概率：非常高
- 适用场景：低速、数据量小
- CPU占用：较低
- 实时性：最差

while 方式：

- 丢失数据概率：较低但仍存在
- 适用场景：中速通信
- CPU占用：中等，没有数据发会一直卡着
- 实时性：稍好

**最佳实践**

推荐解决方案（按优先级）：

1. 中断方式
2. DMA方式
3. 循环缓冲区
4. while 轮询
5. if 轮询

轮询的根本问题

- 无法保证实时性
- 存在数据捕获的时间窗口
- CPU资源浪费
- 难以应对高速数据传输

关键点总结：

- 中断和DMA是解决串口数据丢失的最佳方案
- 轮询（无论 if 还是 while）都无法完全避免数据丢失
- 尤其是在高速通信和复杂系统中

结论：

- 轮询方式（if/while）都无法完全避免数据丢失
- 高速通信必须使用中断或DMA
- 选择轮询方式需谨慎评估通信特点和系统负载

### 合理性和必要性

在串口通信中，使用中断是非常必要且合理的，主要基于以下几个关键原因：

1. 实时性与响应速度
   - 中断可以立即响应数据到达事件
   - 无需轮询，减少CPU资源浪费
   - 数据到达时能够即时处理，避免数据丢失
2. 数据完整性
   - 硬件串口FIFO通常只有1-3个字节深度
   - **轮询模式可能导致数据覆盖或丢失**
   - 中断可以确保及时读取所有接收到的数据
3. 系统资源优化
   - 相比轮询，中断模式CPU占用率更低
   - **可以让MCU在空闲时执行其他任务**
   - 提高系统整体效率和实时性

4. 中断的优势详解

   - 精确捕获每一个数据

   - **避免轮询方式的盲区**

   - 可靠性显著高于轮询

   - 支持高速数据传输场景

5. 适用场景

   - 通信速率 > 9600波特率

   - 数据量大、传输频繁

   - 实时性要求高的系统

   - 需要同时处理多任务的应用

对比总结：

- 轮询：简单但不可靠
- 中断：可靠、高效、实时

因此，在STM32F407等高性能MCU的串口通信中，中断不仅是一种选择，更是一种必然的设计方案。它能够显著提高系统的通信质量、实时性和整体性能。

### 使用中断的条件

**需要中断的程序的共同特点：**

- 被动触发
- 不可预测发生时间
- 随机性强
- 需要快速响应

**使用中断的关键前提：**

硬件支持

- 具备中断请求引脚
- 中断控制器可配置

中断服务程序（ISR）要求

- 执行时间短
- 不包含复杂耗时操作
- 主要进行数据传递和标记

数据安全

- 防止数据竞争
- 使用volatile关键字
- 必要时使用临界段保护

性能考虑

- **中断频率不宜过高**
- **平衡系统实时性**
- **避免频繁中断**

优先级设计

- **合理规划中断优先级**
- **避免中断嵌套过深**
- 防止资源竞争

核心原则：快速、简单、安全、可靠

## 中断控制系统

在CM4中集成了一个用来管理中断机制的控制器-----NVIC中断管理控制器

NVIC控制器的作用:

- 接收中断请求，判断中断事件优先级，指挥CPU按 先后顺序 执行紧急事件（中断服务函数）.

- 注意:紧急事件不能出现死循环,也不能有大量延时

**思考1:**

- 中断跟平时调用的函数有区别吗？

- 执行的程序点有区别：

- 普通函数一定要cpu执行到此函数调用的位置才会执行相应的功能，执行的地点是固定的

- 中断服务函数无论程序此时执行到哪里，只要有紧急事件发生就会去执行中断服务函数，执行的地点是不固定的，随时响应的。

**思考2:**

- 什么时候用中断？

- 不能人为用程序控制此事件发生执行点，随时都有可能发生(CPU执行到任何地方都有可能发生)情况下，为了能实时的响应，就用中断机制。

**常见需要使用中断的场景：**

1. 通信类

   - 串口数据接收

   - CAN总线通信

   - I2C/SPI数据交换

   - USB通信

2. 传感器类

   - 外部温度传感器突发采样

   - 距离传感器检测

   - 加速度传感器中断

   - 陀螺仪数据变化

3. 硬件事件

   - 外部按键触发

   - GPIO电平变化

   - 定时器中断

   - ADC采样完成

   - DMA传输完成

4. 紧急状态

   - 低电压告警

   - 硬件异常中断

   - 电源管理

   - 系统错误

5. 控制类

   - 编码器计数

   - PWM捕获

   - 电机控制

   - 脉冲信号测量

**关键特征：**

- **不可预测发生时间**
- **需要快速响应**
- **无法人为精确控制执行点**
- **随时可能打断当前程序**

### 中断程序设计原则

核心：快进快出，最小化中断开销

**中断程序应该：**

- 执行时间短
- 快速响应
- 仅完成核心动作
- 不进行复杂的数据处理

**推荐做法**

- 只读取数据
- 设置标志位
- 简单数据转移
- 将复杂处理交给主程序

**反例（不好的中断）**

- 大量计算
- 复杂的逻辑判断
- 延时操作
- 文件读写

**正确模式**

- 中断快速capturing数据
- 主程序负责详细处理
- 使用标志位通信

### 谁来触发

中断触发源 在STM32F407中，中断可以由多种源触发：

- 外部硬件中断（GPIO引脚）
- 定时器中断
- 串口中断
- DMA中断
- ADC中断
- I2C/SPI等通信接口中断

中断触发过程 对于您提到的SR（状态寄存器）和DR（数据寄存器）的场景，以串口为例：

- 当接收到一个完整的数据字节时
- SR寄存器中的RXNE（Receive data register Not Empty）标志位会置1
- 如果相应的中断使能位已经打开
- 硬件会向NVIC发送中断请求

NVIC（Nested Vectored Interrupt Controller）中断管理控制器 NVIC的主要职责：

- 接收来自外设的中断请求
- 管理中断优先级
- 决定中断执行的先后顺序
- 将中断请求传递给CPU内核

中断响应流程

- 外设产生中断请求
- NVIC接收并判断中断优先级
- 如果当前没有更高优先级中断正在执行
- 通知CPU执行对应的中断服务函数（ISR）

具体到您提到的通信接口（如SPI/I2C），当DR寄存器接收到数据时：

- 相应的状态寄存器（SR）标志位置1
- 中断使能位已开启
- NVIC会协调中断的触发和响应
- 最终执行预先定义的中断服务程序，读取数据寄存器中的数据

这种机制确保了实时、高效地处理各类中断事件，是微控制器实现实时响应的关键机制。

## 配置中断

### 中断优先级

优先级分类:

- 抢占优先级:  通过设置优先级寄存器设置对应的值 //程序设置
  - 用于决定中断是否能打断其他中断。
  - 优先级值越小，抢占能力越强。

- 响应优先级:  通过设置优先级寄存器设置对应的值 //程序设置
  - 用于决定在相同抢占优先级下的处理顺序。
  - 优先级值越小，响应更快。

- 自然优先级:  是固定，不能通过软件进行配置；  //
  - 固定优先级，取决于中断号的顺序（如编号越小，自然优先级越高）。无法通过软件修改。

说明：优先级的级别值越小，优先级越高。

优先级设置:

- 在CM4中的NVIC控制器，每一个**中断源**都分配了一个8位的寄存器来放置该中断的优先级（抢占响应）

- 注意：在STM32中只用到其中的高四位，低四位为固定值。

- 高四位分为两部分，一部分用来设置中断源的抢占优先级，另一部分用来设置中断源的响应优先级

- 具体抢占优先级和响应优先级各占用多少位 需要根据 设置的优先级分组决定

### **中断源**

![image-20241205162538069](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录6之中断.assets\image-20241205162538069.png)

STM32F407的中断源主要分为以下几类：

1. **外部中断**（如GPIO引脚中断 EXTI0~EXTI15）
2. **系统中断**（如SysTick定时器、PendSV、NMI）
3. **外设中断**（如USART、SPI、I2C、ADC、DMA等外设相关中断）
4. **软件中断**（如通过软件触发的中断）

STM32F407有 **81 个中断通道**，这些通道由NVIC统一管理。NVIC为每个中断源分配一个中断号。

### 优先级分组以及设置

优先级分组决定了抢占优先级和响应优先级的位数分配。在STM32F407中，优先级分组通过 **AIRCR寄存器** 中的 `PRIGROUP` 字段设置：这个寄存器的 10~8 位设置优先级分组（应用程序中断及复位控制寄存器(AIRCR)）

```c
规律：
			写入值 = 7 - 你要设置的抢占优先级的位数
写入值计算方法：
			根据需要确定抢占和响应的级别值              3  2     2 2
			根据抢占的级别值确定抢占占用的位数             
			根据公式确定具体的写入值 
```

**优先级设置**

每个中断源都有一个对应的 **优先级寄存器**（Priority Register），用来存储优先级设置。

- **优先级寄存器为8位宽**，但在STM32中仅高4位有效，低4位固定为0。
- 高4位的分配取决于优先级分组的设置（抢占优先级和响应优先级的位数分配）。

**注意事项**

1. 抢占优先级越高的中断可以打断当前正在执行的低抢占优先级中断。
2. 同抢占优先级的中断通过响应优先级决定执行顺序。
3. 如果两个中断的抢占优先级和响应优先级相同，则通过自然优先级（中断号顺序）处理。

通过合理分配中断优先级，可以确保系统中断处理的实时性和稳定性。

### 中断源对应的优先级寄存器

**每个中断源都有一个对应的 优先级寄存器？那这么多中断源岂不是有很多对应的寄存器？**

确实，**STM32F407的NVIC为每个中断源分配了优先级，但这些优先级寄存器并不是为每个中断源独立分配的**，而是集中管理的。

#### **优先级寄存器的结构**

NVIC的优先级寄存器实际上是一组内存映射寄存器，每个寄存器可以存储多个中断源的优先级配置。

- **STM32F407有 81 个中断通道**。
- 每个中断通道分配 **8 位** 用于优先级存储。
- 由于每个寄存器为 **32 位宽**，所以一个寄存器可以存储 **4 个中断源的优先级**。
- 因此，**81 个中断源的优先级需要用到 81 ÷ 4 = 21 个 32 位寄存器**。

这些寄存器被称为 **NVIC_IPR（Interrupt Priority Registers）**，在STM32F407中，共有 21 个 **NVIC_IPR** 寄存器，位于 NVIC 的地址空间中。

#### **优先级寄存器映射示例**

假设有如下 4 个中断通道，其优先级存储在同一个寄存器中：

| 中断通道 | 对应优先级寄存器 | 偏移地址 | 优先级存储位置 |
| -------- | ---------------- | -------- | -------------- |
| IRQ0     | NVIC_IPR0        | 0x00     | [7:0]          |
| IRQ1     | NVIC_IPR0        | 0x00     | [15:8]         |
| IRQ2     | NVIC_IPR0        | 0x00     | [23:16]        |
| IRQ3     | NVIC_IPR0        | 0x00     | [31:24]        |

**注意：**

- 每个中断通道的 8 位优先级字段中，只有高 4 位有效，低 4 位固定为 0。
- 例如，优先级值 0x10 实际表示中断优先级为 `1`（高 4 位 = 0x1）。

在**32位单片机的设计理念**中，高效利用资源、优化硬件架构是关键目标，尤其是在涉及大量中断源时，单独为每个中断源分配独立的8位寄存器显然是不现实的。

### 中断配置函数（重点）

**NVIC（Nested Vectored Interrupt Controller，嵌套向量中断控制器）**是属于ARM Cortex-M4内核的一部分，因此不同厂商基于Cortex-M4内核开发的芯片在NVIC的寄存器和配置方式上是完全统一的。这就意味着，ARM公司提供的通用配置函数可以直接用于Cortex-M4内核的NVIC配置，而开发者只需掌握这些标准函数的用法即可轻松配置中断。

这些配置函数被定义在 `core_cm4.h` 头文件中，具体来说，它们是由 **CMSIS（Cortex Microcontroller Software Interface Standard）** 标准提供的，CMSIS是ARM为Cortex-M系列设计的一套统一的硬件抽象接口。

#### NVIC管里中断源优先级分组设置(有一个就行)

优先级分组设置不是通过 NVIC 的直接函数来实现，而是通过 **SCB_AIRCR** 寄存器。CMSIS 提供了一个宏定义：

```c
void NVIC_SetPriorityGrouping(uint32_t PriorityGroup);
```

- NVIC管里中断源优先级分组设置   //分配抢占和响应的位数

- 通过对应的寄存器的 8~10 位写值（ 7 6 5 4 3 只有五种组合）

- 函数：
  - void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)----------core-cm4 1435
  - 函数名  ：NVIC_SetPriorityGrouping

- 函数功能  :  设置中断的优先级分组， 分配抢占和响应的位数
- 函数返回值： 无
- 函数参数  ： uint32_t PriorityGroup  //写入值 = 7 - 你要设置的抢占优先级的位数
- 注  意   ：一个工程里只需要一个中断分组，所有中断源共用一个优先级分组
- **位  置   ：通常放在主函数中的其他模块初始化函数上面**
- 练习：
  - 抢占优先级设置2位
  - `NVIC_SetPriorityGrouping(5);`

![image-20241206111549983](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录6之中断.assets\image-20241206111549983.png)

- 只使用高四位分组的话。只能选3，4，5，6，7。就可以发现抢占位数于7的关系。

- 位数就决定了表示范围，进而可以设置的优先级等级范围，响应优先级1，2，3，4，5……

- 如果只有一位的话，响应优先级等级只能设置为0，1

#### 计算优先级编码

​	**设置具体的抢占优先级和响应优先级级别值**

- 函数：

  - `uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)------core-cm4 1592`

  - 函数名：NVIC_EncodePriority

- 功  能：将优先级分组的写入值、抢占优先级值、响应优先级值、计算成一个整型数据返回

- 返回值：u32

- 参  数：
  - 优先级分组(寄存器的 8~10 位的写值)
  - 抢占优先级值（抢占优先级值）
  - 响应优先级值（响应优先级值）

- 注意  ：注意各优先级的值的范围  

- 说明  :  将优先级分组值,抢占级别值,响应级别值,计算成一个u32的数据,返回.

- **位置  :  设置哪个中断源,就把此函数调用在哪个中断源初始化函数中**

- 练习：

  - 设置抢占优先级为1，响应优先级为2

  - `NVIC_SetPriorityGrouping(5);`
  - `u32 pri = NVIC_EncodePriority (5,1,2);`

##### 问题1

**1和2是什么意思？优先级级别吗？抢占优先级大于响应优先级？**

在中断优先级的配置中，“抢占优先级”和“响应优先级”是两种不同的优先级概念：

------

**1. 抢占优先级（Preempt Priority）**

- **定义：**
  **抢占优先级用于决定中断是否可以打断当前正在执行的其他中断**。优先级值越小，抢占优先级越高。
  例如：如果一个抢占优先级为 1 的中断到来时，当前执行的抢占优先级为 2 的中断会被打断。
- **作用：**
  **解决多中断竞争时，哪个中断可以“抢占”CPU。**

------

**2. 响应优先级（Sub Priority）**

- **定义：**
  响应优先级用于**决定同一抢占优先级下多个中断的执行顺序**。优先级值越小，响应优先级越高。
  例如：**如果两个中断抢占优先级相同，响应优先级为 1 的中断会比响应优先级为 2 的中断先执行。**
- **作用：**
  当抢占优先级相同时，定义中断执行的先后顺序。

------

**优先级配置的说明**

**抢占优先级是否高于响应优先级？**

**抢占优先级的权重高于响应优先级**。换句话说：

1. **首先比较抢占优先级**，抢占优先级值小的中断优先执行；
2. 如果抢占优先级相同，则比较响应优先级。

##### 问题2

**问题2：`1` 和 `2` 的含义**

- 定义这个中断的优先级

  - **抢占优先级 = 1**：
    表示此中断的抢占优先级比值更大的中断（如 2、3 等）更高。当更高优先级中断到来时，低优先级中断会被打断。

  - **响应优先级 = 2**：
    表示当多个中断抢占优先级相同时，这个中断的响应优先级低于值更小的中断（如 1）。

例如：

- 中断 A设置：抢占优先级 = 1，响应优先级 = 2
- 中断 B设置：抢占优先级 = 1，响应优先级 = 1

抢占优先级相同的情况下，中断 B 会比中断 A 先执行。

#### 确定具体中断源

​		**将刚才计算出来的优先级编码值,与具体某个中断源联系起来**

- 函数：
  - `void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)-------------core-cm4 1550`
  - 函数名：`NVIC_SetPriority`

- 功  能：设置具体某个中断源的优先级(编码)

- 返回值：无

- 参  数：

  - IRQn_Type IRQn ----具体中断的通道编号（可以直接写名字）    
    - 名字参考stm32f4xx.h文件中的172行
  - priority-----------计算出来的中断优先级编码

- 练习：

  ```c
  将usart2中断，抢占优先级为1，响应优先级为2的中断
  
  设置优先级分组
  
  NVIC_SetPriorityGrouping(5);
  
  计算优先级编码值
  
  u32 pri = NVIC_EncodePriority (5, 1, 2);
  
  确定具体中断源，把这个优先级配置到具体的中断源
  
  NVIC_SetPriority(USART2_IRQn, pri)
  ```

#### 使能NVIC响应通道

NVIC模块响应片上外设中断源的开关   //使能NVIC响应通道

- 函数：
  - void NVIC_EnableIRQ(IRQn_Type IRQn)

- 函数名：NVIC_EnableIRQ

- 作  用：NVIC模块响应片上外设中断源的信号

- 返回值：无

- 参  数：IRQn_Type IRQn ----具体中断的编号（可以直接写名字）

```c
将usart2中断，抢占优先级为1，响应优先级为2的中断

设置优先级分组

NVIC_SetPriorityGrouping(5);

计算优先级编码值

u32 pri = NVIC_EncodePriority (5, 1, 2);

确定具体中断源

NVIC_SetPriority(USART2_IRQn, pri)

启用中断
通过 NVIC_EnableIRQ() 打开 USART2 的中断响应：
NVIC_EnableIRQ(USART2_IRQn);
```

**打开串口中断使能位**

NVIC 只是打开中断控制器的权限，具体中断是否会触发，还需要在 **USART2 外设** 内启用相关的中断源。例如，打开 USART2 的接收缓冲区非空中断（RXNE 中断）：

```c
USART2->CR1 |= USART_CR1_RXNEIE; // 打开接收缓冲区非空中断
```

#### 完整实例

以下是针对 USART2 的中断配置的完整代码：

```c
#include "stm32f4xx.h"
#include "core_cm4.h"

void USART2_NVIC_Config(void) {
    // 1. 设置优先级分组
    NVIC_SetPriorityGrouping(5); // 抢占优先级 2 位，响应优先级 2 位

    // 2. 计算优先级编码值
    uint32_t pri = NVIC_EncodePriority(2, 1, 2); // 分组 2，抢占优先级 1，响应优先级 2

    // 3. 设置中断源 USART2 的优先级
    NVIC_SetPriority(USART2_IRQn, pri);

    // 4. 启用 USART2 中断
    NVIC_EnableIRQ(USART2_IRQn);
}

void USART2_Init(void) {
    // 初始化 USART2，略过详细的串口配置
    // 假设已经配置了波特率、数据位、校验位等
    
    // 5. 打开 USART2 的接收缓冲区非空中断（RXNE 中断）
    USART2->CR1 |= USART_CR1_RXNEIE; // RXNEIE 位 = 1，允许接收中断
}

void USART2_IRQHandler(void) {
    // USART2 中断处理函数
    if (USART2->SR & USART_SR_RXNE) {
        uint8_t data = USART2->DR; // 读取接收数据寄存器，清除中断标志
        // 在此处理接收到的数据
    }
}
```

**说明**

1. **NVIC 的作用**
   - `NVIC_SetPriorityGrouping` 设置优先级分组规则。
   - `NVIC_EncodePriority` 根据分组计算优先级编码。
   - `NVIC_SetPriority` 设置到具体中断源的优先级值。
   - `NVIC_EnableIRQ` 启用指定中断源。
2. **串口中断使能位的作用**
   - NVIC 启用了 USART2 的中断权限，但串口相关的中断是否触发，仍然由串口自身的控制寄存器决定。
   - 在例子中，通过 `USART_CR1_RXNEIE` 位打开接收缓冲区非空中断（RXNE 中断）。
3. **优先级范围**
   抢占优先级和响应优先级的范围由分组规则决定。如果分组设置为非法值（如 5），会导致优先级计算出错。

#### 总结

配置NVIC控制器的四个函数

//优先级分组

void NVIC_SetPriorityGrouping(uint32_t PriorityGroup);

//计算优先级编码值,设置抢占和响应的级别值

uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority);

//设置具体某个中断源的优先级

void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority);

//中断信号响应通道使能

void NVIC_EnableIRQ(IRQn_Type IRQn);

#### 学习和使用建议

1. **理解CMSIS标准**
   `core_cm4.h` 是 CMSIS 的核心部分，它抽象了 NVIC 的底层操作，为开发者提供了易用的接口。学习这些函数，可以让你快速掌握中断配置。
2. **参考芯片厂商的库（如HAL库）**
   厂商通常会基于 CMSIS 提供更高层次的封装（如 HAL 库或 LL 库），在复杂项目中可以结合使用这些库简化开发。
3. **优先级分组的重要性**
   中断的分组和优先级配置是高效中断管理的关键，合理配置抢占优先级和响应优先级可以避免中断冲突。



## 中断服务函数

中断服务函数的本质是一个函数,函数的内容就是紧急事件.

特点：

- 函数名确定-------每个中断源对应有自己的中断服务函数名.  **在启动文件中查找  .s**

- 无参数 无返回值

无需调用（NVIC接收到中断信号,CPU就自动执行中断服务函数）

无需声明

中断服务函数尽量短，不能出现大量延时和死循环

位置：

​	单独创建一个.c文件，nvic.c   

​	此文件专门写中断服务函数

```c
格式：
	void 中断服务函数名(void)
{
紧急事件;
}
```

具体格式说明:

​	以串口1接收中断为例,描述执行过程:

- 每个中断源下面有多个中断信号可以触发,触发了都会进入同一个中断服务函数

- 但是每个中断信号触发执行紧急事件是不一样的,所以要进入中断服务函数后要判断到底是哪个中断信号触发.

```c
void 对应中断函数名(void)
	{
判断是哪个中断信号触发
{
//清除中断标志位(清除状态寄存器的对应状态位)
//紧急事件
}	
	}
```

```c
例子:串口1的接收中断和空闲中断触发
void USART1_IRQHandler(void)
{
	//如果是接收中断触发
	{
	//清除接收中断的标志位
	//紧急事件
	}
    
	//如果是空闲中断触发
	{
	//清除空闲中断标志位
	//紧急事件
	}			
}	
```

### 注意事项

在中断处理函数中直接返回数据是不合适的，因为：

1. **中断上下文**：中断处理程序运行在中断上下文中，通常不应该进行长时间的操作或阻塞操作。你的目标应该是尽可能快地处理中断。
2. **数据处理**：中断处理程序应该尽量简洁，通常是将数据存储到一个全局变量或缓冲区中，然后在主循环或其他任务中处理这些数据。
3. **返回值**：中断处理函数**通常不返回值，它们通过修改全局状态或触发其他事件来传递信息。**

如果你的目标是将数据从中断传递到主程序中，这里有几种方法：

```c
使用全局变量：
volatile char g_receivedData;

void USART1_IRQHandler(void)
{
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        g_receivedData = USART_ReceiveData(USART1);
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}

// 在主循环中
if (someCondition) {
    char data = g_receivedData;
    // 处理data
}
```

**使用信号量或事件标志**：如果你的系统支持实时操作系统（RTOS），你可以使用信号量或事件标志来通知主程序有新数据到达。

选择哪种方法取决于你的具体应用需求、数据传输的速度、以及你是否在使用RTOS等因素。**直接从中断返回数据不是一个标准的做法。**

如果你使用全局变量来传递从中断接收到的数据，你需要在主循环中设置一个条件来检查是否有新的数据可用。以下是几种可能的条件设置方式：

1. **使用一个标志位**：

```c
volatile char g_receivedData = '\0'; // 全局变量
volatile uint8_t g_dataAvailable = 0; // 标志位

void USART1_IRQHandler(void)
{
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        g_receivedData = USART_ReceiveData(USART1);
        g_dataAvailable = 1; // 设置标志位表示有新数据
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}

// 在主循环中
while(1)
{
    if(g_dataAvailable) // 检查是否有新数据
    {
        // 处理g_receivedData
        g_dataAvailable = 0; // 清除标志位
    }
    // 其他代码
}

```

2. **比较数据是否变化**：

```c
volatile char g_receivedData = '\0';
char lastReceivedData = '\0'; // 一个本地变量用于存储上次处理的数据

void USART1_IRQHandler(void)
{
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        g_receivedData = USART_ReceiveData(USART1);
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}

// 在主循环中
while(1)
{
    if(g_receivedData != lastReceivedData) // 检查数据是否有变化
    {
        lastReceivedData = g_receivedData; // 更新上次处理的数据
        // 处理g_receivedData
    }
    // 其他代码
}
```

3. **使用一个计数器**：

如果你需要处理多个字节的数据，可以使用一个计数器来跟踪接收到的字节数。

```c
volatile char g_receivedData;
volatile uint8_t g_dataCount = 0;

void USART1_IRQHandler(void)
{
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        g_receivedData = USART_ReceiveData(USART1);
        g_dataCount++;
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}

// 在主循环中
while(1)
{
    if(g_dataCount > 0) // 检查是否有新数据
    {
        // 处理g_receivedData
        g_dataCount--; // 处理完后减少计数
    }
    // 其他代码
}
```

选择哪种方法取决于你的具体需求。例如，如果你只需要处理单个字节的数据，标志位或数据变化的检测可能就足够了。如果你需要处理多个字节或要确保数据的顺序，计数器方法可能更合适。请注意，访问这些全局变量时需要考虑到原子性和并发访问的问题，特别是在多线程或中断优先级不同的情况下。

### 中断相关的关键字

在使用全局变量与中断服务程序（ISR）或多线程环境时，`volatile`关键字确实很重要，原因如下：

1. **编译器优化**：`volatile`告诉编译器，这个变量可能会被其他程序部分（比如中断服务程序）改变，因此编译器不会对这个变量进行优化，比如不会将其缓存到寄存器中，也不会假设它的值在访问之间不会变化。
2. **多线程/中断环境**：在多线程或中断环境中，`volatile`确保了对变量的读写操作不会被编译器优化掉。特别是在中断可能会改变这个变量的情况下，`volatile`可以确保主程序看到的是最新的值。
3. **避免编译器的死代码消除**：如果一个变量被标记为`volatile`，编译器不会删除或改变对这个变量的任何读写操作，因为它不能假设这个变量不会在运行时发生变化。

```c
volatile u8 g_receivedData = 0; // 全局变量
volatile u8 g_dataAvailable = 0; // 标志位
```

- `g_receivedData` 是从串口接收到的数据，它在中断中被修改，因此需要`volatile`来确保主程序读取到的是最新的数据。
- `g_dataAvailable` 是一个标志位，表示是否有新数据可用，同样因为它在中断中被修改，所以也需要`volatile`。

**不要无所谓地使用或不使用`volatile`**：

- 如果没有`volatile`，编译器可能会对变量的访问进行优化，可能导致你读取到的不是最新的值。例如，如果编译器认为某个变量不会在循环之间改变，它可能会将变量的值缓存到寄存器中，导致在中断更新了变量后，主程序仍然读取到旧的值。
- 在没有`volatile`的情况下，可能会遇到由于编译器优化而导致的难以调试的问题，因为这些问题可能在不同的编译器优化级别下表现不同。

总之，在中断处理或多线程环境中使用全局变量时，`volatile`是非常必要的，它能确保你能正确地读取和写入这些变量。





**串口接收中断服务函数，使用标识位和全局变量是不是只适合一个字节？不适合字符串？**

使用标志位和全局变量来处理串口接收数据的确最适合处理单个字节的情况。对于接收字符串或多个字节的数据，这种方法确实有以下限制：

1. **数据丢失**：如果中断发生的频率很高，在主程序处理完一个字节之前可能已经有新的数据覆盖了旧的数据。
2. **处理延迟**：如果你在主循环中处理数据，可能由于主循环的其他任务而延迟处理，导致数据的实时性下降。
3. **顺序问题**：对于多字节数据，你无法保证接收到的字节顺序不被打乱，因为中断可能在任何时候被触发。

为了更好地处理字符串或多个字节的数据，通常会采用以下几种方法：

- **环形缓冲区（Circular Buffer/Ring Buffer）**：这是一种非常有效的解决方案。数据可以连续写入到缓冲区中，而主程序可以从缓冲区中读取数据。这样可以避免数据丢失，同时保持数据的顺序。

```c
#define BUFFER_SIZE 256
volatile char buffer[BUFFER_SIZE];
volatile int head = 0, tail = 0;

void USART1_IRQHandler(void)
{
    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        char data = USART_ReceiveData(USART1);
        buffer[head] = data;
        head = (head + 1) % BUFFER_SIZE; // 循环写入
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}

// 在主循环中读取数据
while (tail != head) {
    char data = buffer[tail];
    tail = (tail + 1) % BUFFER_SIZE; // 循环读取
    // 处理data
}
```

- **数据包标志**：如果你的数据是以特定的方式封装的（例如以特定的结束符结束），你可以在ISR中识别出数据包的结束，设置一个标志位来通知主程序一个完整的数据包已经接收完毕。
- **使用DMA（Direct Memory Access）**：对于大量数据，DMA可以直接将数据从串口接收到内存缓冲区中，不需要CPU干预，从而提高效率。
- **使用RTOS**：如果你的系统支持实时操作系统，可以利用任务、队列、信号量等机制来处理串口数据，提供更好的数据管理和并发性。
- **双缓冲**：使用两个缓冲区，一个用于接收数据，一个用于处理数据。当一个缓冲区被填满时，切换到另一个缓冲区继续接收数据，处理完毕后再切换回来。

选择哪种方法取决于你的具体需求，如数据传输的速率、数据包的大小、实时性要求等。环形缓冲区是处理串口多字节数据的一个非常常见且有效的解决方案。

### 总结

**因为你也不知道中断服务函数什么时候被调用，所以使用返回值这种做法不合适，甚至都不知道如何接收这个返回值**

正是如此。你提出了一个很关键的点：中断服务函数（ISR）是异步执行的，你无法预测它何时会被调用，因此直接从ISR返回数据给主程序是不切实际的。这是因为：

1. **异步性**：中断可以随时发生，主程序无法等待中断返回数据。
2. **中断上下文**：ISR运行在中断上下文中，通常不允许进行阻塞操作或长时间的处理。
3. **返回值问题**：ISR没有返回值的机制，因为它不是通过函数调用进入的，而是由硬件触发的。

为了处理从ISR接收到的数据，我们通常使用以下方法：

- **全局变量或缓冲区**：在ISR中将数据写入全局变量或缓冲区，然后在主程序中定期或根据某些条件检查这些变量。
- **标志位**：在ISR中设置一个标志位，表示有新数据可用，然后主程序根据这个标志位来决定是否需要处理数据。
- **信号量或事件**：如果使用实时操作系统，可以通过信号量、事件标志等机制在ISR中通知主程序有新数据。
- **回调函数**：在某些系统中，可以注册一个回调函数，当ISR捕获到数据时调用这个回调函数来处理数据，但这通常需要额外的系统支持。
- **环形缓冲区**：用于处理大量数据，避免数据丢失。

选择哪种方法取决于你的系统架构、实时性要求、数据处理的复杂性等因素。在你的情景中，使用全局变量和标志位可能是最直接的解决方案，因为它们不需要额外的系统支持，且实现相对简单。

## 串口中断的使用

### 串口接收中断和串口空闲中断

**串口接收中断的触发机制:**

- 串口控制器接收到数据到DR,状态寄存器的接收完成位自动置1,此时串口控制器就会发出接收中断信号给NVIC控制器,NVIC会指挥CPU去执行串口中断服务函数

**串口空闲中断触发机制:**

- 串口控制器接收到多个字节后,如果没有数据可以接收,状态寄存器的空闲标志位会自动置1,同时触发空闲中断信号给NVIC控制器,NVIC会指挥CPU去执行串口中断服务函数.

- **接收字符串时候,使用空闲中断不用判断结束字符了,空闲中断触发,就意味着字符串接收完成.**

### 两者的作用

串口接收中断：

接收中断的机制是，当串口接收到数据并且数据已经写入接收数据寄存器（DR）时，接收中断会触发。这时，你可以在中断服务函数中读取 DR 寄存器中的数据，从而避免了轮询检查数据的过程。

串口空闲中断：

空闲中断的触发条件与接收中断不同。空闲中断的作用是当串口接收到多个字节的数据后，如果没有新的数据继续接收，且接收线路上出现了空闲状态（即停止传输数据时），空闲标志位会被设置为 1，并触发空闲中断。

具体来说：

1. 当串口接收到一定数量的字节（例如一个完整的消息）并且接收线路没有继续传输数据时，空闲中断会触发。
2. 空闲中断可以用来判断一串连续的数据是否已接收完毕。它通常用于串口接收连续数据或字符串的场景，避免使用特殊的结束符（如换行符或终止符），**因为空闲中断会在数据接收完毕并且空闲状态发生时触发。**

空闲中断的优点：

- **无需轮询**：避免了轮询和频繁检查接收状态的开销。
- **高效**：当数据流停止时，空闲中断即触发，可以进行批量处理数据。
- **更简洁的代码**：在处理大批量数据时，避免了复杂的协议解析或者等待终止符的代码。

### 疑问1

**假如我使用串口跟PC通信，串口调试工具需要约定特俗字符来标识字符串的结束，开发板受到后需要把字符替换为‘\0’变成正常字符串格式，但是使用空闲中断的话，我可以直接等待空闲中断直接在后面加‘\0’？**

是的，使用空闲中断的方式，你可以在接收到完整的字符串时自动处理结束标志，不需要额外依赖于特定的结束字符。

**如何利用空闲中断处理字符串：**

当你使用串口与PC进行通信时，通常 PC 发送的字符串会以特定字符（比如换行符 `\n` 或回车符 `\r`）作为结束标志。然而，如果你使用空闲中断来代替结束字符来检测字符串结束，那么原本需要根据结束符来判断字符串是否完成的代码，可以通过空闲中断来优化。

具体步骤：

1. **接收数据**：
   - 串口接收到每个字节后，通过接收中断（或轮询）将其放入缓冲区。
2. **空闲中断触发**：
   - 当串口接收完数据且空闲时，空闲中断被触发。
   - 空闲中断的作用是指示数据流已经结束，意味着接收数据的最后一个字节之后已经没有新的数据在传输。
3. **在空闲中断中添加 `'\0'`**：
   - 在空闲中断处理函数中，你可以直接在缓冲区的最后一个有效字符后面添加一个 `'\0'` 字符，从而形成一个标准的 C 风格字符串。
   - 由于空闲中断是在接收完成且数据停止时触发，你可以确定数据已经完全接收。

### 疑问2

~~**虽然我PC速度足够快的话，空闲中断如何判断我发完了还是没发完？ 我想发送两串字符串是不是需要间隔久一点？不然会识别为一个长的字符串？**~~

**理论上可以实现，但是实际上如果不是以一次字符串的形式发送，再发送一次字符串时，中间一定会有空闲中断，线路一定会出现空闲。**

~~你提到的一个非常关键的问题是，如何确保空闲中断能够区分两串字符串，而不是误将它们当作一个连续的长字符串。这个问题的核心在于如何判断数据流的结束以及如何处理多个字符串的接收。~~

~~**空闲中断的触发条件：**~~

~~空闲中断触发的机制是基于串口线路上出现“空闲”状态，即没有新的数据到达。通常，空闲中断会在接收完成某个字节并且接下来没有新的数据传输时触发。因此，如果你连续发送两个字符串，而这两个字符串之间没有足够的时间间隔，空闲中断可能会在两者之间的空隙（如果有）触发，从而将它们误判为一个长字符串。~~

~~**解决方法：**~~

~~**在两串数据之间留有间隔**： 如果你需要通过空闲中断来区分两个字符串，确保它们之间有足够的时间间隔是非常重要的。这个间隔可以是一些空闲的时间，或者是通过数据传输协议来人为增加间隔，例如：~~

- ~~**通过特定字符间隔**：你可以通过约定一些字符（如特定的控制字符）来作为两个字符串的分隔符。比如，发送完一个字符串后，可以发送一个空格、换行符或其他控制字符，确保下一个字符串能够明确区分开来。~~
- ~~**发送固定的时间间隔**：确保两串数据之间有一定的延迟。如果发送的速度非常快而没有间隔，空闲中断可能就不能可靠地判断数据接收完毕。~~

~~空闲中断的触发机制是基于串口线路的空闲状态，但如果两串数据之间没有明显的间隔，空闲中断可能会误认为它们是一个长的字符串。因此，解决这个问题的关键是在两个数据之间留出足够的时间间隔，或者使用额外的标识符（如特定字符或时间延迟）来区分数据流。此外，你还可以结合缓冲区大小、超时机制和协议设计来确保数据的正确接收和处理。~~



~~**设定特殊字符的话，我是在空闲中断触发后查看字符串最后一个数据吗？如果是就接收，不是呢？**~~

~~如果你选择设定特殊字符来标识字符串的结束，那么在空闲中断触发后，你确实可以通过检查缓冲区的最后一个接收到的数据来决定是否接收该数据。下面我将详细解释如何利用特殊字符判断字符串的结束，并处理接收到的数据。~~

1. ~~**空闲中断的触发**~~

~~空闲中断通常在串口接收到一串数据后，并且没有新的数据传入时触发。当空闲中断触发时，串口接收的所有数据都已经填充到了缓冲区。~~

2. ~~**判断接收的数据是否完整**~~

~~在空闲中断触发后，你可以检查接收到的缓冲区数据的最后一个字符，如果它是预设的特殊字符（比如换行符 `\n` 或某个自定义字符），则表示字符串接收完成；如果不是特殊字符，你可以选择：~~

- ~~丢弃当前数据（如果不需要）。~~
- ~~或者继续等待下次数据接收（重置SR中的空闲中断状态位，等待下一次触发，就可以接收想要的数据）。~~



**STM32F407，空闲中断，一开始线路就是空闲的啊？难道立马置1？**

在STM32F407的USART（通用同步异步接收发送器）中，空闲中断（IDLE Interrupt）的工作机制比较特殊：

**空闲中断触发条件 当满足以下条件时，空闲中断会被触发：**

- 接收数据完成后
- 总线进入空闲状态
- 最后一个数据传输后的总线空闲状态

**初始状态**

- 上电或复位后，线路确实是空闲的
- 但空闲中断不会立即触发
- 需要有数据传输后，才会在数据传输结束时检测空闲状态

**空闲中断的实际作用**

**检测一帧数据的结束**

- 配合DMA使用，可以快速捕获一次完整的数据传输
- 常用于不定长数据的接收

**注意事项**

- 空闲中断需要与DMA配合使用效果最佳
- 不会在线路最初空闲时立即触发
- 只在数据传输后的空闲状态时触发

简单来说，空闲中断不是在线路初始空闲时触发，而是在一次数据传输完成后，检测到总线进入空闲状态时触发。这种机制特别适合接收不定长数据的场景。



## 程序设计

```
串口初始化配置总体思路
{
    /*IO控制器配置*/
    /*串口控制器配置*/
    /*NVIC控制器配置*/
}

	串口中断服务函数
{

}
---------------------------------------------------------

串口初始化配置详细思路
{
    /*IO控制器配置*/
    //端口时钟使能
    //端口模式配置
    //端口输出类型配置
    //端口输出速度配置
    //上下拉配置
    //复用功能配置
    
    
    /*串口控制器配置*/
    //串口时钟使能
    //CR1 ( 接收中断使能   空闲中断使能  )
    //CR2
    //BRR
    /*NVIC控制器配置*/
    //优先级分组-----------------------------主函数其他初始化上面
    //计算优先级编码值
    //设确定具体中断源
    //使能NVIC响应通道	
}

串口中断服务函数
{
    //判断是接收中断触发
	{
    //清除中断标志位
    //紧急事件
	}
    //判断是空闲中断触发
	{
    //清除中断标志位
    //紧急事件
	}
}
```

## 实战

**开发板与PC通信，PC发送单个字节数据，开发板回送信息给PC，中断服务函数和配置使用nvic的源文件和头文件集中管理。单独创建一个.c文件，nvic.c  此文件专门写中断服务函数**

### nvic.h

```c
#ifndef NVIC_H
#define NVIC_H
#include "stm32f4xx.h"                  // Device header

// 声明全局变量
extern volatile u8 g_receivedData;
extern volatile u8 g_dataAvailable;

// 声明函数
void USART1_NVIC_Config(void);
//void USART1_IRQHandler(void);中断触发不需要对外声明

#endif
```

volatile关键字[使用原因](###中断相关的关键字)

### nvic.c

```c
#include "nvic.h"
#include "stm32f4xx.h"                  // Device header


//定义一个全局变量用于中断程序中读取从DR中的数据
volatile u8 g_receivedData = 0; // 全局变量
volatile u8 g_dataAvailable = 0; // 标志位


void USART1_NVIC_Config(void) {
    // 1. 设置优先级分组为分组
    NVIC_SetPriorityGrouping(5); // 抢占优先级 2 位，响应优先级 2 位

    // 2. 计算优先级编码值
    u32 pri = NVIC_EncodePriority(5, 1, 2); // 分组值5，抢占优先级 1，响应优先级 2

    // 3. 设置到具体的中断源 USART1 的优先级
    NVIC_SetPriority(USART1_IRQn, pri);

    // 4. 启用 USART2 中断
    NVIC_EnableIRQ(USART1_IRQn);
}


//串口1接收完成中断处理函数
void USART1_IRQHandler(void) {
    // 先确定是哪一个信号源
    if (USART1->SR & (1U<<5)) {
        g_receivedData = USART1->DR; // 读取接收数据寄存器，会自动清除中断标志和接收完成标志
				//数据有效
				g_dataAvailable = 1;
    }
}
```

### usart串口1配置处新增配置

开启非空中断

```c
	//发送不用中断不用配置
	// 启用接收非空中断,我判断是否接收完成使用SR中的RXNE：第五位，其对应中断也在第五位
	USART1->CR1 |= 1U<<5;
```

封装为一个函数

```c
//使用接收中断来接收一个字节数据
void usart1_rec_byte_Plus(void){
	// 检查是否有新数据
	if(g_dataAvailable){
		// 处理g_receivedData回送信息给PC
		usart1_send_byte(g_receivedData);
		g_dataAvailable = 0; // 清除标志位
	}
}
```

### 主函数

```c
	//串口配置初始化
	usart1Init(115200);
	//串口1中断配置初始化
	USART1_NVIC_Config();
	
	while(1){
	 usart1_rec_byte_Plus();
	 //没有中断时就跑流水灯
	 waterLed(1);
	}
```

### 局限性

1. **单字节接收中断**：你通过设置 `USART1->CR1` 的第五位（`RXNEIE` 位）来启用接收非空（RXNE）中断。这种方式每当接收到一个字节时，就会触发一次中断。
2. **局限性**：
   - **只能处理单个字节**：因为每接收到一个字节就会触发中断，所以如果你的串口接收的是一个字符串或多字节的数据，你需要在中断处理函数中手动收集这些字节，组成完整的数据。
   - **数据覆盖风险**：如果在处理当前接收到的字节之前又接收到新的字节，新的字节会覆盖旧的字节。这意味着如果你没有及时处理接收到的数据，可能会丢失数据，特别是在高速数据传输的情况下。
3. **处理字符串或多字节数据**：
   - 为了处理字符串或多字节数据，你需要在中断处理程序中实现一个缓冲区来存储接收到的数据。通常会使用一个环形缓冲区（FIFO）或一个固定长度的数组。
   - 你需要维护一个索引来跟踪下一个可用的存储位置，同时要处理缓冲区溢出的情况。
   - 另外，你可能还需要一种机制来知道什么时候一个完整的字符串或数据包已经接收完毕（例如，基于特定的结束字符、长度信息或超时机制）。
4. **改进建议**：
   - **环形缓冲区**：实现一个环形缓冲区来存储接收到的数据，这样可以处理多字节数据。
   - **标志位和计数器**：使用标志位来指示是否正在接收数据，以及一个计数器来跟踪已经接收的字节数。
   - **数据包处理**：如果数据是按包传输的，考虑使用一个结束符（如换行符`'\n'`）或预定义的包长度来确定数据包的结束。
   - **超时处理**：如果数据包没有结束符，可以使用一个超时机制来判定数据包的结束。

总之，你的当前配置确实只能处理单个字节的接收中断，要处理字符串或多字节数据，你需要在软件层面实现更多的逻辑来管理数据的接收和存储。

## 改进二(接收字符串)

**接收中断和空闲中断一起用，接收中断用来接收每一个字符（字节数据），存入数组。空闲中断用来判断是否为字符串的结尾。可以避免使用特殊字符来定义字符串的结束。**

**能成功地接收字符串的话，那么发送字符串也不再话下，逐个字符的发送之后可以再发送换行符号作为一个字符串。**

**这里使用串口打印函数了。**

```c
//全局数组
volatile u8 usart1_buff[50];
//全局字符串接收状体标识
volatile u8 recStrStatu = 0;


//串口1接收完成中断处理函数
void USART1_IRQHandler(void) {
		static u8 i = 0;
    //USART1 中断处理函数
		//接收一个字节数据完成触发中断
    if (USART1->SR & (1U<<5)) {
        usart1_buff[i] = USART1->DR; //通过对 USART_DR 寄存器执行读入操作将该中断状态位清零
				i++;
    }
		
		//当传输多个字节数据后，线路空闲时触发中断
		//该位由软件序列清零（读入 USART_SR 寄存器，然后读入 USART_DR 寄存器）
		if(USART1->SR & (1U<<4)){
				//清除标志位
				//USART1->SR;
				USART1->DR;
				//在这里把缓冲区数组最后面加一个'\0'
				usart1_buff[i] = '\0';
				//重置缓冲区下标
				i = 0;
				//会自动检测尾巴0结束符号
				printf("usart1_buff:\t%s\r\n",usart1_buff);
				//给一个字符串接收完成的标识，定义全局变量，用于外部判断
				recStrStatu = 1;
		}
}
```

## 改进三

因为很多串口都可能需要发送和接收字符串，而发送接收字符串少不了的三要素：数组，长度，接收完成标识。

所以可以定义成结构体，可以对外声明从而只要使用字符串的接收与发送就可以使用。

```c
// 声明全局变量与结构体
typedef	struct{
	u8 usart1_buff[50];
	u32 length;
	u8 usart1StrRec_flag;
}USART1BAL_t;

extern USART1BAL_t usart1_val;
```

