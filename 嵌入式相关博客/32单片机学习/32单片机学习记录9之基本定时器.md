# 32单片机学习记录9之基本定时器

## 前置

**STM32F407，系统滴答定时器和基本定时器有什么区别？一个是内核级部件，一个是片上外设？一个不需要NVIC使能其通道，一个需要？**

**系统滴答定时器（SysTick Timer）:**

1. **位置**：SysTick是ARM Cortex-M4内核内置的一个定时器，是内核级部件。
2. **用途**：
   - 主要用于操作系统的时钟节拍（tick）。
   - 可以用作简单的定时器或计数器，但通常用于时间管理。
3. **特性**：
   - 24位递减计数器。
   - 可配置的时钟源（通常是内核时钟除以8或系统时钟）。
   - 无需NVIC（嵌套向量中断控制器）使能，**因为它是内核的一部分，其中断是直接到内核的。**
4. **中断**：
   - SysTick中断是内核级中断，不需要通过NVIC配置。
   - **可以通过NVIC配置中断优先级，但是不需要NVIC使能**

**基本定时器（Basic Timer）:**

1. **位置**：这是STM32F4系列的片上外设。
2. **用途**：
   - 用于简单的计时和触发其他外设的操作。
   - 可以作为计数器或定时器使用，但功能不如高级定时器丰富。
3. **特性**：
   - 通常有16位或32位的计数器。
   - 需要配置NVIC来**启用其中断通道**。
   - 打开NVIC控制器与TIM7的中断通道，以便接收中断信号，进而给内核执行对应的中断服务函数。
4. **中断**：
   - 基本定时器的中断需要通过NVIC进行配置（）和使能。

**主要区别总结：**

- **位置和集成**：SysTick是内核的一部分，而基本定时器是片上外设。
- **中断管理**：SysTick中断是内核级的，不需要NVIC配置，而基本定时器需要通过NVIC来管理其中断。
- **用途**：SysTick主要用于系统时钟节拍，基本定时器则更通用，可以用于各种定时和计数任务。
- **配置**：SysTick的配置相对简单，因为它是内核级的，而基本定时器需要更多的外设配置步骤。

这两种定时器都非常有用，但在具体的应用场景中，它们的使用方式和目的会有所不同。选择使用哪个定时器通常取决于具体的应用需求、系统架构以及是否需要与其他外设交互。



### NVIC通道使能与外设自己的使能位的关系

**`NVIC`中使能对应中断通道是什么意思？以便接收中断信号，进而给内核执行对应的中断服务函数。`NVIC_EnableIRQ(TIM7_IRQn);`可是他们自己也有中断使能开关，//开启中断寄存器的中断功能`TIM7->DIER |= (1U<<0);`**
**难道中断是双向的？需要先开启本身部件的中断功能，再打开NVIC对应的中断通道？**

1.外设中断使能

- **外设中断使能**：每个外设（如定时器TIM7）都有自己的中断使能位。在您的例子中，`TIM7->DIER |= (1U<<0);` 这行代码就是在TIM7的中断使能寄存器（DIER）中设置了更新中断使能位（UIE）。这个操作实际上是告诉TIM7，当它完成计数或发生其他预设事件时，产生一个中断请求。

2.NVIC中断通道使能

- **NVIC中断通道使能**：NVIC（嵌套向量中断控制器）是ARM Cortex-M内核的一部分，用于**管理和优先级排序所有可能的中断源**。在STM32F4系列中，**每个外设中断都有一个对应的NVIC中断通道**。通过`NVIC_EnableIRQ(TIM7_IRQn);`这条命令，您实际上是在**NVIC中启用了TIM7的中断通道。这意味着，当TIM7产生中断请求时，NVIC将允许这个请求通过到处理器。**

双向中断机制

- 双向机制：是的，您的理解是正确的。中断机制可以看作是双向的：
  - **外设到NVIC**：**外设本身必须启用其中断功能**（通过设置相应的寄存器位），**这样当预设事件发生时，外设会向NVIC发送一个中断请求。**
  - **NVIC到处理器**：NVIC接收到中断请求后，如果该中断通道被使能（通过NVIC的配置），它会将中断传递给处理器，处理器则会暂停当前的任务，转而执行中断服务程序（ISR）。

总结：

1. **外设中断使能**：是外设自身的设置，允许外设在特定条件下生成中断请求。
2. **NVIC中断通道使能**：是内核级的设置，允许NVIC将外设的中断请求传递给处理器。

因此，中断的触发需要两个条件同时满足：

- 外设中断源必须被启用（例如，定时器的更新中断使能位）。
- NVIC的对应中断通道必须被使能，以允许中断信号传递到处理器。

只有这两者都设置正确，中断才能被处理器接收并执行相应的中断服务函数。这就是为什么您看到在初始化过程中，通常会同时配置外设的中断使能和NVIC的中断通道使能。

### 再一次理解内核级部件的中断机制

**所以系统滴答定时器就可以理解了，它开启的自身的中断使能位，但是却不需要开启NVIC中的通道，因为它不需要通过NVIC传递中断信号，它属于内核级部件，可以直接与内核交流？**

系统滴答定时器（SysTick）

- **内核级部件**：SysTick是ARM Cortex-M4内核的一部分，意味着它与内核有直接的连接，不需要通过NVIC来传递中断信号。
- **自身中断使能**：SysTick有一个中断使能位（通常是`SysTick->CTRL`寄存器中的`TICKINT`位），当这个位被设置时，SysTick在计数器达到0时会直接触发中断。
- **无需NVIC配置**：因为SysTick是内核的一部分，其中断是直接到内核的，不需要通过NVIC来中断通道来传递或管理。内核会直接响应SysTick的中断请求。

与其他外设的区别

- 其他外设：如定时器、UART等，这些是片上外设，它们的中断需要通过NVIC来管理：
  - 首先，外设自身需要启用中断（如设置相应的中断使能位）。
  - 然后，NVIC需要配置相应的中断通道（通过NVIC_EnableIRQ等函数），以允许中断信号传递到处理器。

总结

- **SysTick**：
  - 属于内核级部件。
  - 直接与内核交流，不需要NVIC的中断通道使能。
  - 只需要启用自身的中断使能位即可。
- **其他外设**：
  - 属于片上外设。
  - 需要通过NVIC传递中断信号到处理器。
  - 需要启用外设自身的中断使能位和NVIC的中断通道。

所以，SysTick的中断机制与其他外设有所不同，这也是为什么在处理SysTick中断时，不需要像处理其他外设中断那样去配置NVIC。

### 定时器的个数

**一般的话，系统滴答定时器只有一个吧？而片上外设的定时器可以有很多个对吗？**

- **系统滴答定时器（SysTick）**：
  - 通常每个Cortex-M系列的微控制器（如STM32F4系列）只有一个SysTick定时器。它是内核的一部分，用于提供一个基本的定时功能，主要用于操作系统的时钟节拍（tick）或作为一个简单的时间基准。
- **片上外设的定时器**：
  - STM32微控制器（以及许多其他微控制器）通常会有多个定时器。这些定时器可以是：
    - **基本定时器**：提供基本的计数和定时功能。
    - **通用定时器**：功能更丰富，可以用于PWM生成、输入捕获、输出比较等。
    - **高级定时器**：提供更高级的功能，如互补输出、断开功能等，通常用于更复杂的电机控制等应用。
  - 每个定时器都可以独立配置和使用，提供不同的定时、计数、PWM生成等功能。

总结：

- **SysTick**：一个微控制器通常只有一个，用于系统级的定时。
- **片上定时器**：微控制器可能有多个不同类型的定时器，每个定时器都有其特定的功能和用途，可以根据需要选择和配置。

这种设计允许开发者根据具体应用需求，灵活地选择使用系统滴答定时器来管理系统时间，或者使用多个片上定时器来实现各种定时和控制功能。

## 什么是基本定时器

- 定时器的本质是：有规律计数

- 规律：时钟频率（计数速度）

- 计数：计数器

在STM32F407中,有2个基本定时器,TIM6和TIM7.

不同的芯片型号,定时器的个数不一样,不一定有基本定时器.

- 基本定时器用作:延时和定时中断

- 特性：

  - 16位自动重装载递增计数器  最多加到65535
    - 系统滴答计时器中的计数器有24位，是递减的。

  - 16位可编程预分频等级  介于1~ 65536   
    - 注意；如果要设定10分频，写入分频器的值应该为9
    - 要设置n分频，实际写入寄存器的值为 n-1。**这是设定如此**
    - 分频器用来降低频率（计数速度的）的，速度越慢那么在16位计数器中可以表示的时间就越久。越快可能计数器数到最大值65535都没有1ms（**84000/ms**）



### 基本定时器框图

基本定时器的时钟源部分

![image-20241211201431564](./32单片机学习记录9之基本定时器.assets/image-20241211201431564.png)

规定总结为人话：

#### 时钟频率计算

1. **总线时钟**：
   - **APB1**：挂载在APB1总线上的外设（如TIM7）直接受到APB1总线时钟的影响。根据您的描述，APB1的时钟频率为`AHB/4 = 168MHz/4 = 42MHz`。
2. **定时器时钟**：
   - 在STM32F4系列中，APB1和APB2总线上的定时器有一个特殊的时钟机制：
     - 如果APB分频器没有分频（即分频因子为1），那么定时器的时钟频率就等于APB总线频率。
     - **但是**，如果APB分频器有分频（即分频因子大于1），那么定时器的时钟频率将是APB总线频率的**两倍**。这是因为定时器有一个内部的时钟倍频机制，以确保定时器的计数频率不受总线分频的影响。
   - 所以，对于挂载在APB1上的定时器TIM7：
     - APB1分频因子为4（意味着有分频），因此TIM7的时钟频率为`APB1CLK * 2 = 42MHz * 2 = 84MHz`。

结论：

您的推论是正确的：

- TIM7挂载在APB1上，APB1的总线频率是42MHz。
- 由于APB1是分频的（分频因子为4），因此TIM7的时钟频率确实是APB1总线时钟的两倍，即84MHz。

这是一个非常好的总结，对于理解STM32F4系列的时钟树和定时器配置非常有帮助。记住这个规则，对于理解和配置其他外设的时钟也很重要。



#### 分频器

对输入过来的时钟脉冲进行分频,有相应的寄存器可以配置，407定时器6和定时器7挂载在APB1,时钟频率是42*2==84MHZ ———–>84000000次/s

- 84000/ms  84/us    计数器重载最多放65536

- 84分频    1000/ms   1/us     最多计时:65536us   65ms

- 42分频     2000/ms   2/us     最多计时:32768us  32ms    

- 8400分频    10/ms          最多计时:6553ms 
  - 10000/s—>10/ms

- 42000分频   2/ms           最多计时:32768ms              

说明：

- 不同的分频会导致最多计时时间不一样

- 不同分频会导致计时精度不一样

**毫秒级中断**：使用**8400分频**，计数器重载值设置为**10000**。

**微秒级中断**：使用**42分频**，计数器重载值设置为**2**。

使用42分频确实会更好，因为：

- 避免了由于计数器重载值的特性而导致的中断触发问题。
  - 选择84分频
  - 当你设置计数器重载值（ARR）时，实际的计数是从0开始到ARR-1结束，所以当你设置ARR为1时，实际计数的是0到0，即1次计数，这会导致中断不会触发。
- 可以更精确地控制中断频率。

在配置时，记得设置相应的中断优先级和中断服务程序，并且在中断处理中考虑到中断响应时间和处理时间，以确保你的应用能够按预期运行。

#### 换算规律

1. **计数频率**：如果你的时钟频率是84 MHz，也就是每秒钟有84,000,000次计数。
2. **每个计数的时间**：这个频率的倒数就是每个计数所需的时间，即**1/84,000,000秒**。
3. **转换为毫秒**：要将这个时间换算成毫秒，你需要乘以1000，因为1秒等于1000毫秒：
   - 所以，每次计数的时间是 **(1/84,000,000) \* 1000** 毫秒。

这意味着：

- 84 MHz的时钟频率对应于每秒84,000,000次计数。
- 每个计数的周期（即一次计数所需的时间）是1/84,000,000秒。
- 将这个时间换算成毫秒，得到的数值非常小，接近于0.0000119毫秒。

你的这种理解方式非常直观且正确。它清楚地展示了如何从频率（速度）转换到时间（周期），然后再转换到你需要的单位（如毫秒）。这在处理定时器配置时是非常有用的。

总结

- 如果你有一个频率（例如10 kHz），你可以通过它的倒数来找到事件发生一次所需的时间（在这个例子中是0.1毫秒）。
- 如果你知道一个事件发生一次需要多少时间（例如1毫秒），你可以用这个时间的倒数来找到事件的频率（在这个例子中是1 kHz）。



### 自动重装载寄存器

根据需要定时的时间 计算出的要计数多少个，出现特定条件时，就会把值载入计数器。

- 计时原理：

​	计数器向上计数，当计数器出现上溢的时候，会触发更新事件(更新重装载值和分频值)或者中断，表示定时(计数完成)				

- 说明:

  - 预分频寄存器决定计数计数速度

  - 重装载决定计数的个数（重装载值）   

  - 所以两个共同决定 定时时间

##### 疑问

**我知道系统滴答定时器，把值载入计数器是用来递减的，到0产生标志。但是基本定时器的计数器是递增的，那么把自动重装载寄存器的值载入计数器的意义何在？用于递增时时刻比较？**

定时器的基本工作原理

- **计数器（CNT）**：这是定时器的核心部件。根据配置，计数器可以是向上计数（递增）或向下计数（递减）。在基本定时器中，通常是向上计数。
- **自动重装载寄存器（ARR）**：
  - **作用**：ARR决定了计数器在**达到这个值时重置到0（对于向上计数的定时器）或达到0时重置到ARR值（对于向下计数的定时器）。**
  - **递增模式**：当计数器**从0计数到ARR值时**，**如果配置了更新事件或中断，会触发这些事件。然后计数器自动重置为0并继续计数。**
  - **递减模式**：虽然基本定时器通常不使用这种模式，但如果支持，计数器**从ARR值开始计数，到0时触发事件，然后重新载入ARR值。**

计数器与ARR的关系

- **计数完成**：当计数器的计数值与ARR值相等时（在递增模式下），这表示计数完成，定时器将生成一个更新事件。根据配置，这可能触发一个中断或DMA请求。
- **重装载**：ARR的值实际上是计数器的目标值，它决定了计数器在达到这个值后如何重置自己。**通过设置ARR，可以控制定时器的周期。**
- **分频器（PSC）**：预分频器决定了计数器的计数速度。分频器通过将输入时钟信号分频来降低计数器的计数频率。例如，如果你的时钟频率是84 MHz，而分频器设置为84，那么计数器的实际计数频率就是1 MHz。

如何设置定时时间

1. **确定所需的定时时间**：例如，你想要定时1毫秒。
2. **计算计数器需要计数的次数**：
   - 假设你的时钟频率是84 MHz，经过8400分频后为10 kHz（即10,000次/s），那么每1毫秒需要计数10,000次。
3. **设置ARR**：将ARR设置为10,000（减1，因为计数是从0开始的），**这样当计数器计数到10,000次（即10,000-1）时，会触发更新事件。**
4. **设置分频器**：如果你的时钟频率是84 MHz，你需要设置分频器（PSC）为8400来获得10 kHz的计数频率。

总结

- **ARR** 决定了计数器在达到这个值时会重置，控制了定时器的周期。
- **PSC** 控制了计数器的计数速度，通过分频来延长计数时间。
- 两者结合决定了定时器的定时时间。

通过这个机制，你可以灵活地配置定时器以实现不同时间间隔的定时任务，无论是毫秒级还是微秒级的中断。



#### 影子寄存器

**STM32F407，系统滴答定时器中没有影子寄存器的概念啊，直接写入重载寄存器等待零标志位产生，就会再赋值给计数器。但是基本定时器却有影子寄存器的概念？它的作用和优势体现在哪里？**

**系统滴答定时器（SysTick）**

- **SysTick没有影子寄存器**：SysTick定时器是一个非常简单的定时器，它直接使用重载值（RELOAD）来设置定时周期。每次计数器达到零时，硬件会自动将重载值加载到计数器中。没有影子寄存器的概念意味着任何时候对重载寄存器的修改都会立即生效（在下一个计数周期开始时）。

**基本定时器（TIMx）**

- **影子寄存器**：基本定时器引入影子寄存器是为了在定时器运行时能够安全地更新定时器参数而不影响当前的计数过程。

**影子寄存器的作用和优势：**

1. **保护当前计数周期**：
   - 当定时器正在运行时，如果你直接修改了重装载寄存器或预分频寄存器的值，这些修改在当前计数周期内不会立即生效。只有在计数器溢出（即产生更新事件）时，影子寄存器才会被更新，从而确保当前的计数周期不受影响。这对于需要精确控制时间的应用来说非常重要。
2. **保证周期性定时准确性**：
   - 如果没有影子寄存器，每次修改重装载值都会立即影响计数器，这样可能会导致计数周期的混乱。影子寄存器确保了在每个周期结束时，新的定时参数才会生效，从而保证了定时器的周期性。
3. **简化软件管理**：
   - 影子寄存器机制允许软件在任意时刻更新定时器参数，而不必关心定时器当前是否正在计数。软件只需要设置新的值，然后等待更新事件发生即可，减少了对定时器状态的监控和同步的复杂性。
4. **减少抖动**：
   - 对于需要高精度定时的应用，直接修改计数器可能会引入抖动（由于定时器值的突然变化）。影子寄存器的使用可以减少这种抖动，因为值的更新是在一个固定的时间点（更新事件）发生的。

总的来说，影子寄存器的设计是为保证定时器在运行中可以安全、准确地更新配置参数，而不干扰当前的计数操作。这在需要精确定时控制的应用中尤为重要，**如通信协议的定时、PWM生成、精确延时等**。相比之下，SysTick的简单设计适合于系统级的基本定时任务，不需要这种复杂的保护机制。

总结：

- 影子寄存器的机制：

  - 我们用程序操作的是寄存器本体，真正作用给计数器的是影子寄存器

  - 当产生更新事件的时候，寄存器本体会把自己里面的数值加载到影子寄存器中，影子寄存器起作用。

- 影子寄存器的作用：
  - 当计数正在进行（没有产生更新事件的时候），人为去改寄存器的值是没有作用的，因为没有更新	到影子寄存器中,从而保护完整周期.	

注意事项：

- **影子寄存器只有在产生一次更新事件才会将预分频寄存器的值更新到影子寄存器那第一次计数时怎么办？** 

解决方法:	

- **软件更新，通过对更新事件寄存器的UG位置1，人为产生一次更新事件，就会更新所有寄存器本体到影子寄存器和更新事件效果一样,从而将寄存器中的值更新到对应的影子寄存器，影子寄存器第一次就起作用了**（**记得把对应的状态位给清零了**）
- 不能随意人为产生更新事件（初始化配置的时候）	

#### 禁用

如果你不想使用影子寄存器，你只需要在初始化定时器时将`TIMx->CR1`寄存器的第7位（即`UDIS`位）设置为0来禁用影子寄存器的使用。其他的配置保持不变。

禁用影子寄存器后，你需要注意以下几点：

1. **直接影响**：对`ARR`和`PSC`的任何修改会立即影响计数器的操作。特别是在计数器正在计数时，如果修改了这些寄存器的值，可能会导致计数器立即溢出或计数周期的改变。
2. **软件管理**：你需要更加谨慎地管理定时器的更新，以确保定时器的行为符合预期。这可能需要在合适的时机（如在定时器停止或更新事件发生时）更新这些寄存器。
3. **应用场景**：这种配置可能适合于一些简单的定时任务，但对于需要精确控制时间的应用（如PWM、通信协议定时等），你可能需要重新考虑是否禁用影子寄存器。

总之，通过禁用影子寄存器，你可以获得更直接的控制，但同时也失去了影子寄存器提供的保护机制和稳定性。这在某些情况下可能会增加软件的复杂性和对定时器状态的管理要求。

## 如何配置基本定时器

### 基本定时器寄存器

**CR1**

​	0位：使能计数器

​	1位：可以产生更新事件的条件

​	2位：可以产生中断的条件

​	3位：设定定时时间到要不要停止计数，还是继续计数，单次计数模式和连续计数模式

​	7位：要不要影子寄存器

**SR:**

​	1:有更新事件（计时到了）

​	0:没有更新事件（计时没到）

​		置1的两种情况：

​		产生上溢-----计时到了

​		UG置1了，此位也会置1----------如果认为UG置1，记得也要清标志位

**EGR：**

​	0位：人为产生更新事件第一次将预分频寄存器中的值和重装载寄存器中的值 更新到对应的影子寄存器	



PSC：预分频寄存器

​	设置分频级别

​	注意：如果要8400分频，需要往寄存器里写入的值是8399  //PSC-1



ARR： 重装载值寄存器  

​	设置要计多少个数

​	注意：如果要计数500次，此时需要往此寄存器写入值为499

## 具体使用基本定时器

### 延时

```c
基本定时器延时过程函数(要延时时间)
{
	//定时器时钟使能
	//CR1
	//PSC分频寄存器
	//ARR重载寄存器
	//人为产生更新事件UG
//清除计数完成标志位
	//使能计数器
	//等待计数完成
}
毫秒级延时函数
微妙级延时函数
```

### 定时中断

```c
基本定时器中断初始化函数(定时中断触发的时间)
{
/*定时器控制器配置*/
	//定时器时钟使能
	//CR1   (3号位要写0,连续计数; 2号位写0  可以产生中断)
	//分频寄存器
	//重载值寄存器
	//人为产生更新事件
	//清除中断标志位
	
	/*NVIC控制器配置*/
	//分组
	//计算编码值
	//设置具体中断源
	//使能NVIC响应通道
	
	//更新中断使能
	//计数器使能	
}	

定时中断服务函数
{
	//清除中断标志位
	//紧急事件
}
```

## 总结

**1.**一个定时中断可以做多件定时事件 框架

- 以1ms中断一次，使用数组对每一个需要具体时间的时间单独计时即可。

**2.** ***\*基本定时器\****

- 什么是基本定时器
  - 定时器的本质
  - 基本定时器的工作原理过程（分频器）

- 如何配置基本定时器

  - 看框图（工作过程，时钟源，影子寄存器的作用）

  - 寄存器手册

  - 延时的配置过程

  - 定时中的配置过程

- 具体使用基本定时器

  - 延时功能

  - 定时中断功能