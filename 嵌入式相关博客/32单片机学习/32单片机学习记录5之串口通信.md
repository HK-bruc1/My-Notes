# 32单片机学习记录5之串口通信

## 前置

**STM32的GPIO口有通用模式，复用模式，模拟模式三种，加上输入输出就是有6中对应的模式。 我学习了通用模式，会使用GPIO口使用一些简单外设，如LED，独立按键，红外感应器等。但是一些复杂的外设，传递不是高低电平了，那么通用模式已经不够用了。如WiFi模块，蓝牙模块，这个时候就要学习复用模式了。而串口通信就是复用模式下某一类外设的统一通信标准是吗？**

1. GPIO模式确实包括三种基本模式：
   - 通用模式（GPIO）
   - 复用模式（Alternate Function）
   - 模拟模式（Analog）
2. 输入输出方向又进一步细分为：
   - 输入
   - 输出
   - 推挽输出
   - 开漏输出
3. 通用模式适合简单的数字输入输出，如你提到的：
   - LED控制
   - 独立按键
   - 简单的数字传感器（如红外感应器）
4. **复用模式的确是为了连接更复杂的外设而设计的。这些外设需要特定的通信协议或信号传输方式**，如：
   - WiFi模块
   - 蓝牙模块
   - UART/USART串口通信
   - SPI
   - I2C
   - CAN总线
   - 以太网接口等
5. 关于串口通信：
   - **串口（UART/USART）是一种复用模式下的通信标准**
   - 它使用两根线进行双向通信：TX（发送）和RX（接收）
   - 每个GPIO口可以配置为串口的发送或接收端口
   - 这种模式下，数据不再是简单的高低电平，**而是按照特定的波特率和协议传输数据**

总的来说，你的理解是正确的。**复用模式让STM32能够与更复杂的外设进行通信，不再局限于简单的高低电平控制。串口通信就是复用模式的一个典型应用，是微控制器与外部设备进行数据交换的重要方式。**



**内核也只知道机器码吧？GPIO的通用模式也要经过数字寄存器转换，复用模式和模拟模式也要经过特殊的控制器与内核交流？**

**内核与指令**

- 内核确实只能直接执行机器码
- 对于任何GPIO操作，最终都会转换为特定的机器指令

**GPIO操作的基本流程**

- 通用模式：
  - 通过配置寄存器设置GPIO的工作模式
  - 数字寄存器负责控制输入/输出状态
  - 使用类似 GPIOA->ODR 这样的寄存器地址来直接操作
- 复用模式：
  - 需要额外的复用映射寄存器（AFRL/AFRH）
  - 配置特定GPIO口的复用功能
  - 由专门的复用控制器处理信号路由
- 模拟模式：
  - 通常用于ADC、DAC等模数转换
  - 使用模拟控制寄存器
  - 信号需要经过模拟前端电路处理

**寄存器与内核交互**

- 所有模式最终都是通过映射到内存的寄存器地址来实现
- 内核通过总线直接读写这些寄存器
- 不同模式下，寄存器的配置和使用方式有所不同



**所以复用模式需要经过如串口控制器与内核交流，模拟模式需要经过ADC或则DAC控制器与内核交流，这一些都属于单片机上的外设也就是片上外设。 所以与单片机外的外设交流时，选择对应的模式，到时候片上外设会把信息转换为内核认识的机器码的？**

**片上外设（On-Chip Peripherals）**

- 这些外设集成在微控制器芯片内部
- 包括：
  - 串口控制器（USART/UART）
  - ADC控制器
  - DAC控制器
  - I2C控制器
  - SPI控制器
  - 定时器
  - 等等

**通信过程**

- 片上外设作为内核和具体硬件功能之间的桥梁
- 负责将上层逻辑转换为底层硬件可识别的信号
- 将硬件返回的信号转换为内核可理解的数据

**与外部设备通信**

- 选择合适的通信模式（如复用模式）
- 片上外设控制器负责：
  - 信号电平转换（如**通用模式下的数字寄存器**）
    - 数字寄存器将内核的逻辑电平指令**转换**为实际的GPIO电平
    - 控制输出高低电平
    - 读取输入引脚的电平状态
    - 处理电平的开关、翻转等基本操作
  - 协议实现（如**复用模式下的串口控制器**）
    - 实现特定通信协议的底层细节
    - 串口控制器负责：
      - 按照串口通信协议发送数据帧
      - 处理起始位、数据位、校验位、停止位
      - 管理波特率
      - 处理数据的发送和接收缓冲区
    - SPI控制器管理时钟同步、数据移位
    - I2C控制器处理起始信号、从机地址、数据传输等
  - 数据编解码
    - 将内核的数据**转换**为通信接口能识别的格式
    - 对数据进行打包、解包
    - 处理数据的序列化和反序列化
    - 执行必要的数据转换（如二进制到串行）
  - 时序控制
    - 管理通信的时间节奏
    - 控制信号的定时和同步
    - 处理通信协议中的时序要求
    - 管理超时、延迟等时间相关的逻辑

这些职责使得片上外设控制器能够有效地在内核逻辑和具体硬件接口之间进行无缝转换，是微控制器实现复杂通信的关键。

**不同外设通信模式**

- 串口（UART/USART）：使用复用模式
- 模拟传感器：使用模拟模式和ADC
- I2C/SPI：特定的复用模式
- CAN总线：专门的总线控制器模式

所以你的理解完全正确：**片上外设就是内核与具体硬件功能之间的"翻译官"，负责将抽象的指令转换为具体的硬件操作，并将硬件返回的信号转换为内核可理解的数据格式。**



### 一句话总结串口通信是什么

串口通信是单片机在复用模式下实现的一种与单片机外部设备进行数据交换的通信标准和方式。

这个总结精准地概括了串口通信的本质：

1. 使用复用模式
2. 针对片外设备
3. **是一种标准化的通信方式**

### 学习重点

在STM32中，学习复用模式下的串口通信（USART/UART）是一项非常重要的技能，因为串口是嵌入式系统中最常用的通信接口之一。以下是学习步骤和关键知识点：

#### **学习步骤**

##### 1. **理解串口通信的基本原理**

- 串口通信是一种**异步通信**方式，通过发送和接收数据帧进行通信。
- 数据帧的基本组成包括起始位、数据位、校验位（可选）、停止位。
- 熟悉常见的参数配置：
  - 波特率（Baud Rate）：如9600、115200。
  - 数据位：一般是8位。
  - 校验位：奇校验、偶校验或无校验。
  - 停止位：1位或2位。

##### 2. **熟悉 STM32 的硬件资源**

- 阅读目标 STM32 芯片的参考手册（Reference Manual）和数据手册（Datasheet）。
- 确认 UART/USART 外设的数量、对应引脚、复用功能（AF）编号。
- 查看 RCC（复位与时钟控制）部分，找到启用 UART 外设的相关时钟配置。

##### 3. **硬件配置与引脚复用**

- 使用 GPIO 的复用模式（Alternate Function Mode）将特定引脚设置为 UART_TX 和 UART_RX。
- 查阅引脚复用表，找到需要配置的 GPIO 引脚和对应的 AF 编号。

##### 4. **串口配置与初始化**

- **使用 STM32 的 HAL 库或直接操作寄存器：**
  1. 启用时钟（RCC）。
  2. 配置 GPIO 引脚为复用功能。
  3. 初始化 USART/UART 外设，包括设置波特率、数据格式等。
- 推荐使用 **CubeMX** 工具生成代码进行初始学习，便于快速理解配置流程。

##### 5. **实现基本的串口通信**

- 编写简单的发送（`HAL_UART_Transmit`）和接收（`HAL_UART_Receive`）程序，发送一串字符或者接收外设返回的数据。
- **配合串口调试工具（如 SecureCRT、XCOM），测试通信是否正常。**

##### 6. **学习中断和 DMA 模式**

- **中断模式**：学习如何配置串口中断，实现数据的非阻塞收发。
- **DMA 模式**：使用 DMA 进行高效的数据传输，适合处理较大数据量的通信。

##### 7. **学习高级通信协议**

- 基于串口实现常用的通信协议（如 Modbus、AT 指令解析）。
- 如果应用涉及 WiFi 或蓝牙模块，可以编写驱动程序，解析模块返回的数据。



#### **关键知识点**

##### 1. **GPIO 复用模式**

- STM32 GPIO 的复用功能配置，如何根据具体型号找到正确的复用功能编号（AFx）。

##### 2. **RCC 配置**

- USART/UART 外设依赖时钟，需正确启用时钟（APB1/APB2）。

##### 3. **USART 寄存器**

- 理解关键寄存器的作用：
  - `USART_BRR`：设置波特率。
  - `USART_CR1`：控制串口启用、中断、数据格式等。
  - `USART_SR`：状态寄存器，用于检查发送和接收状态。

##### 4. **数据缓冲**

- 如果数据量较大，需熟悉 FIFO 缓冲区的实现，避免数据丢失。

##### 5. **错误处理**

- 常见错误类型：
  - 帧错误（Frame Error）
  - 过载错误（Overrun Error）
  - 噪声错误（Noise Error）
- 了解如何通过状态寄存器（`USART_SR`）检测错误并进行处理。

##### 6. **HAL 与 LL 库的使用**

- HAL 库简单易用，适合快速开发。
- LL（Low Layer）库提供更高效、灵活的控制，适合优化程序性能。

##### 7. **串口通信的调试**

- 串口调试工具：学会使用串口调试助手查看发送和接收的数据。
- 使用逻辑分析仪或示波器验证通信信号的正确性。



#### **推荐的实践项目**

1. **单片机与电脑通信**
   - 发送固定字符串到电脑终端显示。
   - 接收电脑输入的字符并回显。
2. **与传感器通信**
   - 接收传感器通过串口发送的测量数据。
3. **模块驱动开发**
   - 驱动 WiFi 模块（如 ESP8266）的 AT 指令解析。
   - 蓝牙模块数据收发。
4. **数据记录**
   - 将测量数据通过串口发送到电脑并存储为文件。

## 串口参数详解

- 串口通信是一种**异步通信**方式，通过发送和接收**数据帧**进行通信。
- 数据帧的基本组成包括**起始位、数据位、校验位（可选）、停止位。**
- 熟悉常见的参数配置：
  - 波特率（Baud Rate）：如9600、115200。
  - 数据位：一般是8位。
  - 校验位：奇校验、偶校验或无校验。
  - 停止位：1位或2位。

### **波特率：发送速率还是接收速率？**

**波特率**（Baud Rate）表示串口通信中**每秒钟传输的符号数**，通常等于**每秒的比特数**（bps，bits per second），它是发送和接收的统一速率。

- 在异步通信中，通信双方（发送端和接收端）必须配置相同的波特率，以确保数据能够正确解析。

**发送与接收关系：**

1. **单向通信**：
   - 如果只发送或只接收，波特率仅反映这一方向的速率。
   - 例如：传感器发送数据给主控芯片，主控只需要按照传感器设定的波特率去接收。
2. **双向通信**：
   - 对于全双工通信（同时发送和接收），波特率定义了每个方向的最大传输速率。
   - 例如：一端以 115200 的波特率发送，另一端必须以 115200 的波特率接收。

**补充：波特率与实际数据吞吐量**

实际的数据吞吐量可能低于波特率，因为一个数据帧中包含额外的控制位：

- 每帧至少包含 1 位起始位、8 位数据位、1 位校验位（可选）和 1 位停止位。
- 如果波特率是 9600 bps，每秒可传输的有效数据量 = 9600÷(1+8+1+1)=8009600 \div (1 + 8 + 1 + 1) = 8009600÷(1+8+1+1)=800 字节。

### IP网络数据包中的数据帧

**IP网络数据包中不是也有数据帧吗？这算不算相似之处？**

IP 网络数据包中的确也包含“数据帧”的概念，这是它与串口通信的一大相似之处。两者的**相似性**主要体现在分层结构和帧的功能上。我们可以从通信协议的层次角度来深入理解这种关联：

#### **IP 网络中的数据帧**

在网络通信中，“数据帧”是链路层的基本单位。根据 OSI 模型，IP 数据包和数据帧分别属于不同的层次：

1. **数据帧（Frame）**：
   - 位于 **链路层**，由网络设备（如网卡）负责处理。
   - 典型的帧结构包括：
     - **帧头部（Header）**：包含 MAC 地址、帧类型等链路层信息。
     - **帧有效载荷（Payload）**：通常是 IP 数据包。
     - **帧尾部（Footer）**：可能包含校验码（CRC）等信息。
   - 数据帧的作用是封装和传输 IP 数据包，并在链路级别进行校验。
2. **IP 数据包（Packet）**：
   - 位于 **网络层**，是数据传输的核心单位。
   - 包括：
     - **IP 头部**：包含源 IP、目的 IP、协议类型等信息。
     - **IP 载荷**：传输的数据（通常是 TCP/UDP 段）。
   - IP 数据包依赖数据帧在底层网络上传输。

#### **串口通信中的“数据帧”**

- 串口通信中，数据帧是最基本的传输单位，直接封装要传输的数据。
- 类似链路层的帧，它定义了起始位、停止位、校验位等，确保数据可靠性。

#### **IP 网络与串口通信的相似性**

1. **结构化数据帧的使用**
   - 两者都使用明确的数据帧结构来保证通信的可靠性和可解析性：
     - IP 网络：链路层数据帧封装 IP 数据包，IP 数据包再封装上层协议数据。
     - 串口通信：数据帧直接封装要发送的数据。
2. **校验与错误检测**
   - IP 网络的链路层数据帧和串口通信的数据帧都可以通过校验位（如 CRC 或奇偶校验）来检测数据传输过程中的错误。
3. **分层与封装**
   - IP 网络有完整的协议栈，链路层、网络层、传输层分工明确，数据逐层封装。
   - 串口通信虽然没有复杂的分层，但数据帧也起到了基础封装的作用，承担了部分链路层的功能。
4. **点对点传输**
   - 两者都是点对点的传输方式：
     - IP 数据包通过链路层的点对点数据帧传输。
     - 串口通信直接在设备间点对点传输数据帧。

#### **不同点**

| **特点**           | **串口通信数据帧**                 | **IP 网络数据帧**                        |
| ------------------ | ---------------------------------- | ---------------------------------------- |
| **作用范围**       | 嵌入式系统、短距离设备通信         | 广域网、局域网等复杂网络环境             |
| **传输协议复杂度** | 简单，没有多层协议                 | 多层协议栈，包含链路层、网络层、传输层等 |
| **可靠性保障**     | 基本靠校验位，通常需要软件补充处理 | 包含校验、重传机制（如 TCP）             |
| **封装内容**       | 数据 + 起始位/校验位/停止位        | 网络层 IP 包 + MAC 地址等链路层信息      |
| **应用场景**       | 硬件调试、模块通信                 | 网络设备互联                             |

------

#### **总结**

IP 网络的数据帧与串口通信的数据帧在概念和功能上确实存在相似之处，尤其在结构化和校验机制上。不过，IP 网络的数据帧是更高级通信模型中的一个子集，包含更多分层设计和复杂功能。两者的相似性反映了通信系统设计的通用思想：**通过数据帧实现可靠的点对点传输**。

### 传输与解析过程详解

**串口传输路径与解析过程，比如一台MCU与另一台MCU通信，详细到单片机内部路径包括内核**