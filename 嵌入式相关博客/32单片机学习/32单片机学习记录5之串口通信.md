# 32单片机学习记录5之串口通信

## 前置

**STM32的GPIO口有通用模式，复用模式，模拟模式三种，加上输入输出就是有6中对应的模式。 我学习了通用模式，会使用GPIO口使用一些简单外设，如LED，独立按键，红外感应器等。但是一些复杂的外设，传递不是高低电平了，那么通用模式已经不够用了。如WiFi模块，蓝牙模块，这个时候就要学习复用模式了。而串口通信就是复用模式下某一类外设的统一通信标准是吗？**

1. GPIO模式确实包括三种基本模式：
   - 通用模式（GPIO）
   - 复用模式（Alternate Function）
   - 模拟模式（Analog）
2. 输入输出方向又进一步细分为：
   - 输入
   - 输出
   - 推挽输出
   - 开漏输出
3. 通用模式适合简单的数字输入输出，如你提到的：
   - LED控制
   - 独立按键
   - 简单的数字传感器（如红外感应器）
4. **复用模式的确是为了连接更复杂的外设而设计的。这些外设需要特定的通信协议或信号传输方式**，如：
   - WiFi模块
   - 蓝牙模块
   - UART/USART串口通信
   - SPI
   - I2C
   - CAN总线
   - 以太网接口等
5. 关于串口通信：
   - **串口（UART/USART）是一种复用模式下的通信标准**
   - 它使用两根线进行双向通信：TX（发送）和RX（接收）
   - 每个GPIO口可以配置为串口的发送或接收端口
   - 这种模式下，数据不再是简单的高低电平，**而是按照特定的波特率和协议传输数据**

总的来说，你的理解是正确的。**复用模式让STM32能够与更复杂的外设进行通信，不再局限于简单的高低电平控制。串口通信就是复用模式的一个典型应用，是微控制器与外部设备进行数据交换的重要方式。**



**内核也只知道机器码吧？GPIO的通用模式也要经过数字寄存器转换，复用模式和模拟模式也要经过特殊的控制器与内核交流？**

**内核与指令**

- 内核确实只能直接执行机器码
- 对于任何GPIO操作，最终都会转换为特定的机器指令

**GPIO操作的基本流程**

- 通用模式：
  - 通过配置寄存器设置GPIO的工作模式
  - 数字寄存器负责控制输入/输出状态
  - 使用类似 GPIOA->ODR 这样的寄存器地址来直接操作
- 复用模式：
  - 需要额外的复用映射寄存器（AFRL/AFRH）
  - 配置特定GPIO口的复用功能
  - 由专门的复用控制器处理信号路由
- 模拟模式：
  - 通常用于ADC、DAC等模数转换
  - 使用模拟控制寄存器
  - 信号需要经过模拟前端电路处理

**寄存器与内核交互**

- 所有模式最终都是通过映射到内存的寄存器地址来实现
- 内核通过总线直接读写这些寄存器
- 不同模式下，寄存器的配置和使用方式有所不同



**所以复用模式需要经过如串口控制器与内核交流，模拟模式需要经过ADC或则DAC控制器与内核交流，这一些都属于单片机上的外设也就是片上外设。 所以与单片机外的外设交流时，选择对应的模式，到时候片上外设会把信息转换为内核认识的机器码的？**

**片上外设（On-Chip Peripherals）**

- 这些外设集成在微控制器芯片内部
- 包括：
  - 串口控制器（USART/UART）
  - ADC控制器
  - DAC控制器
  - I2C控制器
  - SPI控制器
  - 定时器
  - 等等

**通信过程**

- 片上外设作为内核和具体硬件功能之间的桥梁
- 负责将上层逻辑转换为底层硬件可识别的信号
- 将硬件返回的信号转换为内核可理解的数据

**与外部设备通信**

- 选择合适的通信模式（如复用模式）
- 片上外设控制器负责：
  - 信号电平转换（如**通用模式下的数字寄存器**）
    - 数字寄存器将内核的逻辑电平指令**转换**为实际的GPIO电平
    - 控制输出高低电平
    - 读取输入引脚的电平状态
    - 处理电平的开关、翻转等基本操作
  - 协议实现（如**复用模式下的串口控制器**）
    - 实现特定通信协议的底层细节
    - 串口控制器负责：
      - 按照串口通信协议发送数据帧
      - 处理起始位、数据位、校验位、停止位
      - 管理波特率
      - 处理数据的发送和接收缓冲区
    - SPI控制器管理时钟同步、数据移位
    - I2C控制器处理起始信号、从机地址、数据传输等
  - 数据编解码
    - 将内核的数据**转换**为通信接口能识别的格式
    - 对数据进行打包、解包
    - 处理数据的序列化和反序列化
    - 执行必要的数据转换（如二进制到串行）
  - 时序控制
    - 管理通信的时间节奏
    - 控制信号的定时和同步
    - 处理通信协议中的时序要求
    - 管理超时、延迟等时间相关的逻辑

这些职责使得片上外设控制器能够有效地在内核逻辑和具体硬件接口之间进行无缝转换，是微控制器实现复杂通信的关键。

**不同外设通信模式**

- 串口（UART/USART）：使用复用模式
- 模拟传感器：使用模拟模式和ADC
- I2C/SPI：特定的复用模式
- CAN总线：专门的总线控制器模式

所以你的理解完全正确：**片上外设就是内核与具体硬件功能之间的"翻译官"，负责将抽象的指令转换为具体的硬件操作，并将硬件返回的信号转换为内核可理解的数据格式。**



### 一句话总结串口通信是什么

串口通信是单片机在复用模式下实现的一种与单片机外部设备进行数据交换的通信标准和方式。

这个总结精准地概括了串口通信的本质：

1. 使用复用模式
2. 针对片外设备
3. **是一种标准化的通信方式**

### GPIO口与串口以及ADC,DAC的关系

**我看STM32的芯片内部框图，有串口通信专门端口，也有ADC,DAC的专门端口，为什么要说他们是复用模式和模拟模式下的通信方式？这意思是我还需要去GPIO口设置模式？可是他们并不在一个端口上啊？设置通用模式，是因为需要直接使用GPIO去输出或者检测高低电平**

**在STM32微控制器中，很多引脚实际上是具有多功能的。虽然像USART（串口）、ADC、DAC看起来有专门的端口，但这些端口通常都复用在GPIO（通用输入/输出）引脚上。**这种设计的原因主要有以下几点：

1. 引脚资源复用
   - 芯片的物理引脚数是有限的
   - 通过引脚复用，可以让同一个物理引脚在不同模式下具有不同的功能
   - 这样可以在有限的引脚上实现更多的功能
2. 模式切换
   - GPIO模式不仅仅是简单的输入输出
   - 它可以通过配置寄存器切换为多种功能：
     - 数字输入
     - 数字输出
     - 复用功能（如串口、SPI、I2C等）
     - 模拟功能（如ADC采样）
3. 具体的模式设置
   - 对于串口USART，需要配置为复用模式
   - 对于ADC，需要配置为模拟输入模式
   - 这些配置通过GPIO配置寄存器完成

举个具体的例子：

- PA9和PA10是USART1的发送和接收引脚
- 这两个引脚默认是GPIO口
- 要使用串口功能，需要：
  1. 配置为复用模式（AF模式）
  2. 选择正确的复用功能（这里是USART1）

对于ADC，比如PA0作为ADC通道：

- 需要配置为模拟输入模式
- 这样才能正确进行模数转换

所以，即便看起来STM32有专门的串口、ADC端口，实际上这些功能都是通过GPIO引脚的模式切换来实现的。这种设计提供了极大的灵活性，使得同一个引脚可以根据需要配置为不同的功能。

你的理解是对的：需要通过配置GPIO的模式来决定引脚的具体功能，这正是STM32灵活性的体现。



**我终于知道GPIO口的复用模式的名称由来了，但是内部框图为了好理解，还是把它分开画了？**

内部框图这样分开画主要是为了便于理解和直观展示不同功能模块。

内部框图这种设计有几个重要的目的:

1. 清晰展示功能
   - 即使物理上是复用的,但逻辑功能是不同的
   - 分开画可以让读者更容易理解每个功能模块的工作原理
2. 逻辑解耦
   - 尽管引脚物理上复用,但功能逻辑是独立的
   - 框图反映了芯片内部功能模块的逻辑结构
3. 方便设计和理解
   - 开发者可以更清晰地看到每个功能模块的信号流
   - 有助于理解芯片的内部架构和信号处理方式

简单来说,这就像是地铁线路图。实际上列车可能共用some轨道,但为了方便理解,路线图还是会把每条线路分开画。内部框图也是同样的设计思路 - 为了清晰和易懂。

### GPIO引脚复用的原理

[具体配置传送门](###IO口的复用功能如何配置)

STM32F407的丰富外设确实主要是通过GPIO口的复用功能来实现的。这是STM32微控制器的一个典型特点。让我详细解释一下：

GPIO复用功能

- STM32F407的GPIO口具有强大的复用功能
- 每个GPIO口可以通过配置复用为不同的外设功能
- 同一个物理引脚可以根据需要切换不同的功能模式

复用模式示例

- USART通信：可以将GPIO口配置为串口发送/接收引脚
- I2C：可以复用为SCL和SDA信号线
- SPI：可以配置为MOSI、MISO、SCK等信号
- CAN总线：可以复用为CAN_TX和CAN_RX
- USB：可以配置为USB通信引脚

复用优点

- 节省芯片引脚资源
- 提高芯片集成度
- 灵活配置外设功能
- 降低PCB设计复杂度

复用配置

- 需要通过STM32的寄存器进行精确配置
- 涉及GPIO端口选择
- 设置引脚的具体复用功能
- 配置工作模式（输入/输出/复用）

实际应用

- 开发时需要仔细规划GPIO口的复用
- 避免不同外设间的引脚冲突
- 合理利用有限的物理引脚

这种GPIO复用设计是STM32微控制器的一个重要特色，大大增强了微控制器的灵活性和功能扩展性。



**但其实不是每一个GPIO口都能复用所有的功能的，需要看原理图，才知道GPIO口物理设计时实际复用了什么功能，才能使用AFIO寄存器来选择复用功能？**

GPIO复用的物理限制

- 并非所有GPIO口都可以任意复用所有功能
- 每个引脚的复用功能是在硬件设计时就已经确定的
- 芯片内部的引脚复用矩阵是有具体物理连接限制的

原理图的重要性

- 查看原理图是确定具体GPIO口可用功能的关键
- **原理图详细标注了每个引脚的实际可复用功能**
- 不同的开发板即使使用同一型号的STM32，其引脚复用可能略有不同

**AFIO（备用功能IO）寄存器**

- **AFIO寄存器确实可以选择复用功能**
- **但前提是硬件上支持该复用功能**
- **寄存器配置实际上是在已有物理连接基础上进行选择**

复用功能选择的限制因素

- 芯片内部引脚复用矩阵的物理连接
- PCB设计时的实际布线
- 特定外设的专用引脚要求

实际开发建议

- 必须仔细查看具体项目的原理图
- 不能盲目相信参考手册的通用说明
- 实际使用时要以具体硬件为准

这个细节体现了嵌入式开发中硬件和软件紧密结合的特点。软件配置（如AFIO寄存器）必须建立在硬件物理实现的基础之上。

### 学习重点

在STM32中，学习复用模式下的串口通信（USART/UART）是一项非常重要的技能，因为串口是嵌入式系统中最常用的通信接口之一。以下是学习步骤和关键知识点：

#### **学习步骤**

##### 1. **理解串口通信的基本原理**

- 串口通信是一种**异步通信**方式，通过发送和接收数据帧进行通信。
- 数据帧的基本组成包括起始位、数据位、校验位（可选）、停止位。
- 熟悉常见的参数配置：
  - 波特率（Baud Rate）：如9600、115200。
  - 数据位：一般是8位。
  - 校验位：奇校验、偶校验或无校验。
  - 停止位：1位或2位。

##### 2. **熟悉 STM32 的硬件资源**

- 阅读目标 STM32 芯片的参考手册（Reference Manual）和数据手册（Datasheet）。
- 确认 UART/USART 外设的数量、对应引脚、复用功能（AF）编号。
- 查看 RCC（复位与时钟控制）部分，找到启用 UART 外设的相关时钟配置。

##### 3. **硬件配置与引脚复用**

- 使用 GPIO 的复用模式（Alternate Function Mode）将特定引脚设置为 UART_TX 和 UART_RX。
- 查阅引脚复用表，找到需要配置的 GPIO 引脚和对应的 AF 编号。

##### 4. **串口配置与初始化**

- **使用 STM32 的 HAL 库或直接操作寄存器：**
  1. 启用时钟（RCC）。
  2. 配置 GPIO 引脚为复用功能。
  3. 初始化 USART/UART 外设，包括设置波特率、数据格式等。
- 推荐使用 **CubeMX** 工具生成代码进行初始学习，便于快速理解配置流程。

##### 5. **实现基本的串口通信**

- 编写简单的发送（`HAL_UART_Transmit`）和接收（`HAL_UART_Receive`）程序，发送一串字符或者接收外设返回的数据。
- **配合串口调试工具（如 SecureCRT、XCOM），测试通信是否正常。**

##### 6. **学习中断和 DMA 模式**

- **中断模式**：学习如何配置串口中断，实现数据的非阻塞收发。
- **DMA 模式**：使用 DMA 进行高效的数据传输，适合处理较大数据量的通信。

##### 7. **学习高级通信协议**

- 基于串口实现常用的通信协议（如 Modbus、AT 指令解析）。
- 如果应用涉及 WiFi 或蓝牙模块，可以编写驱动程序，解析模块返回的数据。



#### **关键知识点**

##### 1. **GPIO 复用模式**

- STM32 GPIO 的复用功能配置，如何根据具体型号找到正确的复用功能编号（AFx）。

##### 2. **RCC 配置**

- USART/UART 外设依赖时钟，需正确启用时钟（APB1/APB2）。

##### 3. **USART 寄存器**

- 理解关键寄存器的作用：
  - `USART_BRR`：设置波特率。
  - `USART_CR1`：控制串口启用、中断、数据格式等。
  - `USART_SR`：状态寄存器，用于检查发送和接收状态。

##### 4. **数据缓冲**

- 如果数据量较大，需熟悉 FIFO 缓冲区的实现，避免数据丢失。

##### 5. **错误处理**

- 常见错误类型：
  - 帧错误（Frame Error）
  - 过载错误（Overrun Error）
  - 噪声错误（Noise Error）
- 了解如何通过状态寄存器（`USART_SR`）检测错误并进行处理。

##### 6. **HAL 与 LL 库的使用**

- HAL 库简单易用，适合快速开发。
- LL（Low Layer）库提供更高效、灵活的控制，适合优化程序性能。

##### 7. **串口通信的调试**

- 串口调试工具：学会使用串口调试助手查看发送和接收的数据。
- 使用逻辑分析仪或示波器验证通信信号的正确性。



#### **推荐的实践项目**

1. **单片机与电脑通信**
   - 发送固定字符串到电脑终端显示。
   - 接收电脑输入的字符并回显。
2. **与传感器通信**
   - 接收传感器通过串口发送的测量数据。
3. **模块驱动开发**
   - 驱动 WiFi 模块（如 ESP8266）的 AT 指令解析。
   - 蓝牙模块数据收发。
4. **数据记录**
   - 将测量数据通过串口发送到电脑并存储为文件。

## 串口参数详解

- 串口通信是一种**异步通信**方式，通过发送和接收**数据帧**进行通信。
- 数据帧的基本组成包括**起始位、数据位、校验位（可选）、停止位。**
- 熟悉常见的参数配置：
  - 波特率（Baud Rate）：如9600、115200。
  - 数据位：一般是8位。
  - 校验位：奇校验、偶校验或无校验。
  - 停止位：1位或2位。

### **波特率：发送速率还是接收速率？**

**波特率**（Baud Rate）表示串口通信中**每秒钟传输的符号数**，通常等于**每秒的比特数**（bps，bits per second），它是发送和接收的统一速率。

- 在异步通信中，通信双方（发送端和接收端）必须配置相同的波特率，以确保数据能够正确解析。

**发送与接收关系：**

1. **单向通信**：
   - 如果只发送或只接收，波特率仅反映这一方向的速率。
   - 例如：传感器发送数据给主控芯片，主控只需要按照传感器设定的波特率去接收。
2. **双向通信**：
   - 对于全双工通信（同时发送和接收），波特率定义了每个方向的最大传输速率。
   - 例如：一端以 115200 的波特率发送，另一端必须以 115200 的波特率接收。

**补充：波特率与实际数据吞吐量**

实际的数据吞吐量可能低于波特率，因为一个数据帧中包含额外的控制位：

- 每帧至少包含 1 位起始位、8 位数据位、1 位校验位（可选）和 1 位停止位。
- 如果波特率是 9600 bps，每秒可传输的有效数据量 = 9600÷(1+8+1+1)=8009600 \div (1 + 8 + 1 + 1) = 8009600÷(1+8+1+1)=800 字节。

### IP网络数据包中的数据帧

**IP网络数据包中不是也有数据帧吗？这算不算相似之处？**

IP 网络数据包中的确也包含“数据帧”的概念，这是它与串口通信的一大相似之处。两者的**相似性**主要体现在分层结构和帧的功能上。我们可以从通信协议的层次角度来深入理解这种关联：

#### **IP 网络中的数据帧**

在网络通信中，“数据帧”是链路层的基本单位。根据 OSI 模型，IP 数据包和数据帧分别属于不同的层次：

1. **数据帧（Frame）**：
   - 位于 **链路层**，由网络设备（如网卡）负责处理。
   - 典型的帧结构包括：
     - **帧头部（Header）**：包含 MAC 地址、帧类型等链路层信息。
     - **帧有效载荷（Payload）**：通常是 IP 数据包。
     - **帧尾部（Footer）**：可能包含校验码（CRC）等信息。
   - 数据帧的作用是封装和传输 IP 数据包，并在链路级别进行校验。
2. **IP 数据包（Packet）**：
   - 位于 **网络层**，是数据传输的核心单位。
   - 包括：
     - **IP 头部**：包含源 IP、目的 IP、协议类型等信息。
     - **IP 载荷**：传输的数据（通常是 TCP/UDP 段）。
   - IP 数据包依赖数据帧在底层网络上传输。

#### **串口通信中的“数据帧”**

- 串口通信中，数据帧是最基本的传输单位，直接封装要传输的数据。
- 类似链路层的帧，它定义了起始位、停止位、校验位等，确保数据可靠性。

#### **IP 网络与串口通信的相似性**

1. **结构化数据帧的使用**
   - 两者都使用明确的数据帧结构来保证通信的可靠性和可解析性：
     - IP 网络：链路层数据帧封装 IP 数据包，IP 数据包再封装上层协议数据。
     - 串口通信：数据帧直接封装要发送的数据。
2. **校验与错误检测**
   - IP 网络的链路层数据帧和串口通信的数据帧都可以通过校验位（如 CRC 或奇偶校验）来检测数据传输过程中的错误。
3. **分层与封装**
   - IP 网络有完整的协议栈，链路层、网络层、传输层分工明确，数据逐层封装。
   - 串口通信虽然没有复杂的分层，但数据帧也起到了基础封装的作用，承担了部分链路层的功能。
4. **点对点传输**
   - 两者都是点对点的传输方式：
     - IP 数据包通过链路层的点对点数据帧传输。
     - 串口通信直接在设备间点对点传输数据帧。

#### **不同点**

| **特点**           | **串口通信数据帧**                 | **IP 网络数据帧**                        |
| ------------------ | ---------------------------------- | ---------------------------------------- |
| **作用范围**       | 嵌入式系统、短距离设备通信         | 广域网、局域网等复杂网络环境             |
| **传输协议复杂度** | 简单，没有多层协议                 | 多层协议栈，包含链路层、网络层、传输层等 |
| **可靠性保障**     | 基本靠校验位，通常需要软件补充处理 | 包含校验、重传机制（如 TCP）             |
| **封装内容**       | 数据 + 起始位/校验位/停止位        | 网络层 IP 包 + MAC 地址等链路层信息      |
| **应用场景**       | 硬件调试、模块通信                 | 网络设备互联                             |

------

#### **总结**

IP 网络的数据帧与串口通信的数据帧在概念和功能上确实存在相似之处，尤其在结构化和校验机制上。不过，IP 网络的数据帧是更高级通信模型中的一个子集，包含更多分层设计和复杂功能。两者的相似性反映了通信系统设计的通用思想：**通过数据帧实现可靠的点对点传输**。

### 串口通信的逻辑

对于复用功能的 IO，我们首先要使能 GPIO 时钟，然后**使能相应的外设时钟**，同时要把 **GPIO 模式设置为复用**。这些准备工作做完之后，剩下的当然是**串口参数的初始化设置**，包括波特率，停止位等等参数。在设置完成只能接下来就是**使能串口**，这很容易理解。同时，如果我们开启了串口的中断，当然要初始化 NVIC 设置中断优先级别，最后编写中断服务函数 。

串口设置的一般步骤可以总结为如下几个步骤：

1) 串口时钟使能， GPIO 时钟使能。

2) 设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。

3) GPIO 初始化设置：要设置模式为复用功能。

4) 串口参数初始化：设置波特率，字长，奇偶校验等参数。

5) 开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。

6) 使能串口。

7) 编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。

## 通信背景知识

**单片机与外部设备通信的两种方式：**

- 并行通信
  - 传输原理：数据各个位同时传输
  - 优点：速度快
  - 缺点：引脚资源占用多
- 串行通信
  - 传输原理：数据按位顺序传输
  - 优点：引脚资源占用少
  - 缺点：速度相对慢

### 串行通信的分类

**串行通信按传输方向可以分为以下三类：**

单工通信

- 数据只能单向传输
- 通信双方只能有一方发送数据
- 例如：广播系统

半双工通信

- 数据可以双向传输，但同一时刻只能单向传输
- 通信双方需要轮流发送和接收数据
- 例如：对讲机

全双工通信

- 数据可以同时双向传输
- 通信双方可以同时发送和接收数据
- 例如：电话通话、以太网

这种分类主要反映了通信过程中数据传输的灵活性和通道利用率。



**根据是否带有时钟同步信号，串行通信可以分为两类：**

**同步通信**

- 有专门的时钟信号线
- 发送方和接收方共享时钟信号
- 数据传输严格同步
- 例如：SPI、I2C通信

**异步通信**

- 无额外时钟信号线
- **通过预先约定的波特率实现通信**
- 数据传输依赖起始位和停止位
- 例如：UART通信

主要区别在于时钟同步机制的处理方式不同，影响数据传输的精确性和复杂性。



异步通信就像两个人约定好用某种特定的"暗号"通信：

- 事先约定好数据的传输规则（波特率、数据位、停止位等）
- 接收方按照约定的"暗号"规则来解析收到的数据
- 双方没有实时的时钟同步信号
- 数据传输依赖于起始位和停止位来标记数据的开始和结束

同步通信则像两个人同步跳舞：

- 有专门的时钟线"指挥"数据传输
- 发送方和接收方完全同步，精确地在时钟信号的控制下传输数据
- 不需要额外的数据边界标记
- 传输更加精确，实时性更强

打个比方：

- 异步通信：像两个人用对讲机，说话前先喊"我要说话了"
- 同步通信：像两个人跳探戈，完全跟随音乐节拍移动

同步和异步通信的应用场景各有特点：

同步通信典型应用场景：

1. 高速数据传输系统
2. 内部总线通信
3. 实时性要求高的系统
4. 工业控制系统
5. 传感器数据采集

- 代表性接口：SPI、I2C

异步通信典型应用场景：

1. 串口通信
2. 低速、远程通信系统
3. 嵌入式设备间通信
4. GPS模块通信
5. 蓝牙、无线通信

- 代表性接口：UART

选择依据：

- 同步：实时性高、数据量大、距离近
- 异步：成本低、实现简单、抗干扰能力强

### 常见的通信接口

![image-20241130145049639](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241130145049639.png)

是否同步决定是否带有同步时钟。全双工两根线，半双工共用一根线。F407VGT6只有两个UART。有四个USART。

### 引脚连接方法

![image-20241130145919744](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241130145919744.png)

### 串口与引脚对应关系

两个仅支持异步通信的串口：

**UART4_TX**对应单片机的PA0端口

**UART4_RX**对应单片机的PA1端口 还对应着PC11端口

**UART5_TX**对应单片机的PC12端口

**UART5_RX**对应单片机的PD2端口

### 异步通信特点

![image-20241130151235986](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241130151235986.png)

### 异步通信过程

![image-20241130151343538](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241130151343538.png)

还是放到寄存器中，只不过按照一定的规律接收并放到寄存器中，内核接收的永远是机器码。

### 异步通信的参数

![image-20241130151857496](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241130151857496.png)

## 学习

- [什么串口通信](###一句话总结串口通信是什么)
- 如何配置串口通信
- 具体使用串口通信

### 功能需求

通过串口通信  

①PC 与  STM32芯片 传送 字符  字符串

②PC控制开发板的灯、流水灯 

③开发板1控制开发板2

### 通信协议的介绍的补充

**现场总线/板级总线**

**现场总线：工业控制现场总线（可远距离传输数据） 差模信号抗干扰**

- 485总线---千米级别
- can总线---十千米级	

**板级总线：芯片之间通信（距离长会被干扰）    共模信号** 

​			如：IIC/SPI/8080

**差模信号 共模信号**

有/无线

​	有线：可靠性强 

​	无线：方便

​		GSM  蓝牙  433（500m）  2.4G  RFID通信



### 通信配置方式

**配置通信控制器** 

​	前提：有通信控制器

​	关注：通信控制器寄存器

**IO口模拟时序**

​	前提：有通信时序图

​	关注：如何看时序图

### 串口通信介绍F407补充

![image-20241202154908473](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241202154908473.png)

F407芯片内部在6个串口控制器，也就是说可以同时进行六组串口通信。	

### 串口控制器框图

**GPIO口复用模式下，单片机内部的串口控制器也有发送数据寄存器和接收数据寄存器，这跟GPIO口通用模式下，内核通过输出和输入数据寄存器获取高低电平的信息的作用一样，都是转换为内核能够识别的机器码？**

**GPIO通用模式**

- 使用GPIO的输出数据寄存器(GPIOx_ODR)控制输出高低电平
- 使用GPIO的输入数据寄存器(GPIOx_IDR)读取输入的高低电平
- 直接通过置位/清位寄存器(GPIOx_BSRR)快速改变输出电平

**串口复用模式**

- 串口发送数据寄存器(USARTx_DR)
- 串口接收数据寄存器(USARTx_DR)
- 这些寄存器同样会被转换为内核可识别的机器码

**数据转换机制**

- 无论是GPIO还是串口复用模式,都是通过寄存器映射到内存空间
- 微控制器内部的外设总线(APB1/APB2)负责寄存器访问
- 最终都转换为CPU能够识别和处理的二进制指令

**关键区别**

- GPIO通用模式：直接控制电平开关
- 串口复用模式：提供数据发送和接收的专用通道
- **底层机制都是通过寄存器进行数据交互**

**内部处理流程**

- 写入数据寄存器
- 触发相应的控制寄存器
- 硬件自动完成数据发送/接收
- 中断或轮询方式告知CPU数据状态

这种设计体现了STM32微控制器外设的灵活性和标准化设计思路。无论是通用IO还是专用外设,都遵循一致的寄存器访问和数据交互原则。



**所以无论是哪一种GPIO口模式，都需要通过对应的寄存器转换为对应的机器码给内核？**

这是STM32微控制器（以及大多数基于寄存器的微控制器）的基本工作原理：

**寄存器映射**

- 所有GPIO模式（通用、复用、模拟等）都通过寄存器映射到内存地址空间
- **每种模式都有对应的配置寄存器**
- 通过对特定寄存器写入特定值,转换为CPU可执行的机器指令

**寄存器类型**

- 模式配置寄存器(GPIOx_MODER)
- 输出类型寄存器(GPIOx_OTYPER)
- 输出速度寄存器(GPIOx_OSPEEDR)
- 上下拉寄存器(GPIOx_PUPDR)
- 输入/输出数据寄存器
- ……

**转换过程**

- 写入寄存器 → 硬件电路解析 → 生成对应的电气信号
- 寄存器值被转换为具体的硬件操作指令
- 内核通过总线访问这些寄存器

**适用范围**

- GPIO通用输入/输出模式
- 复用功能模式(UART, SPI等)
- 模拟输入模式(ADC)
- 时钟输出模式

这种寄存器映射和指令转换机制是微控制器硬件抽象层的核心设计思想。



**使用串口通信的话，因为是复用GPIO口的，所以GPIO口控制器中的相关寄存器需要配置。 还需要经过串口控制器解析协议和转换数据，内核才能识别，所以还要控制串口控制器中的相关寄存器？**

是的,您的理解非常准确！串口通信涉及两个控制器的寄存器配置：

**GPIO控制器寄存器配置**

- 配置GPIO口的复用功能
- 设置GPIO口工作模式（复用模式）
- 配置引脚的输入/输出特性
- 选择具体的复用功能（串口功能）

**串口控制器寄存器配置**

- 配置通信参数（波特率、数据位、停止位等）
- 配置串口工作模式（发送、接收）
- 配置中断使能
- 控制串口的开启和关闭
- 数据寄存器的读写控制

**通信流程**

- GPIO配置：确定物理连接
- 串口控制器：解析协议、转换数据
- 内核：处理最终的数据信息

**具体配置通常包括：**

- USART_CR1：控制寄存器1
- USART_CR2：控制寄存器2
- USART_BRR：波特率寄存器
- USART_DR：数据寄存器

这种多层控制器协同工作的设计,体现了现代微控制器硬件抽象和功能解耦的精妙之处。

#### 框图分成三部分

##### 收发过程（数据传输框图部分）

![image-20241202162412081](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241202162412081.png)

**发送数据过程：**

- CM4写数据到发送数据寄存器中，发送数据寄存器自动过度发送移位寄存器中发送移位寄存器再一位一位的将数据发送出去。

- 注意：CM4写数据到发送数据寄存器之前要检测之前的发送是否完成
  - 发送完成可以写到发送数据寄存器，如果发送未完成要等待发送完成

- 思考：如何检测之前的数据是否发送完成？

  - 有相应的发送完成标志位 状态寄存器的6号位

- ```
  综上：
  串口发送一个字节数据函数（要发送的数据 u8）
  {
  等待之前的数据发送完成（等待状态寄存器的发送完成位置1）
  要发送的数据赋值给数据寄存器
  }
  说明： 把数据给到数据寄存器后，要想到清零发送完成位（会自动置1可不会自动置0）
  ```

**接收数据过程：**

- 数据一位一位的接收到接收移位寄存器中，自动过度到接收数据寄存器中CM4从接收数据寄存器中读到接收的数据到变量

- 注意：CM4在读数据前要检测是否接收完成，（RDR）接收完成就可以读到变量中
  - 如果没有接收完成，要等待接收完成再读到变量中

- 思考：如何检测是否接收完成？

  - 有相应的接收完成标志位

- ```
  综上：
  u8 串口接收一个字节数据函数（无）
  {
  等待数据接收完成（等待状态寄存器中的接收完成位置1）
  将数据寄存器的值赋值给一个变量；
  返回这个变量
  }
  
  DR（数据寄存器） 
  是TDR和RDR寄存器统称，发送数据时候就会启动TDR，RDR读的时候启用
  	开发人员在写程序的时候，无论发送还是接收只需要写DR
  ```

  

##### 寄存器设置过程（通信协议控制部分）

- 直接去看数据手册上的对应寄存器描述

- 必须要等待数据接收或者发送完成才能往移位寄存器中读取或者写入，作为发送1次1个字节8位二进制数据。

- 这一些时机都由状态寄存器控制。

- 这三个寄存器确实是串口通信中最关键的寄存器：

  1. 状态寄存器 (USART_SR)

     - 记录串口通信的当前状态

     - 标志位包括：
       - 发送完成标志
       - 接收数据就绪标志
       - 校验错误标志
       - 帧错误标志
       - 过载错误标志

     - 通过读取和清除这些标志位，可以了解通信过程和处理异常

  2. 数据寄存器 (USART_DR)

     - 串口数据的读写寄存器

     - 发送时：写入要发送的数据

     - 接收时：读取接收到的数据

     - 8位或9位数据模式可配置

  3. 波特率寄存器 (USART_BRR)

     - 决定串口通信的波特率

     - 通过配置分频系数来设置

     - 根据系统时钟和期望波特率计算

     - 影响数据传输的速率

     - 这三个寄存器构成了串口通信的核心控制机制，直接决定了串口的工作状态和数据传输过程。

- 移位寄存器是串口控制器硬件自动完成的功能:

  1. 移位寄存器的硬件实现

     - 完全由串口控制器硬件自动处理

     - 负责将数据按照串口协议进行bit by bit的发送和接收

     - 不需要软件直接干预

  2. 开发者只需关注

     - 数据寄存器(USART_DR)的写入和读取

     - 通过状态寄存器(USART_SR)监控通信状态

     - 配置基本的通信参数

  3. 移位寄存器的工作原理

     - **自动将数据寄存器中的数据转换为串行数据流**

     - 按照配置的数据位、停止位、校验位等协议

     - 硬件自动完成数据的并行转串行(发送)和串行转并行(接收)

  4. 这种设计大大简化了串口通信的软件实现,将底层的数据转换细节交给硬件完成。

- 发送数据要保证 上一次发送的数据已经发送完成

  - 如何知道发送完成
    - 寄存器发送完成位（上一次的发送完成，寄存器对应自动变为1）
    - 读寄存器的这位是1，就可以再次发送数据

  ​			

- 接收数据就是把数据读取到变量中，要保证数据已完整的接收完成

  - 如何知道接收完成
    - 寄存器接收完成位（接收完成了，寄存器对应位自动变为1）
    - 读寄存器的这位是1，可以把串口控制器的数据读到变量里去



##### 波特率框图部分

- 波特率：因为是异步通信，通信双方设备没有用同一时钟，所以双方要约定好相同的数据传输速度:`4800pbs  9600pbs`     

- 波特率寄存器：对总线提供的时钟 分频  达到需要的频率
  - 16位有效，0~3小数部分   4~15位整数部分	

- 波特率计算公式：（手册686页）

  - Tx/Rx 波特率 = fCK/(8*(2-OVER8)*USARTDIV)		

  - fCK ：总线提供的时钟 (**看芯片内部框图的数据**)

  - OVER8  : 过采样 （**CR1寄存器，抽象成16次采样，8次采样，通常设置为0，默认16倍**）

  - USARTDIV：要往波特率寄存器里写的值		

- 变形得到：
  - USARTDIV = fCK / (波特率 * (8*(2-OVER8)))	

**注意：此时得到的值带有小数部分，要想写入寄存器，二进制要整体左移四位，故十进制要扩大16倍**

- **11011101.1101，整数转换为二进制时，直接存入只能存入整数部分11011101：因为寄存器是U32类型**
- **二进制下，小数点右移动四位即可，相当于十进制扩大16倍，所以先乘以16即可，寄存器低位小数部分就会存入11011101  1101**

波特率寄存器写入的值 = (fCK / (波特率 * (8*(2-OVER8)))) * 16;

波特率写入的值 =fCK / 波特率    注意此时是16倍过采样

波特率写入的值 = fCK / 波特率 \* 2;   注意此时是8倍过采样

**注意：会不会有可能算出来的数，使用二进制无法表示？你举例几个**

这是一个非常深入的问题。确实存在一些波特率计算结果在二进制表示时会出现无法精确表示的情况，主要源于浮点数的离散性。

几个典型的例子：

**经典波特率：115200**

- 以72MHz系统时钟为例
- USARTDIV = 72000000 / (115200 * 16)
- 结果约为 39.0625
- 二进制表示时，0.0625这个小数在二进制中是无法精确表示的

原因：

- 某些分数在二进制表示中是循环小数
- 浮点数的精度限制
- 系统时钟与波特率的特定组合



**至少比直接取整数部分要精准，获取一个相对精准的值，但是无所谓，因为通信双方都是一样的波特率，相当于暗号是一样的，就不会出错？**

您的理解非常准确！这正是串口通信波特率设置的关键点：

**精度处理**

- 通过放大16倍的方式，可以保留更多小数部分信息
- 比直接取整数部分要精准得多
- 可以最大程度地接近理想的波特率

**通信一致性**

- 通信双方使用完全相同的波特率配置
- 即使存在微小误差，只要双方一致
- 实际上就不会出现通信错误

**误差容忍**

- 串口通信对波特率有一定的容错范围
- 通常误差在±2%以内都可以正常通信
- 硬件本身具有一定的同步容错机制

**实际影响**

- 微小的波特率差异不会导致通信中断
- 关键在于双方时钟同步
- "暗号一致"的比喻很形象

所以，即使存在微小的不精确性，只要通信双方保持一致，串口通信仍然可以稳定进行。这种设计体现了通信协议的鲁棒性。

**暗号一致就不会出错，影响的只是暗号解析的速度而已**

### 串口控制器的相关寄存器

#### 状态寄存器 (USART_SR)

--------------指示UART控制器运行的状态

位6 TC：发送完成 (Transmission complete)

​		通过检测此为是0表示之前的数据发送还没有完成，不能再次写数据到DR，需要等待

​		如果此位是1，表示之前的数据发送完成，可以再次写数据到DR，

位5 RXNE：读取数据寄存器不为空 (Read data register not empty)

​		在接收外界数据的时候，通过此位判断是否可以读数据

​		0  表示没有接收到数据     需要等待

​		1  表示已经接收到完整的数据， 可以读



#### 数据寄存器 (USART_DR)

​	---------包括发送数据寄存器(只读)和接收数据寄存器（只写）

#### 波特率寄存器 (USART_BRR)

​	Tx/Rx 波特率  = fCK /(8 * (2 - OVER16) * USARTDIV)

​	9600  = 84M /(16 * USARTDIV)

​	USARTDIV = 84M/16*9600

​	**寄存器要写的是： 84M/9600**

#### 控制寄存器 1 (USART_CR1)

​	位15 过采样倍数  16倍

​	位13 使能UART控制器

​	位12 字长  8位数据位

​	位3  发送使能

​	位2  接收使能

#### 控制寄存器 2 (USART_CR2)

​	位12 位13 停止位  默认一个停止位 

### IO口的复用功能如何配置

说明：

​	**每个IO口都有自己固定的复用功能，并不是每个IO口都可以复用任何功能**（虽然可以选择那么多，但是要符合硬件设计）

​	如何知道IO口具体的复用功能------------查表（**Table 9. Alternate function mapping** ）

**如何配置复用功能**

①确定IO（根据具体的复用功能确定IO）  

​		根据自己需要的复用功能去查看哪个管脚支持这个复用功能（STM32F407ZGT6）   ------  **通常通过原理图就可以确定，以实际硬件为准**

②确定寄存器和寄存器的位

​		配置复用功能寄存器AFR[0](4~7)（参考手册） AFR[0](0~7)   ------

③确定标识

​		查表（数据手册3.9）    ------

④确定数值

​		去查看具体寄存器下面的说明（中文参考手册）



**我正在看STM32F407的数据手册的内部框图： 我现在需要使用UART4，我使能APB1上对应的位，但是UART4复用的是GPIO口的PA0和PA1口，那么我是否还需要使能AHB1上对应的位？因为从内部框图来看，他们逻辑上是分开的，但是物理上是复用的**

是的，你需要同时使能AHB1上的GPIO时钟以及APB1上的UART4时钟。以下是原因：

**逻辑解释**

1. **UART4 的时钟控制**
   UART4 属于 APB1 外设，因此使能 APB1 的 UART4 时钟是为了让 UART4 模块开始工作。
2. **GPIO 的时钟控制**
   PA0 和 PA1 属于 GPIOA 引脚，GPIO 的时钟由 AHB1 总线控制。为了能够配置和使用 GPIOA 的引脚（无论是普通 I/O 模式还是复用功能），都需要先使能 GPIOA 的时钟。

**物理复用的关键**

复用功能的实现依赖于 GPIO 模块和外设模块的协作：

- GPIO 引脚默认处于普通输入模式，只有在你通过寄存器（如 `MODER` 和 `AFR`）配置为复用功能时，才能将这些引脚的信号引导到 UART4。
- 这意味着即使你已经使能了 APB1 上的 UART4 时钟，但如果没有使能 AHB1 上的 GPIO 时钟，你无法配置 PA0 和 PA1 的复用模式，也无法让 UART4 正常工作。

**配置流程**

1. **使能时钟**
   - 使能 AHB1 的 GPIOA 时钟：通过 `RCC_AHB1ENR` 寄存器设置对应位。
   - 使能 APB1 的 UART4 时钟：通过 `RCC_APB1ENR` 寄存器设置对应位。
2. **配置 GPIO 引脚**
   - 将 PA0 和 PA1 的模式配置为复用模式（`MODER`）。
   - 设置复用功能为 UART4（`AFR`）。
3. **初始化 UART4**
   - 配置 UART4 的波特率、数据格式等参数。
   - 使能 UART4。
4. **由于 GPIO 和 UART4 分属不同的时钟域，必须分别使能对应的时钟。即使物理上是复用的，引脚的复用模式仍需要通过 GPIO 模块配置后才能与 UART4 关联。**

### 程序设计

#### 配置思路

```
总体思路
	串口控制器初始化配置函数
	{
		IO口控制器配置（复用需要经过，需要设置一些东西，输入输出相关的寄存器）
		某个串口控制器配置（具体串口通信的设置（传输的数据，波特率等）输入输出的相关寄存器）
	}
	串口发送一个字节数据函数       //波特率就是一秒发送多少个字节的速度，
	{
	}
	串口接收一个字节数据函数
	{	
	}
	
	详细程序思路
	串口控制器初始化配置函数
	{
		/*IO口控制器配置*/
        //端口时钟使能
        //端口模式配置-------复用
        //输出类型
        //输出速度
        //上下拉
	   //复用功能寄存器配置

		/*某个串口控制器配置*/
        //串口控制器时钟使能	
        //CR1
        //CR2
	   //BRR
	}
	void 串口发送一个字节数据函数(u8 要发送的数据)
	{
        等待之前的数据发送完成（等待状态寄存器的发送完成位置1）
        要发送的数据赋值给数据寄存器		
	}
	
	u8 串口接收一个字节数据函数（无）
	{
        等待数据接收完成（等待状态寄存器中的接收完成位置1）
        将数据寄存器的值赋值给一个变量；
        返回这个变量	
	}
	
如何配置复用功能
①确定IO（根据具体的复用功能确定IO）   
		根据自己需要的复用功能去查看哪个管脚支持这个复用功能（STM32F407ZGT6）    ------  通常通过原理图就可以确定
	②确定寄存器和寄存器的位
		配置复用功能寄存器AFR[0](4~7)（参考手册）         AFR[0](0~7)          ------
	③确定标识
		查表（数据手册3.9）                      ------
	④确定数值
		去查看具体寄存器下面的说明（中文参考手册）
```

#### IO口控制器配置

思路：

```c
在 GPIOx_MODER 寄存器中将所需 I/O 配置为复用功能
    
— 通过 GPIOx_OTYPER、 GPIOx_PUPDR 和 GPIOx_OSPEEDER 寄存器，分别选
择类型、上拉/下拉以及输出速度
    
— 在 GPIOx_AFRL 或 GPIOx_AFRH 寄存器中，将 I/O 连接到所需 AFx
```

1. **GPIOA_MODER** 寄存器中将所需 I/O 配置为复用功能，

   1. PA0设置为复用功能模式  (10)

   2. PA1设置为复用功能模式  

   3. ```c
      GPIOA->MODER &= ~(3U<<0);
      GPIOE->MODER |= (1U<<1);
      
      GPIOA->MODER &= ~(3U<<2);
      GPIOE->MODER |= (1U<<4);
      ```

2. GPIOA_OTYPER寄存器

   1. PA0选择推挽输出

   2. ```
      GPIOA->OTYPER |= (1U);
      ```

3. GPIOA_PUPDR寄存器

   1. PA0无

   2. PA1无

   3. ```
      GPIOA->PUPDR &= ~(3U<<0);
      GPIOA->PUPDR &= ~(3U<<2);
      ```

4. GPIOA_OSPEEDER 寄存器

   1. PA0：高速（10）

   2. ```
      GPIOA->OSPEEDR &= ~(3U<<0);
      GPIOA->OSPEEDR |= (1U<<1);
      ```

5. 使配置生效需要使能PA组GPIO(PA0和PA1)

   1. ```
      RCC->AHB1ENR |= (1U);
      ```

6. 选择具体的复用功能（**在 GPIOx_AFRL 或 GPIOx_AFRH 寄存器中，将 I/O 连接到所需 AFx**）复用功能寄存器

   1. PA0和PA1应该在低位寄存器设置，（四位控制一个io口）

   2. 使用4号串口，选择AF8功能，即1000

   3. ```
      GPIOA->AFRL &= ~(15U<<0);
      GPIOA->AFRL |= (1U<<3);
      
      GPIOA->AFRL &= ~(15U<<4);
      GPIOA->AFRL |= (1U<<7);
      ```

#### 复用功能寄存器配置（怎么知道是哪个串口？直接在后面加数字指定即可）以串口4为例

**需要关注的寄存器和位思路：**

```
状态寄存器 (USART_SR)--------------指示UART控制器运行的状态
位6 TC：发送完成 (Transmission complete)
		通过检测此为是0表示之前的数据发送还没有完成，不能再次写数据到DR，需要等待
		如果此位是1，表示之前的数据发送完成，可以再次写数据到DR，
			
位5 RXNE：读取数据寄存器不为空 (Read data register not empty)
		在接收外界数据的时候，通过此位判断是否可以读数据
		0  表示没有接收到数据         需要等待
		1  表示已经接收到完整的数据， 可以读
		
数据寄存器 (USART_DR)
	---------包括发送数据寄存器(只读)和接收数据寄存器（只写）

波特率寄存器 (USART_BRR)
	Tx/Rx 波特率  = fCK /(8 * (2 - OVER16) * USARTDIV)
	9600   = 84M /(16 * USARTDIV)
	USARTDIV = 84M/16*9600
	寄存器要写的是： 84M/9600
	
控制寄存器 1 (USART_CR1)
	位15 过采样倍数  16倍
	位13 使能UART控制器
	位12 字长  8位数据位
	位3  发送使能
	位2  接收使能
	
控制寄存器 2 (USART_CR2)
	位12 位13 停止位  默认一个停止位 
```

- 状态寄存器 (USARTx_SR)  写函数用的，检测数据的状态
  - 位 6 TC：发送完成  
  - 位 5 RXNE：读取数据寄存器不为空  

- 数据寄存器 (USARTx_DR)  读取或者写入需要的数据

  - ```
    
    ```

- 波特率寄存器 (USARTx_BRR)  填入响应运算表达式即可

  - **看复用GPIO上的总线频率还是框图上的USART4对应总线频率？**

    - [在逻辑上分开](###串口通信介绍F407补充)，使用USART4对应的总线频率算这个数值，他是串口控制器中的部分！
    - 只是经过GPIO口的，所以开启时钟使能即可，最多输出速度寄存器哪里的速度阈值要高于波特率即可

  - ```
    USART4->BRR = 84M/9600？？？
    ```

- 控制寄存器 1 (USARTx_CR1)  

  - 位 15 OVER8：过采样模式 (Oversampling mode)  ，默认，16倍采样

  - 位 13 UE： USART 使能 (USART enable)  赋值1，USART 使能  

  - 位 12 M：字长 (Word length)    0： 1 起始位， 8 数据位， n 停止位  

  - 位 10 PCE：奇偶校验控制使能 (Parity control enable)   置0，禁用

  - 位 7 TXEIE： TXE 中断使能 (TXE interrupt enable)   置0，禁用中断

  - 位3  发送使能

  - 位2  接收使能

  - ```
    USART4->CR1 |= (1U<<13 | 3U<<2)
    USART4->CR1 &= ~(1U<<12 | 1U<<10 | 1U<<7)
    ```

- 控制寄存器 2 (USARTx_CR2)  

  - 位 13:12 STOP：停止位 (STOP bit)这些位用于编程停止位。00： 1 个停止位01： 0.5 个停止位10： 2 个停止位11： 1.5 个停止位

  - 注意： 0.5 个停止位和 1.5 个停止位不适用于 UART4 和 UART5。

  - ```
    USART4->CR2 &= ~(3U<<12) 
    ```

- 使配置生效，使能对应总线上的端口,UART4 时钟使能  

  - ```
    APB1线上的USART4
    RCC->APB1ENR |= (1U<<19)
    ```

    

### PC与开发板通信原理（串口协议与USB相互转换）

![image-20241203154638317](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241203154638317.png)

CH340芯片的确是实现USB转串口的常用方案，但不是唯一或最主要的原因。让我详细解释一下：

1. 接口转换需求 USB接口是现代计算机和移动设备的标准接口，而很多传统设备和通信协议（如串口）仍然广泛使用。CH340芯片的主要作用是实现这种协议转换，使不同的通信接口能够互相连接。

2. CH340的具体功能

   - 将USB信号转换为串口(UART)信号

   - 提供驱动程序，让操作系统识别和管理串口设备

   - 成本低、体积小，适合各种嵌入式和电子设计

3. 为什么需要协议转换

   - PC主板通常没有直接的RS232串口

   - USB提供了更通用、更现代的接口标准

   - 许多传感器、单片机、工业设备仍使用串口通信

4. 其他转换方案 除了CH340，还有：

   - FT232芯片

   - PL2303芯片

   - CP2102芯片

**所以，协议转换是主要原因，而不仅仅是"PC没有引脚接收串口数据"。CH340只是这一需求的一种常见解决方案。**

#### F407补充

- PA9作为串口1TX发送使用

- PA10作为串口1RX接收使用
- 发送和接收以串口控制器为主体视角

#### 配置与初始化

```c
#include "usart.h"
#include "stm32f4xx.h"                  // Device header



void usart1Init(u32 baud){
	/*IO口控制器配置*/
  //端口时钟使能
	RCC->AHB1ENR |= (1U<<0); 
	
	//端口模式配置-------复用 PA9：发送 PA10：接收
	GPIOA->MODER &= ~(3U<<18 | 3u<<20);//先清零
	GPIOA->MODER |= (2U<<18 | 2U<<20);//再置1
	
	//输出类型
	GPIOA->OTYPER &= ~(1U<<9); //清零顺便置0
	
	//输出速度,慢速
	GPIOA->OSPEEDR &= ~(3U<<18);
	
	//上下拉
	GPIOA->PUPDR &= ~((3U<<18) | (3u<<20));//先清零顺便置0
	
	//复用功能寄存器配置
	//GPIOA->AFR[1] |= ~(7U<<4 | 7U<<8);//置0111，写错了！！！直接STLink断了
	GPIOA->AFR[1] |= (7U<<4 | 7U<<8);//置0111
	
	
	/*某个串口控制器配置*/
	//串口控制器时钟使能	
	RCC->APB2ENR |= (1U<<4);
	
	//CR1
	USART1->CR1 &= ~(1U<<15);//清零顺便置0 16倍采样
	USART1->CR1 &= ~(1U<<12);//清零顺便置0 字长
	USART1->CR1 |= ((1U<<2) | (1U<<3));//再置1
	
	//CR2
	USART1->CR2 &= ~(3U<<12);//清零顺便置0
	
	//BRR
	USART1->BRR = 84000000/baud;//赋值直接给
	
	//串口控制器使能
	USART1->CR1 |= (1U<<13);//串口控制器使能
}

//发送一个字节
void usart1_send_byte(u8 data){
	  //等待之前的数据发送完成（等待状态寄存器的发送完成位置1）
		while(!(USART1->SR & (1U<<6)));
    
    // 直接发送数据
    USART1->DR = data;
}

//接收一个字节数据
u8 usart1_rec_byte(void){
	u8 data;
	
	//等待数据接收完成（等待状态寄存器中的接收完成位置1）
	while(!(USART1->SR & (1U<<5)));
	
	//手动清零会自动清零
	//USART1->SR &= ~(1U<<5);
	
	//将数据寄存器的值赋值给一个变量
	data = USART1->DR;
	
	//返回这个变量	
	return data;
}
```

### 两个开发板通信原理

- 板A按键控制器板B的LED灯

- 板B将开状态的LED灯编号反馈给上位机

![image-20241204174212590](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\32单片机学习\32单片机学习记录5之串口通信.assets\image-20241204174212590.png)

- 开两个工程分别烧录不同的程序
- 条件编译把两个相似的工程合在一起
- 前提是要同频率共地线共电源

### 串口打印函数的原理

#### 串口打印函数的使用场景

串口打印函数在嵌入式开发和硬件调试中非常重要，主要有以下使用场景和优点：

**调试信息输出**

- 可以通过串口打印实时输出程序运行状态、变量值、错误信息等
- 帮助开发者了解程序执行流程和定位问题
- 在没有图形界面的嵌入式系统中尤其有用

**系统诊断**

- 输出系统关键参数和运行日志
- 记录重要事件和异常情况
- 帮助追踪系统运行状态和性能

**开发阶段调试**

- 在开发过程中实时监控程序执行
- 检查关键函数的调用和返回值
- 验证算法和逻辑的正确性

**性能分析**

- 可以打印时间戳，分析程序执行时间
- 帮助定位代码中的性能瓶颈

**中断和异常处理**

- 在中断服务程序中输出调试信息
- 记录异常发生的详细情况

#### 与串口发送字符串的区别

**单板调试：使用串口打印函数**

- 主要目的是输出调试信息
- 通常使用 `printf()` 等标准输出函数
- 仅在本机查看运行状态和调试信息
- 不需要进行数据交互

**双板串口通信：使用串口发送字符串**

- 目的是在两个设备之间传输数据
- 需要自定义通信协议
- 使用串口发送和接收函数
- 需要处理数据的打包、发送、接收和解析

两者的关键区别在于:

- 调试打印是单向的、非结构化的
- 串口通信是双向的、需要遵循特定通信协议的

#### 打印函数重定向程序

```c
#include "selfprintf.h"

#pragma import(__use_no_semihosting)             

struct __FILE 
{ 
    int handle; 
}; 

FILE __stdout;       

//定义_sys_exit()以避免使用半主机模式    
void _sys_exit(int x) 
{ 
    x = x; 
} 

//重定义fputc函数 
int fputc(int ch, FILE *f)
{      
    while((USART1->SR&(1<<6))==0);//循环发送,直到发送完毕   
    USART1->DR = (u8) ch;      
    return ch;
}

#ifndef SELFPRINTF_H
#define SELFPRINTF_H
#include "stm32f4xx.h"                  // Device header
#include <stdio.h>

// 声明可能需要的函数
int fputc(int ch, FILE *f);
void _sys_exit(int x);

#endif
```
