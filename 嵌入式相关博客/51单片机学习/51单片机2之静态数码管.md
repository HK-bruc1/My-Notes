

# 51单片机2之静态数码管

## 前置疑问

**LED灯和数码管是一种东西吗？**

LED灯和数码管不是一种东西，它们是不同的电子元件，尽管它们都使用LED（发光二极管）技术。

1. **LED灯**（Light Emitting Diode）是用于发光的电子元件，广泛应用于照明、指示灯、显示屏等领域。它的主要作用是发出不同颜色的光（如红色、绿色、蓝色等），并且能效高、使用寿命长。

2. **数码管**，也叫七段显示器，是一种用来显示数字或字母的电子显示装置。数码管通常由多个LED组成，通常每个数字由七个LED（在七段显示器中）构成，通过控制哪些LED点亮，来显示不同的数字或字符。数码管常见于电子钟表、计算器等设备中。

3. 你可以说数码管是由多个LED灯组成的。实际上，数码管中的每个显示段通常由一个小的LED灯构成，因此数码管的工作原理就是通过控制这些LED灯的点亮与熄灭来显示数字或字符。

   在常见的七段数码管中，每个数字通常由七个LED组成，按照特定的排列方式（称为“七段”）。例如，要显示数字“8”，七个LED灯都会点亮。而通过不同的组合，可以显示不同的数字或字母。

   所以，数码管确实是由多个LED灯（或LED显示单元）构成的。

总结来说，LED灯主要用于提供光源，而数码管是由多个LED组成的显示设备。两者都使用LED技术，但功能不同。

## 数码管介绍

![image-20241116144527695](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机2之静态数码管.assets\image-20241116144527695.png)

共阳数码管是指将所有发光二极管的**阳极接到一起形成公共阳极(COM)**的数码管， 共阳数码管在应用时应将公共极 COM 接到+5V， 当某一字段发光二极管的**阴极为低电平**时， 相应字段就点亮， 当某一字段的**阴极为高电平**时， 相应字段就不亮。  

共阴数码管是指将所有发光二极管的**阴极接到一起形成公共阴极**(COM)的数码管， 共阴数码管在应用时应将公共极 COM 接到地线 GND 上， 当某一字段发光二极管的阳极为高电平时， 相应字段就点亮， 当某一字段的阳极为低电平时， 相应字段就不亮。  

**一高一低电平接通就亮。**

不同位数的数码管实物图如下所示：  

![image-20241115152617675](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机2之静态数码管.assets\image-20241115152617675.png)

### 数码管显示原理  

不管将几位数码管连在一起， 数码管的显示原理都是一样的， 都是靠点亮内部的发光二极管来发光， 下面我们就来讲解一个数码管是如何亮起来的。 数码管内部电路如下图所示：  

![image-20241115152801699](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机2之静态数码管.assets\image-20241115152801699.png)

所以讲**数码管由LED组成**没有毛病。

从上图可看出， 一位数码管的引脚是 10 个， 显示一个 8 字需要 7 个小段(命名为a-g段)，另外还有一个小数点(dp)， 所以其**内部一共有 8 个小的发光二极管**， 最后还有一个公共端(COM)， 多数生产商为了封装统一， 单位数码管都封装 10 个引脚， 其中第 3 和第 8 引脚是连接在一起的（内部连接的）。 而它们的公共端又可分为共阳极和共阴极， 图中间为共阳极内部原理图， 右图为共阴极内部原理图。

**一位数码管，内部一共有 8 个小的发光二极管，相当于8个小的LED灯？ 四位数码管，相当于四个大的LED灯，每个LED灯中有8个小的LED灯？** 

**一位数码管**

- **结构**：一位数码管内部包含 **8 个发光二极管 (LED)**，通常用于显示一个数字（0-9）或部分符号。
- **组成**：7个LED形成数字“8”的七段显示部分，另一个LED是小数点（可选）。
- **功能**：通过控制这些LED的点亮与熄灭，可以显示不同的数字和符号。

**四位数码管**

- **结构**：四位数码管实际上是 **4 个一位数码管**组合在一起，因此内部共有 **32 个发光二极管（每位8个LED）**。
- **功能**：用于同时显示四个数字或符号。每位数码管独立控制其显示内容。

### 总结

- 一位数码管：8个小的LED灯。
- 四位数码管：包含4个一位数码管，总共32个小的LED灯。





**共阳极和共阴极的区别：**

- 共阳极：公共端接正电压(VCC)，各段接地才会发光
  - IO口只需提供接地通路
  - 电流从VCC流经LED再到IO口
  - IO输出低电平点亮LED
- 共阴极：公共端接地(GND)，各段接正电压才会发光
  - IO口必须提供源电流
  - **电流从IO口流向LED再到地**
  - IO输出高电平点亮LED

### 共阴极

数码管就像是一个LED数字显示屏。共阴数码管就好比是一个"耗电大户"，需要比较大的电流才能把数字显示亮起来。

但是单片机的IO口（输出端口）就像是一根细小的水管，流量（电流）有限。如果直接连接：

1. 数码管需要的"水量"太大
2. 细水管供应不上这么多
3. 可能会导致显示不稳定或不够亮

所以我们需要在中间加个"助推器"，有两种方案：

1. 用上拉电阻 - 相当于加个小水泵
2. 用专门的驱动芯片(如74HC573、**[74HC245](####动态显示方式（推荐）)**) - 相当于加个大功率的水泵站

这些"助推器"可以提供更大的电流，确保数码管能够明亮稳定地显示数字，而且接线方式也比较简单。

### 共阳极

共阳极数码管就像是8个小灯泡，它们的正极（+）都连在一起。工作时：

1. 这个公共的正极要接到高电平（就是接电源的正极）
2. 要让哪个小灯亮，就要把那个灯的负极接地（给低电平）

简单比喻：

- 共阳极数码管就像是8个吊灯，顶部的电线（正极）都连在一起接着电源
- 每个灯都有个单独的开关（负极）
- 要让某个灯亮，就把它的开关拨到地线那边（低电平）

需要注意的是：

1. 每个小灯都需要足够的电流（至少5毫安）才能亮起来
2. 但又不能电流太大，不然会烧坏
3. 当多个灯一起亮时，电流会汇集到单片机，要小心不要超过单片机能承受的电流

就像是控制水流，既不能水流太小导致灯不亮，也不能水流太大把灯或控制器冲坏。

### 两者的区别

共阴极数码管：

- 所有的负极连在一起接地（就像所有排水管汇集到一个下水道）
- 单片机IO口负责提供高电平（相当于开水龙头）
- 电流方向：从单片机IO口 → LED → 共同的地线
- IO口的角色：电流提供者（"出水口"）

共阳极数码管：

- 所有的正极连在一起接电源（就像一个总水管接着水塔）
- 单片机IO口负责提供低电平（相当于排水口）
- 电流方向：从共同的电源 → LED → 单片机IO口
- IO口的角色：电流吸收者（"下水道"）

关键区别：

1. 共阴极时，IO口要能提供足够的电流（输出能力要强）
2. 共阳极时，IO口要能吸收足够的电流（吸收能力要强）

这就是为什么两种情况都可能需要驱动芯片 - 因为单片机IO口无论是作为"水龙头"还是"下水道"，能力都可能不够用。



想象数码管就像是一组小灯泡，IC芯片就像是一个控制器。

**为什么更喜欢用共阳极数码管？**

1. 共阳极的工作方式：
   - 大功率的活（提供电流）交给专门的电源来做
   - IC芯片只负责简单的开关工作（吸收电流）
   - 就像是水从高处自己流下来，IC芯片只需要控制"开关"
2. 共阴极的工作方式：
   - IC芯片要又当开关又要提供电流
   - 就像让一个控制器既要控制又要"推水"
   - 因为IC芯片"力气小"，灯可能会很暗
   - 要解决这个问题就得加"助推器"（上拉电阻或三极管）

简单来说：

- 共阳极就像是用自来水（专门的电源），IC芯片只负责开关
- 共阴极就像是让IC芯片自己打水，还要负责开关，太累了

所以共阳极更受欢迎 - 让专业的人做专业的事，控制器就负责控制就好！

## 硬件设计

我们开发板上使用的数码管是 2 个四位一体的**共阴极数码管**（即 8 个 LED的阴极全部并联一起引出， 阳极分别引出如 A、 B...DP） ， 本章实验也是在该数码管上实现单个的静态显示。 如果要让共阴数码管显示数字 0， 即对应的段ABCDEF **要点亮即给它高电平**， 其他的段熄灭即给它低电平。 其他的数字显示方式一样， 这里就不多说。 下面给出共阴和共阳数码管的 0-F 段码数据表， 如下所示  ：

![image-20241115165801789](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机2之静态数码管.assets\image-20241115165801789.png)

### **数码管基本原理**

- **共阴极数码管**：指的是数码管的阴极（负极）共同接到一起，每个段的阳极（正极）独立控制。如果要点亮某一段，就需要将该段对应的阳极接高电平，同时阴极接低电平。
- 段选和位选：
  - 段选：控制哪些段点亮，用于显示具体的数字或符号。
  - 位选：选择哪一位的数码管进行显示。

### **段选数据和51单片机端口**

由于数码管的每一段（A、B、C、D、E、F、G、DP）对应一个控制信号，总共有8个控制信号。51单片机的一个端口（如P0、P1、P2或P3）正好是8位宽，**因此可以用一个端口直接控制数码管的段选**。

例如，如果使用P0口连接到数码管的8个段（A、B、C、D、E、F、G、DP）：

- P0.0 对应 a 段
- P0.1 对应 b 段
- P0.2 对应 c 段
- 依次类推，直到 P0.7 对应 dp 段

共阴数码管码表:

![image-20241116115344867](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机2之静态数码管.assets\image-20241116115344867.png)

```c
// 使用code关键字将数据放在代码区
code u8 gsmg_code[17] = {
	0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
	0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71
};
```



### **段码数据生成**

通常，显示某个数字（如“8”），需要发送对应的段码。例如：

- 数字“8”的段码：**11111111**（即点亮所有段）
- 数字“1”的段码：**00000110**（仅点亮b和c段）

这些段码可以通过查表法获取，比如在程序中定义一个数组存储段码。

### **位选控制**

当一个单片机控制多个数码管时，除了段选，还需要位选。位选通常通过另一个端口来控制不同的数码管，例如P2口的每一位控制不同的数码管。

**示例**： 通过动态扫描方式：

1. 先对P0口输出段选数据。
2. 再对P2口输出位选信号，选中某个具体的数码管。
3. 快速轮询各个数码管，实现多位数码管的显示效果。

### 数码管静态显示原理  

**一位数码管不是可以使用一个八位的IO端口控制嘛？ 那么同时使用四个静态数码管就要四个八位的IO端口控制？**

如果采用**静态显示**方式，确实需要大量IO端口。以下是对静态和动态显示的解释以及如何优化端口使用的方法：

#### **静态显示方式**

在静态显示中，每个数码管都需要独立的**段选（8位）和位选（1位）**。假如有4个四位数码管，每个数码管都需要8个段选端口，合计如下：

- **每个数码管需要8个IO口（P2端口有8个）来控制段选**。
- **四个数码管总计需要 8 × 4 = 32个IO口**。

由于51单片机的总IO口数量（P0、P1、P2、P3）一共只有32个，这种方式很快会耗尽IO资源，不适合用在多位数码管的情况下。四个大端口，每个端口8个IO就是32个。STC98C52RC有8个数码管，IO口远远不够。

#### **动态显示方式（推荐）**

为了节省IO口，通常采用**动态扫描**方法。这种方式利用**时间复用**的原理，只需要一组段选（8个IO口）和若干位选端口即可。

动态扫描的实现

- **段选**：**所有数码管的段选（A~G, DP）共用一个8位IO端口。**
- **位选**：每个数码管的位选信号分别接到不同的IO口（例如**4位数码管需要4个位选控制信号**）。
- 只需要**8个段选IO**和**4个位选IO**，总计**12个IO**即可控制4个数码管。大幅节省了单片机的IO资源。

假设：

- 段选口接到P0（8位）。
- 位选口接到P2的低4位（P2.0~P2.3）。

动态扫描的核心思想是：

- 在某一时刻只点亮一个数码管，通过**快速轮询**点亮不同的数码管，从而实现多个数码管的显示。
- **动态扫描**利用人眼的视觉暂留特性，通过快速轮询点亮不同的数码管，虽然在每个时刻只点亮一个数码管，但人眼会感知到它们是同时亮着的。
- 相当于把“并行”改为“并发”。



![image-20241115173829359](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机2之静态数码管.assets\image-20241115173829359.png)

8个IO用于段选的口，被8个数码管共用。

看到74HC245接到了VCC，必定有驱动作用。

**74HC245 作为驱动芯片使用， 目的是让数码管能获得更大的电流， 为防止因电流过大烧坏数码管， 在 74HC245 芯片输出管脚又串联了 2个 4 位的 100 欧排阻后连接数码管段码 a-dp 脚**。不必了解 74HC245 芯片使用 ，只要知道 P0 口输出什么， 74HC245 芯片就输出什么  

![image-20241115174037658](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机2之静态数码管.assets\image-20241115174037658.png)

#### 共阴极数码管的**74HC245**和**74HC138**

在基于**STC89C52单片机**的开发板中，**74HC245**和**74HC138**这两个芯片在数码管显示系统中分别承担着不同的角色。以下是它们的具体作用：

**74HC245：总线收发器**

**作用**：

- **数据总线驱动**：74HC245是一种8位三态双向总线收发器，用于实现单片机与外部设备（如数码管）之间的数据传输。
- **缓冲与隔离**：当数码管需要显示不同的数据时，STC89C52通过74HC245将数据输出到数码管的段选端（A~G 和 DP）。74HC245起到数据缓冲作用，**确保单片机的数据输出不会因为负载过多而受影响。**

**具体功能**：

- 单片机的数据输出通过74HC245进行驱动，**以增强驱动能力**。
- 控制方向引脚（DIR）和使能引脚（OE\），可灵活控制数据的传输方向以及是否输出。

**74HC138：3-8线译码器**

**作用**：

- **位选控制**：74HC138的主要功能是将3位输入（来自单片机的3个IO口）译码成8个输出中的一个。通过这个译码器，可以控制哪一个四位一体的数码管被选中，进行动态显示。
- **节省IO口**：通过3位地址输入，可以控制8个输出端，从而节省单片机IO口资源。

**具体功能**：

- 将单片机的3位控制信号译码为8个输出中的一个（Y0~Y7）。
  - 插电后，P2_2,P2_3,P2_4全部默认高电平，位选的结果是111->Y7。
  - 段选因为P0默认高电平，全亮
- 在动态扫描过程中，74HC138用于选择具体的数码管位（如四位中的第1位、第2位等），实现分时复用。

**整体工作流程**：

1. **数据传输**：STC89C52通过74HC245将要显示的段码数据传送到数码管的段选端（A~G 和 DP）。
2. **位选控制**：同时，单片机通过3个IO口控制74HC138的输入，选择某一个具体的数码管位（如第1位或第2位）。
3. **动态显示**：通过快速循环改变74HC138的输出，依次点亮不同的数码管位，配合74HC245的数据传输，实现数码管的动态显示。



### 数码管的驱动方式

**数码管的驱动方式： 单片机直接扫描：硬件设备简单，但会耗费大量的单片机CPU时间专用驱动芯片：内部自带显存、扫描电路，单片机只需告诉它显示什么即可？**

**单片机直接扫描驱动**

这种方法是**利用单片机的IO口直接控制数码管**，执行**动态扫描**来实现显示。

**工作原理**：

- 单片机控制数码管的**段选信号**（A~G 和 DP）来决定显示的字符。
- 同时，利用**位选信号**（通过位选电路如74HC138）来控制哪个数码管被点亮。
- **单片机按一定频率快速轮流点亮各个数码管，利用人眼的视觉暂留效应，使用户看到稳定的显示。**

**优点**：

- **硬件简单**：不需要额外的专用显示驱动芯片，只需少量译码器（如74HC138）和驱动电路。
- **成本低**：少用或不用外部芯片，整体电路结构简单。

**缺点**：

- **占用CPU资源多**：**单片机需要不断执行动态扫描程序，按周期刷新每个数码管。特别是需要显示复杂内容或处理其他任务时，CPU时间将被大量占用。**
- **实时性差**：**如果单片机需要同时完成其他任务（如数据采集、通信），显示刷新可能受到影响，导致显示不稳定或闪烁。**



**专用驱动芯片**

使用如**MAX7219**、**TM1637**等专用驱动芯片来控制数码管。这些芯片内部**自带显存和扫描电路**。

**工作原理**：

- 单片机通过简单的通信（如SPI或I2C）将需要显示的内容发送给专用驱动芯片。
- 专用驱动芯片负责将数据存储到内部显存，并完成数码管的动态扫描工作。
- 单片机只需在内容改变时更新数据，**无需持续参与动态扫描**。

**优点**：

- **降低单片机负担**：动态扫描由**驱动芯片自动完成**，单片机可以专注于其他任务。
- **稳定性高**：显示刷新率稳定，不受单片机运行状态影响。
- **硬件能力更强**：驱动芯片通常支持更多位数码管，且内置亮度调节等功能。

**缺点**：

- **硬件成本较高**：增加了专用芯片，硬件设计复杂度增加。
- **开发复杂性增加**：需要理解和使用驱动芯片的通信协议。

## 软件设计

虽然开发板上没有单个的静态数码管， 但依然可以在动态数码管电路中使用其中一个来学习静态数码管显示（**位选固定就行了**）。 本实验使用 SMG1 最左边那个数码管作为静态数码管（LED8）， **因为单片机 IO 口外部都增加了外部上拉电阻，因此 P22、 P23、 P24 引脚默认就是高电平** 

根据 38 译码器输出特点， **此时 Y7脚（LED8） 输出有效， 即低电平。暂时不用管**。 而数码管的段选 a-dp 连接在 74HC245 驱动芯片输出口， 由 P0 端口控制。 所以只要控制 P0 口输出高电平(**因为共阴极数码管**)， SMG1 最左边那个数码管默认就可以显示 。

位选肯定由P2_2,P2_3,P2_4经过38译码器选出。而P0端默认是高电，数码管又是共阴极的。所以我连接电源，P22、 P23、 P24 引脚默认就是高电平产生了位选，所以有一个数码管的全段是亮的。

当我不断修改P2端口的高低电平，P22、 P23、 P24 引脚可能产生了位选，导致全亮的数码管在8个中移动。

### 显示数字

控制静态数码管显示数字 0， 即让 P0 端口输出数字0 的段码 0x3f（共阴） 。  ABCDEF全给高电平，G和dp给低电平，

0011 1111也就是0x3f,单片机io口默认给高电，所以只需要控制P0_6和P0_7即可

```c
#include <REGX52.H>

typedef unsigned int u16; //对系统默认数据类型进行重定义
typedef unsigned char u8;

#define SMG_A_DP_PORT P0 //使用宏定义数码管段码口

// 使用code关键字将数据放在代码区
code u8 gsmg_code[17] = {
	0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
	0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71
};

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

void main(){
     //位选,100 （Y4从0开始）->LED5管，序号从右往左
	P2_2 = 1;
	P2_3 = 0;
	P2_4 = 0;
    //段选
	SMG_A_DP_PORT=gsmg_code[0];//将数组第 1 个数据赋值给数码管段选口
	while(1){
		
	}

}
```

**在Keil C51中,也可以使用ROM关键字,效果是一样的:**

```c
ROM u8 gsmg_code[17] = {
   0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
   0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71
 };
```

 这样做的好处是:

- 程序启动后不需要额外的初始化过程
- 数据直接从Flash中读取,执行效率高
- 节省RAM空间用于其他变量存储

### 封装

```c
#include <REGX52.H>

typedef unsigned int u16; //对系统默认数据类型进行重定义
typedef unsigned char u8;

#define SMG_A_DP_PORT P0 //使用宏定义数码管段码口

// 延时函数
void delay_ms(u16 ms);
//位选和段选
void Nixie(unsigned char Lacation,Number);

// 使用code关键字将数据放在代码区
code u8 gsmg_code[17] = {
	0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
	0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71
};


void main(){
	Nixie(1,1);
	while(1){
		
	}

}

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

//封装
/**
 * @brief 
 * 
 * @param Lacation 选择哪一个数码管，编号从1到8,位置从左数，跟原理图反过来了但直观
 * @param Number 共阴极数码管显示表中的下标
 */
void Nixie(unsigned char Lacation,Number){
	switch (Lacation) {
	case 1:
		//位选:Y7->LED8
		P2_2=1;
		P2_3=1;
		P2_4=1;
		break;
	case 2:
		//Y6
		P2_2=0;
		P2_3=1;
		P2_4=1;
		break;
	case 3:
		//Y5
		P2_2=1;
		P2_3=0;
		P2_4=1;
		break;
	case 4:
		//Y4
		P2_2=0;
		P2_3=0;
		P2_4=1;
		break;
	case 5:
		//Y3
		P2_2=1;
		P2_3=1;
		P2_4=0;
		break;
	case 6:
		//Y2
		P2_2=0;
		P2_3=1;
		P2_4=0;
		break;
	case 7:
		//Y1
		P2_2=1;
		P2_3=0;
		P2_4=0;
		break;
	case 8:
		//Y0
		P2_2=0;
		P2_3=0;
		P2_4=0;
		break;
	default:
		break;
	}
	//段选
	P0 = gsmg_code[Number];
}
```

# 动态数码管显示

对于**共阴极数码管**的动态扫描，通常采用的是**先段选，后位选**的方式。这种顺序可以有效避免显示错误和数据混论问题。

**为什么选择“先段选，后位选”？**

在动态扫描中，每次刷新一个数码管时，需要做以下操作：

1. **设置段选信号**：控制数码管的每个段（A~G 和 DP），决定显示的字符或符号。
2. **设置位选信号**：选择具体哪一位数码管被点亮。

**如果先段选，后位选：**

- 先设置好段选信号后，确保段码数据稳定。
- 然后启用对应的位选信号，点亮目标数码管。
- **这样数码管的段选和位选信号是同步的，避免显示数据错位或混乱。**

**如果先位选，后段选：**

- 位选信号会提前点亮某个位数码管，但此时段选信号可能尚未更新完成。
- 结果是，点亮的数码管会短暂显示上一帧的段选数据，导致显示“闪烁”或“乱码”。

**流程示意：先段选，后位选**

1. **更新段选信号**：将新数据加载到段选引脚，设定当前要显示的字符。
2. **设置位选信号**：选择需要点亮的数码管位。
3. **延时显示**：短暂保持显示，利用视觉暂留实现动态扫描。
4. **关闭位选信号**：为下一次切换段选信号做好准备。



**如何动态扫描？利用速度和主循环，利用视觉停留，刷新够快就看不到闪速**

```c
#include <REGX52.H>

typedef unsigned int u16; //对系统默认数据类型进行重定义
typedef unsigned char u8;

#define SMG_A_DP_PORT P0 //使用宏定义数码管段码口

// 延时函数
void delay_ms(u16 ms);
//位选和段选
void Nixie(unsigned char Lacation,Number);

// 使用code关键字将数据放在代码区
code u8 gsmg_code[17] = {
	0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
	0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71
};


void main(){
	while(1){
		Nixie(1,1);
		//delay_ms(200);
		//delay_ms(20);//这个延迟已经看不到闪烁了
		delay_ms(1);
		Nixie(2,2);
		//delay_ms(200);
		//delay_ms(20);
		delay_ms(1);
		Nixie(3,3);
		//delay_ms(200);//如果不要这么延迟的话，循环太快，导致亮度不够
		//delay_ms(20);
		delay_ms(1);//不清0还是会段选数据错乱
	}

}

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

//封装
/**
 * @brief 
 * 
 * @param Lacation 选择哪一个数码管，编号从1到8,位置从左数，跟原理图反过来了但直观
 * @param Number 共阴极数码管显示表中的下标
 */
void Nixie(unsigned char Lacation,Number){
	switch (Lacation) {
	case 1:
		//位选:Y7->LED8
		P2_2=1;
		P2_3=1;
		P2_4=1;
		break;
	case 2:
		//Y6
		P2_2=0;
		P2_3=1;
		P2_4=1;
		break;
	case 3:
		//Y5
		P2_2=1;
		P2_3=0;
		P2_4=1;
		break;
	case 4:
		//Y4
		P2_2=0;
		P2_3=0;
		P2_4=1;
		break;
	case 5:
		//Y3
		P2_2=1;
		P2_3=1;
		P2_4=0;
		break;
	case 6:
		//Y2
		P2_2=0;
		P2_3=1;
		P2_4=0;
		break;
	case 7:
		//Y1
		P2_2=1;
		P2_3=0;
		P2_4=0;
		break;
	case 8:
		//Y0
		P2_2=0;
		P2_3=0;
		P2_4=0;
		break;
	default:
		break;
	}
	//段选
	P0 = gsmg_code[Number];
}
```

可以通过延时看到他们之间的区别。这里不要延迟之后，发生了段选数据错乱显示。

## 先位选再段选的消影问题

**位选 段选  位选 段选 当第二个位选开始时，可能会把第一个段选拿过来用**

你提到的**数据混论问题**确实是动态扫描中需要特别注意的问题，它通常是由于**位选信号**和**段选信号**没有同步更新引起的。

### **问题描述：数据混论**

在动态扫描过程中，数码管的**位选**和**段选**必须配合工作。动态扫描的基本流程是：

1. 设置段选信号（显示的内容，如数字"8"的段码）。
2. 打开对应数码管的位选信号，点亮该数码管。
3. 等待一小段时间（以确保显示稳定）。
4. 关闭当前位选，更新段选，切换到下一个数码管。

**混乱问题**出现的原因：

- **位选和段选不同步**：位选信号切换得太早，导致在段选信号还未完全稳定时，下一数码管已经被点亮。
- **显示数据错位**：新数码管可能暂时显示上一数码管的段选数据，导致显示“闪烁”或“乱码”。

### **解决方案：消除数据混论**

1.**段选信号提前清零**

在切换位选和段选信号时，可以先将段选信号清零，确保位选更新时不会有不正确的数码管被点亮。

```c
#include <REGX52.H>

typedef unsigned int u16; //对系统默认数据类型进行重定义
typedef unsigned char u8;

#define SMG_A_DP_PORT P0 //使用宏定义数码管段码口

// 延时函数
void delay_ms(u16 ms);
//位选和段选
void Nixie(unsigned char Lacation,Number);

// 使用code关键字将数据放在代码区
code u8 gsmg_code[17] = {
	0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
	0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71
};


void main(){
	while(1){
		Nixie(1,1);
		//delay_ms(200);
		//delay_ms(20);//这个延迟已经看不到闪烁了
		Nixie(2,2);
		//delay_ms(200);
		//delay_ms(20);
		Nixie(3,3);
		//delay_ms(200);//如果不要这么延迟的话，循环太快，导致亮度不够
		//delay_ms(20);
	}

}

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

//封装
/**
 * @brief 
 * 
 * @param Lacation 选择哪一个数码管，编号从1到8,位置从左数，跟原理图反过来了但直观
 * @param Number 共阴极数码管显示表中的下标
 */
void Nixie(unsigned char Lacation,Number){
	switch (Lacation) {
	case 1:
		//位选:Y7->LED8
		P2_2=1;
		P2_3=1;
		P2_4=1;
		break;
	case 2:
		//Y6
		P2_2=0;
		P2_3=1;
		P2_4=1;
		break;
	case 3:
		//Y5
		P2_2=1;
		P2_3=0;
		P2_4=1;
		break;
	case 4:
		//Y4
		P2_2=0;
		P2_3=0;
		P2_4=1;
		break;
	case 5:
		//Y3
		P2_2=1;
		P2_3=1;
		P2_4=0;
		break;
	case 6:
		//Y2
		P2_2=0;
		P2_3=1;
		P2_4=0;
		break;
	case 7:
		//Y1
		P2_2=1;
		P2_3=0;
		P2_4=0;
		break;
	case 8:
		//Y0
		P2_2=0;
		P2_3=0;
		P2_4=0;
		break;
	default:
		break;
	}
	//段选
	P0 = gsmg_code[Number];
	delay_ms(1);//清0之后，低延迟也不闪烁
	P0 = 0x00;
}
```

2.**适当延时，确保段选信号稳定**

在更新段选信号之后，确保有足够的时间让段选数据稳定下来，然后再切换位选信号。

**延时的目的是：**

- 让段选信号完成传输，避免未完成传输时位选切换导致错误显示。

3.**硬件解决：使用锁存器（如74HC573）**

如果单片机IO口资源充足，可以使用锁存器来缓解段选和位选的切换问题。

- 通过锁存器将段选信号锁存住，在位选信号切换时段选数据不发生变化。
- 锁存器的作用是：段选数据先写入，等所有数据更新完毕后一次性输出到数码管。

**硬件流程**：

1. 将段选信号送入74HC573并锁存。
2. 切换位选信号，点亮特定数码管。

4. **软件优化：双缓冲技术**

通过软件设立两个段选缓冲区：

- 一个缓冲区存储要显示的数据；
- 另一个缓冲区用于更新下一次显示数据，切换完成后再替换显示缓冲区。

## 共阴极数码管的位选和段选时序

先段选再位选的方案实际上不会出现显示混乱的问题。原因如下：

先段选:

- 在切换到下一个数字之前，先将段选信号设置好
- 此时所有位选都是关闭的，所以即使段选信号改变也不会显示出来

位选开启:

- 段选信号已经稳定
- 打开对应位的位选信号
- 数字会立即正确显示

这种方案的优点是:

- 避免了段选信号转换过程中的瞬态显示
- 不会出现错误的段选样式
- 显示更稳定可靠

而先位选再段选的问题在于:

- 位选打开时段选信号还未准备好
- 会短暂显示上一个数字的段选状态
- 造成视觉上的混乱或鬼影

所以在设计数码管显示电路时，建议采用"先段选后位选"的时序控制方案。这也是业界普遍采用的方案。

**但是有没有可能第二个段选准备好了，但是第二个位选没有准备好，导致使用的是第一个位选？**

确实存在这样的风险：

1. 第一位数字正在显示(位选1开启)
2. 设置第二个数字的段选信号
3. 此时如果位选1没有及时关闭
4. 新的段选信号会在位选1上显示出来，造成错误显示

## 改进程序

```c
#include <REGX52.H>

typedef unsigned int u16; //对系统默认数据类型进行重定义
typedef unsigned char u8;

#define SMG_A_DP_PORT P0 //使用宏定义数码管段码口

// 延时函数
void delay_ms(u16 ms);
//位选和段选
void Nixie(unsigned char Location, unsigned char Number);

// 使用code关键字将数据放在代码区
code u8 gsmg_code[17] = {
	0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07,
	0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71
};


void main(){
	while(1){
		Nixie(0,0);
		Nixie(1,1);
		//delay_ms(200);
		//delay_ms(20);
		Nixie(2,2);
		//delay_ms(200);
		//delay_ms(20);
		Nixie(3,3);
	}

}

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

//封装
/**
 * @brief 
 * 
 * @param Lacation 选择哪一个数码管，编号从1到8,位置从左数，跟原理图反过来了但直观
 * @param Number 共阴极数码管显示表中的下标
 */
void Nixie(unsigned char Location, unsigned char Number){
	unsigned char LSA;
	unsigned char LSB;
	unsigned char LSC;
	
	// 边界检查
    //下标16是
	if (Location < 0 || Location > 8 || Number >= 16) {
		return;
	}
	//把数的二进制一个个拿出来单独赋值,模2也是可以的
	//八个灯最多三位数，位移的距离是死的
	// 位选控制统一处理
	LSA = Location & 1;    // P2_2
	LSB = (Location >> 1) & 1;  // P2_3
	LSC = (Location >> 2) & 1;  // P2_4
	
	P2_2 = LSA;
	P2_3 = LSB;
	P2_4 = LSC;
	//段选
	P0 = gsmg_code[Number];
	delay_ms(1);
	P0 = 0x00;
}
```

**函数中的变量必须单独定义，不能定义并同时初始化：**会报错！！！

```
	unsigned char LSA = Location & 1; 
	unsigned char LSB = (Location >> 1) & 1; 
	unsigned char LSC = (Location >> 2) & 1;
```

这么写的话，位置不好控制，只能按照电路设计原理来显示，不能像switch那样选择。因为是根据lacation来做位选赋值的，而上面那个是单独赋值的。
