# 51单片机

## 一些疑问

### STC89C52和STC89C52RC两种型号的区别？

让我来解释STC89C52和STC89C52RC这两种型号单片机的主要区别：

工作电压范围

- STC89C52: 5V±10%
- STC89C52RC: 5.5V-3.3V (具有更宽的工作电压范围)

最高工作频率

- STC89C52: 24MHz
- STC89C52RC: 35MHz(RC版本可以工作在更高频率)

功耗

- STC89C52RC的功耗更低，这也是加入"RC"后缀的主要改进之一

时钟源

- STC89C52: 需要外接晶振
- STC89C52RC: 内置RC振荡器，可以不需要外接晶振就能工作，但也支持外接晶振

成本

- STC89C52RC由于集成了RC振荡器，在不需要高精度时钟的应用场合可以省去外部晶振，从而降低整体成本

稳定性

- STC89C52RC的抗干扰能力和稳定性都有所提升

总的来说，STC89C52RC是STC89C52的改进版本，主要增加了内置RC振荡器，提高了工作频率，扩大了工作电压范围，降低了功耗。在不需要特别精确的时钟源的应用中，STC89C52RC是更好的选择。

### STC89C52的芯片手册可以用于学习STC89C52RC吗？

STC89C52的芯片手册大部分内容都可以用于学习STC89C52RC,原因如下:

核心功能一致

- 两款芯片都基于80C51内核
- 指令集完全相同
- 内部资源(定时器、中断、IO口等)的功能和使用方法基本一致
- 寄存器地址和功能大多相同

需要注意的区别

- RC振荡器相关的配置(STC89C52RC特有)
- 最高工作频率的限制不同
- 工作电压范围的差异
- 部分特殊功能寄存器(SFR)可能有细微差异

建议

- 可以先用STC89C52的手册学习基础知识
- 对于RC振荡器等特殊功能,建议参考STC89C52RC的专门说明
- 如果做实际项目,最好还是查看对应型号的最新数据手册

总的来说,STC89C52的手册可以作为学习STC89C52RC的主要参考资料,但在实际应用中要注意查证具体型号的一些特殊特性。这种学习方式是可行的,因为两者的基础架构和大部分功能都是一致的。

### **ISP软件中的波特率是什么？会影响程序的烧录速度？**

ISP软件中的波特率涉及程序烧录过程的通信速率设置，让我详细解释：

波特率的概念

- **波特率是串口通信的速率单位**，表示每秒传输的位数(bit/s)
- ISP软件中常见的波特率有：2400、4800、9600、19200、38400等

波特率与烧录速度的关系

- 波特率确实会影响程序烧录速度
- 波特率越高，数据传输越快，烧录时间越短
- **但过高的波特率可能导致通信不稳定**

波特率的选择建议

- 初次使用建议选择较低波特率(如4800或9600)进行测试
- **确认可以正常下载后，可以逐步提高波特率**
- 一般情况下19200或38400是比较理想的选择

影响烧录稳定性的因素

- 下载线的质量
- USB转串口芯片的性能
- 电脑性能和系统负载
- 供电电压的稳定性

常见问题处理

- 如果高波特率下载失败，可以尝试降低波特率
- 出现频繁下载失败，检查接线和供电是否正常
- 不同电脑可能支持的最高稳定波特率不同

实用技巧

- 开发初期可以用低波特率保证稳定性
- 程序基本完成后，可以使用高波特率加快调试效率
- 大容量程序建议使用较高波特率以节省时间

### STC89C52RC芯片的参数是什么？

下面是STC89C52RC芯片的主要参数：

内核和架构

- 增强型8051内核
- 8位CPU
- 8位数据总线
- 16位地址总线

存储器

- **8K字节Flash程序存储器**
- **512字节RAM**
- 在系统可编程(ISP)功能
- 支持IAP功能

工作参数

- 工作电压：3.3V - 5.5V
- 最高工作频率：35MHz
- **内置RC振荡器**，可选外部晶振

I/O资源

- 32个可编程I/O口
- 4个8位I/O端口(P0~P3)
- 每个I/O口都可独立编程

定时器/计数器

- 3个16位定时器/计数器
- Timer 0和Timer 1可配置为13位定时器
- Timer 2有自动重装功能

中断系统

- 8个中断源
- 4个外部中断
- 2级中断优先级

串行通信

- 全双工串行通信口(UART)
- 可编程波特率发生器

其他特性

- 看门狗定时器(WDT)
- 掉电保存模式
- 空闲模式
- 上电复位电路
- 低电压检测电路

封装类型

- **PDIP-40 (双列直插式封装)**
- PLCC-44 (塑料芯片载体封装)
- LQFP-44 (低型方形扁平封装)

### 单片机不是会一直重复执行程序吗？while的作用在哪里？

是的，在单片机中，程序会从上电或复位时开始执行，从 `main` 函数开始运行，一直顺序执行到底。如果没有特殊处理，程序会执行完最后一行后停下来或进入不可预测的状态。因此，通常需要让单片机程序在运行中保持执行，这就需要一个“主循环”。

`while` 在单片机中的作用

1. **构建主循环**
   在单片机程序中，通常会用一个 `while(1)`（或 `for(;;)`）构建一个**无限循环**，以保证程序能够持续地执行一些操作。例如：

```c
while(1) {
    // 反复执行的代码
    readSensor();
    updateDisplay();
    handleInput();
}
```

这样，无论程序执行到哪里，都会回到循环的起点，确保程序一直在运行。

**等待事件**
有些时候，你可能会在循环中等待某个条件成立，比如：

```c
while(flag == 0) {
    // 等待某个事件
}
```

在这种情况下，程序会在循环中不断检查条件，直到条件满足才会退出循环继续执行后续代码。

**响应中断和定时器**
即使在主循环中等待，中断（Interrupt）机制依然可以打断当前的执行，去处理一些更高优先级的任务，例如定时器中断、按键中断等：

```c
while(1) {
    // 主循环执行任务
    checkStatus();
    processData();
}

// 中断服务程序
void timerInterrupt() {
    // 定时任务
}
```

如果没有 `while` 主循环会怎样？

- 如果没有 `while(1)` 或类似的结构，程序可能会运行到 `main` 的最后一行，然后退出。对某些编译器或硬件而言，退出 `main` 后的行为可能是不确定的，有些可能复位，有些可能停止在某个地方。
- 这种情况下，单片机就不会再执行新的任务，也无法响应新的事件。

## 基本介绍

基本概念:

- 51单片机是Intel公司1980年推出的MCS-51系列单片机
- 型号主要有AT89C51/52等,现在主要由STC等公司生产
- 是入门单片机学习的经典选择,资料丰富

主要特点:

- CPU: 8位处理器,工作频率一般12MHz
- 内存: 程序存储ROM 4K-64K,数据RAM 128-256字节
  - RAM:512 字节
  - ROM：8K （flash，U盘也用这个）
- 定时器/计数器: 2-3个16位定时器
- I/O接口: 4组8位并行IO口(P0-P3)
- 中断: 5个中断源,2个优先级
- 串行通信接口: 全双工UART

常见应用场景:

- 智能家电控制
- 简单的数据采集
- LED显示控制
- 电机控制
- 传感器数据处理

开发工具:

- 编程语言: C语言或汇编语言
- 开发环境: Keil C51
- 仿真软件: Proteus
- 烧录器: STC-ISP

优点:

- 结构简单,易于入门
- 价格便宜,成本低
- 资料丰富,社区活跃
- 可靠性高

缺点:

- 性能相对较低
- 外设功能较少
- 内存空间小

学习建议:

1. 先掌握C语言基础
2. 了解数字电路基础知识
3. 购买开发板进行实践
4. 从简单项目开始(如LED控制)
5. 逐步学习各种外设使用
6. 尝试更复杂的项目开发

虽然51单片机性能不及新型MCU,但它结构简单,非常适合入门学习单片机开发。

### RAM和ROM

**RAM (Random Access Memory):**

- 是的,RAM相当于内存,但与计算机内存有区别
- 51单片机的RAM分为:
  - 片内RAM: 128字节
    - 直接寻址区(30H-7FH): 80个字节
    - 位寻址区(20H-2FH): 16个字节
    - 寄存器组(R0-R7): 8个字节
    - 特殊功能寄存器(SFR)
  - 片外RAM(扩展): 最大可达64K
- 特点:
  - 断电数据丢失
  - 读写速度快
  - 用于存储程序运行时的临时数据
  - 相当于计算机中的"内存",但容量小得多

**ROM (Read Only Memory):**

- 不完全等同于计算机的硬盘
- 51单片机的ROM分为:
  - 程序存储器: 存放程序代码
  - 数据存储器: 存放固定的数据表
- 特点:
  - 断电数据不丢失
  - 主要用于存储程序代码
  - Flash型可以重复擦写
  - 容量远小于计算机硬盘

**对比计算机存储器:**

8x1024B（字节） = 8x1024x8二进制位（比特bit）

```
单片机                    计算机
RAM (512字节)            内存RAM (8GB+)
ROM (8KB Flash)          硬盘 (256GB+)
```

**为什么容量这么小?**

- 单片机主要用于专用控制场景
- 程序代码一般很小
- 运行时数据需求少
- 成本和功耗考虑
- 实时性要求高

**这种存储架构特别适合单片机的应用场景:**

- 固定的控制程序(ROM)
- 少量的运行时数据(RAM)
- 快速的数据处理
- 可靠的程序存储

### 命名规则

![image-20241104102053958](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104102053958.png)

![image-20241104102029693](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104102029693.png)

STC89C52系列单片机的命名规则:

STC89C52 的命名可以分成几个部分来理解：

1. STC - 表示生产厂商是宏晶科技(STC Micro)
2. 89 - 表示是兼容Intel 8051架构的80C51系列单片机
3. C - 表示采用CMOS工艺制造
4. 52 - 表示具体型号,区分不同的存储容量:

- 52 表示内部Flash为8K字节
- **51 表示内部Flash为4K字节**

后面还可能带有一些字母后缀,表示不同的特性:

- RC: 内置RC振荡器
- RD+: 增强型,具有ISP下载功能
- AD: 带AD转换功能
- L: 低电压版本
- DIP40/PDIP40: 表示封装类型为40脚DIP
- LQFP32: 表示32脚LQFP封装
  - 封装形式（芯片对外的形式形状，配置相同的情况）
  - 长条矩形
  - 正方式

举例:

- STC89C52RC: 带RC振荡器的基本型号
- STC89C52RC-40I-PDIP40: 40脚DIP封装,工业级
- STC89C52RD+: 带ISP下载功能的增强型

### 内部结构

![image-20241104103921381](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104103921381.png)

![image-20241104103950340](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104103950340.png)

### 管脚图

![image-20241104104017785](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104104017785.png)

### 开发板原理图(普中)

![image-20241104105425143](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104105425143.png)

### 开发板结构图（普中）

![image-20241104105753909](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104105753909.png)

### 各外设介绍

![image-20241104110141467](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104110141467.png)

![image-20241104110159705](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241104110159705.png)

pJ1是电位器，是调节液晶屏的对比度（清晰度）

## 外设1：LED

**在microchip中的89C52找到对应的芯片支持包**

用途：照明、广告灯、指引灯、屏幕

![image-20241105165517257](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241105165517257.png)![image-20241112213746363](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241112213746363.png)![image-20241112213800839](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241112213800839.png)

**怎么发光的？有原理科普吗？**

LED（发光二极管）是一种通过电流发光的半导体器件。它的发光原理基于半导体中的*电子*和*空穴*的复合，当两者结合时释放出能量，以光子的形式发出。

**LED的内部结构**

LED的内部结构主要由以下几个部分组成：

1. **半导体材料**：LED的核心是一个半导体晶片，通常由砷化镓（GaAs）、氮化镓（GaN）等材料制成。不同材料会发出不同颜色的光。
2. **P-N结**：半导体内部形成了一个P-N结，即一边是P型半导体（富含空穴），另一边是N型半导体（富含电子）。
3. **电极**：LED上有正负两个电极，用于接入电源并引导电流通过P-N结。

**发光原理**

当给LED施加正向电压时，电流会从P型半导体流向N型半导体。电流通过时，P区的空穴和N区的电子在P-N结处复合，并释放出能量。由于半导体材料的特性，这些能量会以光子的形式释放出来，这就是LED发光的过程。

**总结**

只要给LED提供合适的电压和电流，它就会发光。

### 原理图

![image-20241112214248018](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241112214248018.png)

八个灯，两个联合电阻。

对应开发板中单片机位置：（VCC为正极）

![image-20241112214515520](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241112214515520.png)

### 点亮一个LED

**STC89C52RC单片机 GPIO 分为 P0、 P1、 P2 和 P3 口 其中P2端口连接着单片机的一个8位大小的寄存器，同时对应着led模块的8个led灯，当对应位为十六进制的1时，给入高电平，led熄灭，给0则亮灯？**

STC89C52RC 单片机的 GPIO 口通常以“反逻辑”方式控制 LED 模块。具体解释如下：

**即所有LED 阳极管脚接电源 VCC， 阴极管脚通过一个 470 欧的限流电阻接到 P2 口上。 根据前面 LED 的介绍我们知道， 要让 LED 发光即对应的阴极管脚应该为低电平， 若为高电平则熄灭。**  

1. **P2口与LED连接**：
   - 每个LED模块的一端接在P2口的某一位（P2.0~P2.7）。
   - 另一端通常接电源 VCC。
2. **LED的亮灭逻辑**：
   - 当 P2 口的某一位输出 **高电平**（逻辑1）时，LED两端的电压相同，电流无法通过，LED **熄灭**。
   - 当 P2 口的某一位输出 **低电平**（逻辑0）时，电流从 P2 输出流向 GND，LED **点亮**。
3. **十六进制设置**：
   - 若P2口的值为 `0xFF`（所有位为1），表示P2.0~P2.7全为高电平，对应的8个LED全熄灭。
   - 若P2口的值为 `0x00`（所有位为0），表示P2.0~P2.7全为低电平，对应的8个LED全点亮。
   - 例如：P2口写入 `0xF0`（二进制 `11110000`）时，P2.7~ ~P2.4 高电平，P2.3~ ~P2.0 低电平，前4个LED熄灭，后4个LED点亮。
   - 高位也代表寄存器的高位，P27对应D8号LED？？？

总结：

- **高电平（1）→ LED熄灭**
- **低电平（0）→ LED点亮**



**P2口与LED连接，另一端与单片机的寄存器相连？**

可以从硬件连接和控制逻辑两个角度解释**P2口**与**LED**以及**寄存器**的关系。

1. **硬件连接**

   - **P2口的每一位（P2.0 ~ P2.7）\**通过硬件连接到对应的\**LED灯**。

   - 每个**LED灯**的另一端通过限流电阻接到**GND**。

   - 实际控制的核心在于**P2口的寄存器**。STC89C52RC的每个GPIO口都对应单片机内的一个**特殊功能寄存器（SFR）**。

2. **寄存器的作用**
   - P2口的状态（高电平或低电平）是由寄存器的值决定的。
     - 当你对 `P2` 寄存器赋值时，例如 `P2 = 0xFF;`，它会将高电平输出到P2的每一位。
     - 对应的LED灯根据其连接逻辑进行点亮或熄灭。

3. **控制过程总结**

   - 软件层面：
     - 当你向P2的寄存器写入某个值（比如 `P2 = 0x00;`），P2口对应的8个引脚会输出低电平，所有LED点亮。

   - 硬件层面：
     - P2口引脚的电平直接影响LED的状态。
     - 同时，寄存器值和P2口的物理引脚一一对应，P2.0控制第一个LED，P2.1控制第二个LED，依此类推。
     - P27对应D8号LED，P2端口的单片机八位寄存器从低到高位逐个对应P2的0~7引脚，0~7引脚对应D1~D8LED灯

4. **示意图**：

```c
P2寄存器（8位） ---> P2口引脚 ---> LED灯 ---> GND
例如：
P2 = 0xF0（11110000）：前4个LED熄灭，后4个LED点亮。
P2 = 0x0F（00001111）：前4个LED点亮，后4个LED熄灭。
```

5. 程序

```c
#include <REGX52.H>

sbit LED8=P2^7; //将 P2.0 管脚定义为 LED1

void main()
{
	LED8=0; //LED1 端口设置为低电平
	while(1)
	{ 
    }
}
```

使用 sbit 关键字来定义 P2.0 管脚， 定义好后即可使用 LED1 来替代 P2.0口的操作  。

![image-20241113161156637](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241113161156637.png)

**编译结果里面的几个数据的意义：**

- **code**：
  - 表示程序代码（指令部分）在**FLASH**存储器中占用的大小。
  - 这是单片机上存储程序指令的主要区域。
  - `code` 的大小直接反映了程序在片上**Flash ROM**（非易失性存储器）中所占的空间。
- **data**：
  - 表示程序中**内部RAM**的使用情况，即程序在内部**SRAM**中为变量、寄存器分配的内存大小。
  - 内部RAM是存放全局变量、局部变量（未分配到寄存器中的部分）以及中断服务程序数据的地方。
  - **data** 部分占用的内存通常非常有限（8051单片机典型为128字节或256字节的内部RAM）。
- **xdata**：
  - 表示程序中使用的**外部RAM**（即 **XRAM**），这部分存储区域可以通过扩展芯片连接到单片机。
  - 如果你的程序需要大量的数据缓冲或大数组，通常会配置到 **xdata** 中。

**实际程序大小计算**

- 程序的实际占用空间并不是 `.hex`文件的大小，而是code和data的总和。
  - **实际程序大小 = code + data**
  - `xdata` 是外部RAM，占用的大小视硬件支持而定，不影响片上资源。

 **注意事项**

- **.hex文件大小**：
  - `.hex` 文件包含编译后的程序代码以及一些附加的元信息（地址、校验信息等），所以它的大小通常比`code` 大。
  - `.hex` 文件用于烧录到单片机中，但不等于实际的代码占用。
- **优化和分析**：
  - 通过关注 **code** 和 **data** 的大小，可以确定程序是否超出了芯片的存储限制。
  - 如果**code**过大，可以尝试优化代码，减少不必要的函数或使用更高效的算法。
  - 如果**data**超限，可能需要减少全局变量或优化局部变量的使用。

#### sbit关键字

`sbit` 关键字在 **Keil C51** 编译器中用来定义 **特殊功能寄存器**（SFR）或 **端口寄存器**的某一位（Bit Addressable），从而直接对某个管脚进行操作。

1.**`sbit` 关键字的作用**

- **`sbit`** 是用于对寄存器中的某一位（bit）进行直接操作的关键字。
- 它允许你将某一特定位（如 P2.0 引脚）定义为一个可以直接操作的变量。

```c
sbit 变量名 = 寄存器名^位;
sbit LED1=P2^0; 
P2 是 8051 单片机的 8 位 I/O 端口寄存器。
P2^0 表示 P2 寄存器的第0位，即 P2.0 引脚。
LED1 现在等价于对 P2.0 的直接操作，可以用 LED1 来控制 P2.0 引脚的高低电平。
```

**变量名**：定义的位变量名称（如 `LED1`）。

**寄存器名**：位可寻址的特殊功能寄存器或端口（如 `P2`）。

**位**：指定寄存器中的某一位（如 `0` 表示 P2.0）。

2.**位操作的优势**

- **直接操作**：可以更方便地对单片机的某个位进行控制，而无需写复杂的位操作代码。
- **更简洁**：避免每次操作都需要进行寄存器的按位与或运算。

3.**注意事项**

- 只有位可寻址寄存器才能使用 `sbit`进行定义。
  - 例如：`P0`、`P1`、`P2`、`P3` 端口，以及部分 SFR（如 `TCON`、`SCON` 等）。
- 不可位寻址的寄存器无法通过 `sbit` 操作。

### LED闪烁

如果要实现 LED 闪烁， 只需循环让 D1 指示灯先亮一会后熄灭。 这里就有一个延时问题， 如何来产生延时呢？ 我们知道单片机执行每条代码指令都是需要时间的， 在前面介绍 C 语言时讲解过循环语句， 因此只需编写一个循环函数， 让CPU 不干其它事， 专门在那循环运行即可实现延时功能。 **依据人的肉眼余晖效应，延时时间不能太短， 否则就无法观察到 LED 闪烁。**  (**使用循环来延时只是获得一个大概的时间， 并不能精确， 如需精确延时， 后期我们会学习定时器。 此处就不用纠结这个问题。  **)

```c
#include <REGX52.H>

typedef unsigned int u16; //对系统默认数据类型进行重命名

/**
 * @brief 
 * 
 * @param ten_us 循环次数
 */
void delay_10us(u16 ten_us)
{
	while(ten_us--);
}

int main(){
	while(1){
		P2 = 0xF0;//(11110000)前4个LED熄灭，后4个LED点亮。
		delay_10us(50000); //大约延时 450ms
		P2 = 0x0F;//(00001111)前4个LED点亮，后4个LED熄灭。
		delay_10us(50000);
	}
}
```

#### 共用P2端口引脚现象

##### DP1常亮

![image-20241114093627162](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241114093627162.png)

这个 DP1 LED 确实是电源指示灯。从电路图可以看到：

1. LED（DP1）通过 R17（102，即1kΩ）连接到 VCC
2. 当 USB 插入电脑后，VCC 会有 5V 电压，LED 就会点亮
3. 这样的设计正是用来指示 USB 已连接并供电的

所以 DP1 LED 常亮是完全正常的现象，表示：

- USB 已正确连接到电脑
- 电路板已获得供电
- CH340G 模块工作在正常供电状态

这个指示灯的设计很有用，可以帮助用户快速确认 USB 转 TTL 模块是否已正确接入并得到供电。

LED点亮的原理是：

1. LED需要形成**电位差**才能导通发光
2. 在这个电路中：
   - LED阳极(+)通过R17电阻（限流）连接到VCC(5V)
   - LED阴极(-)接到GND(0V)
   - 因此形成了5V的电位差

具体工作过程：

- 当USB插入时，VCC提供5V高电平
- GND提供0V低电平
- 电流从VCC经过限流电阻R17，然后通过LED流向GND
- R17(1kΩ)的作用是限制电流，**保护LED不会因电流过大而损坏**

所以说，LED能亮的关键确实就是形成了VCC到GND之间的高低电平差，并通过合适的限流电阻控制电流大小，让LED可以安全稳定地工作。



**为什么动态数码管模块也跟着闪烁？我看他们没有共用引脚啊？**



### LED流水灯

如果要实现 LED 流水灯， 只需循环让 D1-D8 指示灯逐个点亮。  在前面我们学习了 C 语言相关的基础知识， 里面有移位以及循环语句操作， 根据流水灯实现原理， 即 IO 口由低往高或者由高往低逐个输出低电平特点， **那么我们可以将移位操作以及循环结合进来。**  

```c
#include <REGX52.H>

#define LED_PORT P2 //使用宏定义 P2 端口

typedef unsigned int u16; //对系统默认数据类型进行重命名
typedef unsigned char u8;

/**
 * @brief 
 * 
 * @param ten_us 循环次数
 */
void delay_10us(u16 ten_us)
{
	while(ten_us--);
}

void main(){
	
	u8 i=0;//char类型的字符,可以节约空间而不影响效果
	while(1)
	{
		for(i=0;i<8;i++)
		{
			//将 1 右移 i 位， 然后取反将结果赋值到 LED_PORT
			//0000 0001 通过位运算和取反可以把某一位置0其他全部为1
             //D1-D8 是连接到 P2.0-P2.7 的,从低位开始，P2.0对应8位寄存器的低位
			LED_PORT=~(0x01<<i);
			delay_10us(50000);
		}
	}
}
```

**i为什么用char? 是考虑到51单片机的性能瓶颈吗？节约开销？**

1.**数据类型选择的意义**

在 8051 单片机上，选择适合的数据类型可以显著提高性能和节约存储资源。

- 8051单片机的特性：
  - 8051单片机内部只有**8位寄存器**。
  - 使用 `char` 或 `unsigned char`（8位）数据类型可以更高效地在寄存器和内存之间操作。
  - 如果使用 `int` 或 `unsigned int`（16位），需要额外的处理步骤来分两次读写数据，因为 8051 的 ALU 是 8 位的。

2.**节省存储空间**

- **`unsigned char`** 仅占 **1字节**（8位），而 `unsigned int` 占 **2字节**（16位）。
- 在资源有限的嵌入式系统中，尽量使用更小的数据类型有助于节约 RAM 和 ROM 的使用。

3.**避免不必要的性能开销**

- 使用 `int`（16位）在循环中进行计数时，8051需要更多的指令来处理16位的加法和比较。
- 使用 `char`（8位）则可以直接在单片机的寄存器中完成操作，减少指令数，提高执行效率。

4.**变量范围满足需求**

- `i` 的作用：
  - `i` 用于循环计数，从 `0` 到 `7`（总共8次）。
  - **`unsigned char`** 的范围是 `0`~`255`，完全满足 `i` 的取值需求。
  - 因此，没必要使用更大的数据类型（如 `int`）。

#### 使用左移_crol_、 右移_cror_函数  

除了使用 for 循环语句实现移位， **KEIL C51 软件内还有对应的移位库函数**，左移函数是_crol_()， 右移函数是_cror_()， 要使用这两个函数在我们的程序中必须包含 intrins.h 头文件。   

在 **Keil C51** 中，除了使用常规的 `for` 循环或位操作符 (`<<`, `>>`) 实现位移操作，还可以直接使用 Keil 提供的 **内联汇编库函数**，如 `_crol_()` 和 `_cror_()`，它们可以对变量执行高效的循环移位操作。

1.**包含头文件**

要使用这两个函数，需要包含 `intrins.h` 头文件：

```c
#include <intrins.h>
```

2.**函数说明**

`_crol_(value, count)`

- **功能**：循环左移指定位数。

- **语法**：

  - ```c
    unsigned char _crol_(unsigned char value, unsigned char count);
    ```

- **参数**：

  - `value`：需要左移的8位无符号字符（`unsigned char`）。
  - `count`：左移的位数。

  **返回值**：

  - 左移后的新值，按位循环左移。

```c
unsigned char result;
result = _crol_(0x81, 1);  // 0x81 = 1000 0001, 左移1位后结果为 0000 0011 (0x03)
```

`_cror_(value, count)`

- **功能**：循环右移指定位数。

- **语法**：

  - ```c
    unsigned char _cror_(unsigned char value, unsigned char count);
    ```

- **参数**：

  - `value`：需要右移的8位无符号字符（`unsigned char`）。
  - `count`：右移的位数。

  **返回值**：

  - 右移后的新值，按位循环右移。

```c
unsigned char result;
result = _cror_(0x81, 1);  // 0x81 = 1000 0001, 右移1位后结果为 1100 0000 (0xC0)
```

**3.循环移位 vs 普通移位**

**普通移位**： 使用位移操作符 `<<` 和 `>>`，高位或低位会补 0，不会循环回到另一端。

```c
unsigned char value = 0x81;  // 1000 0001
value = value << 1;          // 结果是 0000 0010
```

**循环移位**： 使用 `_crol_()` 和 `_cror_()`，**移出的位会循环填充到另一端。**

```c
unsigned char value = 0x81;  // 1000 0001
value = _crol_(value, 1);    // 结果是 0000 0011
```

**4.优点**

- **高效性**：相比 `for` 循环手动位移，使用 `_crol_()` 和 `_cror_()` 可以直接调用 Keil 内部优化的汇编指令，执行效率更高。
- **简洁性**：减少代码量，使程序更简洁，便于维护。

**5.适用场景**

- **LED流水灯**：用循环移位控制多个 LED 的亮灭状态。
- **加密/解密算法**：循环位移是一些加密算法中的基础操作。
- **数据处理**：需要对数据按位进行快速循环移位操作时。

```c
#include <REGX52.H>
#include "intrins.h"

#define LED_PORT P2 //使用宏定义 P2 端口

typedef unsigned int u16; //对系统默认数据类型进行重命名
typedef unsigned char u8;

/**
 * @brief 
 * 
 * @param ten_us 循环次数
 */
void delay_10us(u16 ten_us)
{
	while(ten_us--);
}

void main(){
	
	u8 i=0;
    //取反后:0000 0001-> 1111 1110
    LED_PORT=~0x01;
	while (1)
	{
		delay_10us(50000);
		LED_PORT = _crol_(LED_PORT, 1); // 循环左移 1 位,移出的位会回到右边最低位,达到0不在不同的位上的效果
	}
}
```

## 外设2：独立按键

### 前置了解

通过独立按键实验来介绍IO 口作为输入的使用。 开发板上板载 4 个独立按键。   

轻触按键：相当于是一种电子开关，按下时开关接通，松开时开关断开，实现原理是通过轻触按键内部的金属弹片受力弹动来实现接通和断开。

![image-20241114193618062](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241114193618062.png)

松开状态：

- 按键未被按下
- 上下触点分离
- 弹簧处于自然状态
- 电路断开
- 1号和2号引脚内部导通（上方虚线连接）；3号和4号引脚内部导通（下方虚线连接）

按下状态：

- 按键被按下
- 上下触点接触
- 弹簧被压缩
- 电路导通，1-2-3-4号引脚形成全连通状态

![image-20241114195545428](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241114195545428.png)

在实际使用时：

- **通常将一对引脚（如1-2）接到电路中作为信号输入**
- 另一对引脚（如3-4）可以不使用，或用作双保险
- 按键按下时，可以通过**检测相应引脚的电平变化来判断按键状态**



**在实际使用时，按键通常与单片机的IO口相连，通过检测高低电平来判断按键状态。需要注意的是，实际电路中通常还需要添加去抖动电路，以消除按键抖动带来的干扰。**

通常的按键所用开关为机械弹性开关,当机械触点断开、 闭合时，由于机械点的弹性作用， 按键开关在闭合时不会马上稳定的接通， 在断开时也不会一下子断开， 因而在闭合和断开的瞬间均伴随着一连串的抖动。 抖动时间的长短由按键的机械特性决定的， 一般为 5ms 到 10ms。 按键稳定闭合时间的长短则由操作人员的按键动作决定的， 一般为零点几秒至数秒。 按键抖动会引起按键被误读多次。 为了确保 CPU 对按键的一次闭合仅作一次处理， 必须进行消抖。

![image-20241114200320300](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241114200320300.png)

这个示意图展示了按键抖动现象的关键特点：

**按下瞬间的抖动：**

- 理想情况下应该是一次性从高电平切换到低电平
- 实际上会在5-10ms内反复震荡
- 可能造成单次按键被识别为多次按键

**释放瞬间的抖动：**

- 理想情况下应该是一次性从低电平返回高电平
- 实际上同样会出现5-10ms的震荡过程
- 同样可能导致错误的信号识别

**按键稳定时间：**

- 在抖动结束后，信号会保持稳定
- 持续时间取决于操作人员的按键时长
- 通常在0.1秒到数秒不等

这种现象的产生原因：

- 机械触点的弹性特性
- 触点材料的物理特性
- 按键结构的机械特性

因此在实际应用中需要：

1. 进行软件或硬件消抖处理
2. 常用的消抖方法包括：
   - 延时消抖
   - 多次采样消抖
   - RC硬件消抖电路

这种现象在所有机械按键中都普遍存在，是设计按键电路时必须考虑的重要因素。



生活中的防抖(去抖动)设计确实源于这个原理,主要是为了区分人为的有效按压和意外的瞬时触碰。让我解释一些日常生活中的例子：

手机的开机键：

- 需要长按2-3秒才能开机
- 防止口袋里意外碰触导致开关机
- 给用户一个"确认"的过程

电梯按钮：

- 按下后需要一定的按压力度和时间
- 避免轻微触碰就启动
- 确保是人为的有意识操作

智能手表：

- 抬腕点亮屏幕需要一定幅度和速度
- 不是随便晃动就亮屏
- 减少电量消耗和误操作

电子门锁：

- 指纹解锁需要完整的指纹信息
- 触摸按键需要一定的停留时间
- 防止雨滴、灰尘等造成误触

设计这些防抖机制的目的是：

1. 确保操作的目的性
2. 提高使用安全性
3. 降低误操作概率
4. 延长设备寿命
5. 提升用户体验

这就是为什么我们在设计电子产品时，会刻意加入一些"延迟"或"确认"机制，这不是缺陷，而是很重要的人性化设计。

按键消抖有两种方式， 一种是硬件消抖， 另一种是软件消抖。 为了使电路更加简单， 通常采用软件消抖。 我们开发板也是采用软件消抖， 一般来说一个简单的按键消抖就是**先读取按键的状态， 如果得到按键按下之后， 延时 10ms， 再次读取按键的状态， 如果按键还是按下状态， 那么说明按键已经按下。 其中延时10ms 就是软件消抖处理**  ：

1. 先设置 IO 口为高电平（由于开发板 IO 都有上拉电阻， 所以默认 IO 为高电平） 。  
2. 读取 IO 口电平确认是否有按键按下。
3. 如有 IO 电平为低电平后， 延时几个毫秒。
4. 再读取该 IO 电平， 如果仍然为低电平， 说明按键按下。
5. 执行按键控制程序

### 按键介绍

独立按键电路构成是由各个按键的**一个管脚（一个按键通常只使用一对引脚）连接在一起接地**， 按键其他引脚分别接到单片机 IO 口。  

我们知道单片机的 IO 口既可作为输出也可作为输入使用， 当检测按键时用的是它的**输入功能**， 独立按键的一端接地， 另一端与单片机的 I/O 口相连， 开始时先给该 IO 口赋一高电平， 然后让单片机不断地检测该 I/O 口是否变为低电平， 当**按键闭合时， 即相当于该 I/O 口通过按键与地相连， 变成低电平， 程序一旦检测到 I/O 口变为低电平则说明按键被按下， 然后执行相应的指令**  。

### 硬件设计

![image-20241114193849562](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241114193849562.png)

从上图中可以看出， 4 个独立按键的控制管脚连接到 51 单片机的 P3.0-P3.3脚上。 其中 K1 连接在 P3.1 上， K2 连接在 P3.0 上， K3 连接在 P3.2 上， K4 连接在 P3.3 上。 4 个按键另一端全部连接在 GND， **当按键按下后， 对应 IO 口即为低电平  。**

### 软件设计

**一个完整的按键检测过程：**

1. 检测到按键按下(低电平)
2. 延时消抖
3. 再次检测确认是真实按下
4. 等待按键释放
5. 释放消抖
6. 再次检测确认是真实松开
7. 执行按下一次按键的程序
8. 返回继续检测

**这样的设计可以保证:**

- 按键动作被准确识别
- 不会产生重复触发
- 抗干扰性好

#### 按键检测完整示例

```c
#include <REGX52.H>

void Delay(unsigned char xms)
{
    unsigned int i, j;
    while(xms--)
    {
        i = 2;
        j = 239;
        do{
            --j;
        }while(--i);
    }
}

unsigned char Key()
{
    unsigned char KeyNumber = 0;
    
    if(P3_0 == 0)        // 第一步：检测按下
    {
        Delay(20);       // 第二步：按下消抖
        if(P3_0 == 0)    // 第三步：确认按下
        {
            KeyNumber = 1;  // 记录按键状态
            
            while(P3_0 == 0);  // 等待按键松开
            
            Delay(20);        // 第四步：松开消抖
            if(P3_0 == 1)     // 第五步：确认松开
            {
                // 可以在这里添加按键松开时的操作
                return KeyNumber;  // 返回按键值
            }
        }
    }
    
    return 0;  // 无按键按下或者按键检测失败返回0
}

void main()
{
    while(1)
    {
        switch(Key())
        {
            case 1:
                P2_0 = !P2_0;  // 按键完整的按下和松开才翻转LED
                break;
            default:
                break;
        }
    }
}
```

如果不检测按键松开并不消抖的问题：

- 按下按键不放时：

  - LED会快速反复翻转

  - 因为主循环会反复检测到按键按下

- 释放按键时：

  - 可能因为释放抖动被识别为新的按下

  - 导致LED又翻转一次

#### 1.使用独立按键控制LED亮灭

```c
#include <REGX52.H>

// 数据类型重定义
typedef unsigned int u16;
typedef unsigned char u8;

// 按键引脚定义
sbit KEY1 = P3^1;
sbit KEY2 = P3^0;
sbit KEY3 = P3^2;
sbit KEY4 = P3^3;

// LED引脚定义，板子最左边第一个灯
sbit LED1 = P2^0;

// 按键状态定义
#define KEY1_PRESS   1
#define KEY2_PRESS   2
#define KEY3_PRESS   3
#define KEY4_PRESS   4
#define KEY_UNPRESS  0

// 延时函数
void delay_ms(u16 ms)
{
    u16 i, j;
    while(ms--)
    {
        i = 2;     // 这里的数值根据实际单片机频率调整
        j = 239;   // 以达到准确的1ms延时
        do
        {
            --j;
        }while(--i);
    }
}

// 按键检测函数
u8 key_scan(void)
{
    //循环很快，当按下时会被记录一次状态，没有松开，当再一次进入循环时，状态还是按下状态，不会返回值
    //只有按下后松开，松开逻辑才会把状态改为松开状态，那么下一次按下时才会返回值
    static u8 key_state = KEY_UNPRESS;  // 记录上一次的按键状态
    
    // 检测KEY1
    if(KEY1 == 0)  // 第一次检测到按下
    {
        delay_ms(20);  // 消抖
        if(KEY1 == 0)  // 确认按下
        {
            if(key_state == KEY_UNPRESS)  // 之前是未按下状态
            {
                key_state = KEY1_PRESS;
                return KEY1_PRESS;
            }
        }
    }
    else if(KEY2 == 0)  // 检测KEY2
    {
        delay_ms(20);
        if(KEY2 == 0)
        {
            if(key_state == KEY_UNPRESS)
            {
                key_state = KEY2_PRESS;
                return KEY2_PRESS;
            }
        }
    }
    else if(KEY3 == 0)  // 检测KEY3
    {
        delay_ms(20);
        if(KEY3 == 0)
        {
            if(key_state == KEY_UNPRESS)
            {
                key_state = KEY3_PRESS;
                return KEY3_PRESS;
            }
        }
    }
    else if(KEY4 == 0)  // 检测KEY4
    {
        delay_ms(20);
        if(KEY4 == 0)
        {
            if(key_state == KEY_UNPRESS)
            {
                key_state = KEY4_PRESS;
                return KEY4_PRESS;
            }
        }
    }
    else  // 所有按键都未按下或者按下后松开了
    {
        delay_ms(20);  // 松开消抖
        if(KEY1 == 1 && KEY2 == 1 && KEY3 == 1 && KEY4 == 1)  // 确认都松开
        {
            key_state = KEY_UNPRESS;  // 恢复未按下状态，static局部变量
        }
    }
    
    return KEY_UNPRESS;  // 返回未按下状态
}

void main()
{
    u8 keyStatus = KEY_UNPRESS;
    
    // 初始化LED状态，LED初始熄灭，不需要因为默认高电熄灯状态
    //LED1 = 1; 
    
    while(1)
    {
        keyStatus = key_scan();  // 扫描按键
        
        switch(keyStatus)
        {
            case KEY1_PRESS:
                LED1 = !LED1;  // LED状态翻转
                break;
            case KEY2_PRESS:
                // KEY2处理逻辑
                break;
            case KEY3_PRESS:
                // KEY3处理逻辑
                break;
            case KEY4_PRESS:
                // KEY4处理逻辑
                break;
            default:
                break;
        }
    }
}
```

**优雅的地方：**

- **使用状态机记录按键状态**
- **只在按下瞬间返回按键值**
- **等待完全松开才能触发下一次按键**
- **不需要使用while循环等待按键释放**

主要优化点：

1. 按键检测改进：
   - 增加了`static`状态变量记录按键状态
   - 实现了按键防抖
   - 避免了重复触发
   - **松开检测更可靠**
2. 状态机设计：
   - 清晰的按下和松开状态转换
   - 更好的抗干扰性
   - 支持连续按键检测

这种方式更适合实际应用，因为：

1. **响应更及时**
2. **不会阻塞程序执行**(**while会一直等待你释放，如果你按下不松开灯是不反应的**)
3. 可以轻松扩展多键检测
4. 可以添加长按检测功能

#### 2.使用独立按键控制LED显示二进制

```c
#include <REGX52.H>

// 数据类型重定义
typedef unsigned int u16;
typedef unsigned char u8;

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

void main(){
	//0~255
	unsigned char LEDNum = 0;
	while(1){
		if(P3_1==0){
			//消抖
			delay_ms(20);
			while(P3_1==0);//等待按键松开
			//消抖
			delay_ms(20);
			//确认松开
			if(P3_1==1){
				//完成了一次按下并松开，可以执行程序
				//避免超出范围对LEDNum校验,255可以表示，256不行
				//不校验好像也行，因为最高位溢出后为全0，取反为全1也是全灭
				//溢出校验部分可以省略，因为unsigned char类型的溢出是自动循环的。
				//自增到255时再加1会回到0，因此不需要这个溢出校验。
//				if(LEDNum==256){
//					LEDNum=0;
//				}
				LEDNum++;
				//p2初始为全高电：1111 1111
				//LEDNum进行按位取反运算时，计算机会转换为char类型的8为二进制
				//那么此时自增在二进制上有了变化，LED灯就可以显示
				P2=~LEDNum;
			}
		}
	}
}
```

- 十进制的自增，计算机转换为二进制后，二进制是有变化的
- 要想用LED来显示二进制的变化

刚开始为十进制0，即二进制0000 0000。1->0000 0001。 2->0000 0010。 3->0000 0011

如果直接使用LED表示的话，效果是反的。可以等二进制出来之后再按位取反即可实现LED对应的效果。

**这里可以直接可以使用P3_1去访问单片机对应的端口，在头文件中有定义。**

**问题：**

**但是低位对应的是D1在左边，不太直观。观感上低位应该在右边**

十进制数出来之后，再把他的二进制的高位变成低位，低位变成高位即可。

**给一个变量接收一下，直接逐个位给我取出来**

```c
#include <REGX52.H>

// 数据类型重定义
typedef unsigned int u16;
typedef unsigned char u8;

unsigned char reverseBits1(unsigned char num);
void delay_ms(u16 ms);


void main(){
	//0~255
	unsigned char LEDNum = 0;
	while(1){
		if(P3_1==0){
			//消抖
			delay_ms(20);
			while(P3_1==0);//等待按键松开
			//消抖
			delay_ms(20);
			//确认松开
			if(P3_1==1){
				//完成了一次按下并松开，可以执行程序
				//避免超出范围对LEDNum校验,255可以表示，256不行
				//不校验好像也行，因为最高位溢出后为全0，取反为全1也是全灭
				//溢出校验部分可以省略，因为unsigned char类型的溢出是自动循环的。
				//自增到255时再加1会回到0，因此不需要这个溢出校验。
//				if(LEDNum==256){
//					LEDNum=0;
//				}
				LEDNum++;
				//p2初始为全高电：1111 1111
				//LEDNum进行按位取反运算时，计算机会转换为char类型的8为二进制
				//那么此时自增在二进制上有了变化，LED灯就可以显示
				P2=~reverseBits1(LEDNum);
			}
		}
	}
}

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

unsigned char reverseBits1(unsigned char num) {
	unsigned char result = 0;
	int i;
	for (i = 0; i < 8; i++) {
		//操作八次即可把所有位置换掉
		//左移result为下一位腾出空间
		//开始那个0可以看作没有的，后面会挤出去
		result <<= 1;
		// 取num的最低位加到result上
		//直接取二进制的最低位，在对应位置上按位或运算即可
		result |= (num % 2);
		// 右移num准备处理下一位
		num >>= 1;
	}
	return result;
}
```

 

#### 两种响应方式的区别

利用static关键字的继承性，按下的瞬间，LED直接响应，只有松开才会响应下一次按键（**响应更及时**）

而利用while等待释放，LED是按键按下并松开之后才响应。

1. 响应时机：
   - while方式：按下→松开→响应
   - static方式：按下→响应→松开
2. 用户体验：
   - while方式：有明显延迟感
   - static方式：反应更迅速
3. 程序执行：
   - while方式：会阻塞程序执行
   - static方式：不会阻塞，可以处理其他任务
4. 扩展性：
   - while方式：难以添加长按等功能
   - static方式：容易扩展新功能（比如长按、连击）

所以static方式更适合实际应用，响应更快更自然！

#### 3.使用独立按键控制LED移位

```c
#include <REGX52.H>

// 数据类型重定义
typedef unsigned int u16;
typedef unsigned char u8;

// 按键引脚定义
sbit KEY1 = P3^1;
sbit KEY2 = P3^0;
sbit KEY3 = P3^2;
sbit KEY4 = P3^3;

// 按键状态定义
#define KEY1_PRESS   1
#define KEY2_PRESS   2
#define KEY3_PRESS   3
#define KEY4_PRESS   4
#define KEY_UNPRESS  0

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

// 按键检测函数
u8 key_scan(void)
{
	//循环很快，当按下时会被记录一次状态，没有松开，当再一次进入循环时，状态还是按下状态，不会返回值
	//只有按下后松开，松开逻辑才会把状态改为松开状态，那么下一次按下时才会返回值
	static u8 key_state = KEY_UNPRESS;  // 记录上一次的按键状态
	
	// 检测KEY1
	if(KEY1 == 0)  // 第一次检测到按下
	{
		delay_ms(20);  // 消抖
		if(KEY1 == 0)  // 确认按下
		{
			if(key_state == KEY_UNPRESS)  // 之前是未按下状态
			{
				key_state = KEY1_PRESS;
				return KEY1_PRESS;
			}
		}
	}
	else if(KEY2 == 0)  // 检测KEY2
	{
		delay_ms(20);
		if(KEY2 == 0)
		{
			if(key_state == KEY_UNPRESS)
			{
				key_state = KEY2_PRESS;
				return KEY2_PRESS;
			}
		}
	}
	else if(KEY3 == 0)  // 检测KEY3
	{
		delay_ms(20);
		if(KEY3 == 0)
		{
			if(key_state == KEY_UNPRESS)
			{
				key_state = KEY3_PRESS;
				return KEY3_PRESS;
			}
		}
	}
	else if(KEY4 == 0)  // 检测KEY4
	{
		delay_ms(20);
		if(KEY4 == 0)
		{
			if(key_state == KEY_UNPRESS)
			{
				key_state = KEY4_PRESS;
				return KEY4_PRESS;
			}
		}
	}
	else  // 所有按键都未按下或者按下后松开了
	{
		delay_ms(20);  // 松开消抖
		if(KEY1 == 1 && KEY2 == 1 && KEY3 == 1 && KEY4 == 1)  // 确认都松开
		{
			key_state = KEY_UNPRESS;  // 恢复未按下状态，static局部变量
		}
	}
	
	return KEY_UNPRESS;  // 返回未按下状态
}

void main()
{
	u8 keyStatus = KEY_UNPRESS;
	u8 LEDNuml = 0;
	u8 LEDNumr = 1;
	
	while(1)
	{
		keyStatus = key_scan();  // 扫描按键
		
		switch(keyStatus)
		{
		case KEY1_PRESS:
             //灯从最左边出来，不断的赋特殊值来达到亮灯效果
			//如果按了一次K1按键,左移一位
			//P2初始是全灭，按一下应该是 1111 1110取反前应该是0000 0001
			//只能移动8次，i从0~7
			if(LEDNuml==8){
				//第八次重置状态，又从最左边第一个出来
				LEDNuml = 0;
			}
             //1:1111 1110 2:1111 1101 3:1111 1011 4:1111 0111 ... 7:0111 1111 8:1111 1110
			P2 = ~(0x01<<LEDNuml);
			LEDNuml++;
			break;
		case KEY2_PRESS:
			// KEY2处理逻辑
			break;
		case KEY3_PRESS:
			// KEY3处理逻辑
			break;
		case KEY4_PRESS:
			// KEY4处理逻辑,按一下右移动一位
			//可以一直右移，到0000 0001时就是P2为1111 1110时，再右移就全熄灭嘛，再右移也无所谓
			//需要获取现在P2的状态
			P2 = ~((~P2)>>LEDNumr);
			break;
		default:
			//没按或者按了一次没松开，循环很快，统统从这里出去再进循环
			break;
		}
	}
}
```

左移动比右移动的条件多一点，右移动只需要直接拿P2的值进行取反按位右移即可。

这一种是不循环的移位灯，如果要想循环，可以使用自带的函数。或者不断的使用0x01左移，不过是移多少位达到对应的效果而已，只用左移也能达到右移的效果。

因为D1在左边，低位对应的灯在左边，所以效果是反过来的,互换两个按键的代码即可。

```c
#include <REGX52.H>

// 数据类型重定义
typedef unsigned int u16;
typedef unsigned char u8;

// 按键引脚定义
sbit KEY1 = P3^1;
sbit KEY2 = P3^0;
sbit KEY3 = P3^2;
sbit KEY4 = P3^3;

// 按键状态定义
#define KEY1_PRESS   1
#define KEY2_PRESS   2
#define KEY3_PRESS   3
#define KEY4_PRESS   4
#define KEY_UNPRESS  0

void delay_ms(u16 ms);
// 按键检测函数
u8 key_scan(void);



void main()
{
	u8 keyStatus = KEY_UNPRESS;
	u8 LEDNuml = 0;
	u8 LEDNumr = 1;
	
	while(1)
	{
		keyStatus = key_scan();  // 扫描按键
		
		switch(keyStatus)
		{
		case KEY1_PRESS:
			//如果按了一次K1按键,左移一位
			//可以一直右移，到0000 0001时就是P2为1111 1110时，再右移就全熄灭嘛，再右移也无所谓
			//需要获取现在P2的状态
             //
			P2 = ~((~P2)>>LEDNumr);
			break;
		case KEY2_PRESS:
			// KEY2处理逻辑
			break;
		case KEY3_PRESS:
			// KEY3处理逻辑
			break;
		case KEY4_PRESS:
             //灯从最左边出来，不断的赋特殊值来达到亮灯效果
			//如果按了K4按键，就右移动一位
			//P2初始是全灭，按一下应该是 1111 1110取反前应该是0000 0001
			//再按一次应该是1111 1101取反前应该是0000 0010
			//因为K4在板子右边，led高位灯在右边
			//只能移动8次，i从0~7
			if(LEDNuml==8){
				//重置状态
				LEDNuml = 0;
			}
             //1:1111 1110 2:1111 1101 3:1111 1011 4:1111 0111 ... 7:0111 1111 8:1111 1110
			P2 = ~(0x01<<LEDNuml);
			LEDNuml++;
			break;
		default:
			//没按或者按了一次没松开，循环很快，统统从这里出去再进循环
			break;
		}
	}
}

// 延时函数
void delay_ms(u16 ms)
{
	u16 i, j;
	while(ms--)
	{
		i = 2;     // 这里的数值根据实际单片机频率调整
		j = 239;   // 以达到准确的1ms延时
		do
		{
			--j;
		}while(--i);
	}
}

// 按键检测函数
u8 key_scan(void)
{
	//循环很快，当按下时会被记录一次状态，没有松开，当再一次进入循环时，状态还是按下状态，不会返回值
	//只有按下后松开，松开逻辑才会把状态改为松开状态，那么下一次按下时才会返回值
	static u8 key_state = KEY_UNPRESS;  // 记录上一次的按键状态
	
	// 检测KEY1
	if(KEY1 == 0)  // 第一次检测到按下
	{
		delay_ms(20);  // 消抖
		if(KEY1 == 0)  // 确认按下
		{
			if(key_state == KEY_UNPRESS)  // 之前是未按下状态
			{
				key_state = KEY1_PRESS;
				return KEY1_PRESS;
			}
		}
	}
	else if(KEY2 == 0)  // 检测KEY2
	{
		delay_ms(20);
		if(KEY2 == 0)
		{
			if(key_state == KEY_UNPRESS)
			{
				key_state = KEY2_PRESS;
				return KEY2_PRESS;
			}
		}
	}
	else if(KEY3 == 0)  // 检测KEY3
	{
		delay_ms(20);
		if(KEY3 == 0)
		{
			if(key_state == KEY_UNPRESS)
			{
				key_state = KEY3_PRESS;
				return KEY3_PRESS;
			}
		}
	}
	else if(KEY4 == 0)  // 检测KEY4
	{
		delay_ms(20);
		if(KEY4 == 0)
		{
			if(key_state == KEY_UNPRESS)
			{
				key_state = KEY4_PRESS;
				return KEY4_PRESS;
			}
		}
	}
	else  // 所有按键都未按下或者按下后松开了
	{
		delay_ms(20);  // 松开消抖
		if(KEY1 == 1 && KEY2 == 1 && KEY3 == 1 && KEY4 == 1)  // 确认都松开
		{
			key_state = KEY_UNPRESS;  // 恢复未按下状态，static局部变量
		}
	}
	
	return KEY_UNPRESS;  // 返回未按下状态
}
```

待改进：灯左移置0后，右移动不是从最左边开始？？？

```c
case KEY1_PRESS:
			//如果按了一次K1按键,左移一位
			//可以一直右移，到0000 0001时就是P2为1111 1110时，再右移就全熄灭嘛，再右移也无所谓
			//需要获取现在P2的状态
			P2 = ~((~P2)>>LEDNumr);
			break;
			
case KEY4_PRESS:
             //灯从最左边出来，不断的赋特殊值来达到亮灯效果
			//如果按了K4按键，就右移动一位
			//P2初始是全灭，按一下应该是 1111 1110取反前应该是0000 0001
			//再按一次应该是1111 1101取反前应该是0000 0010
			//因为K4在板子右边，led高位灯在右边
			//只能移动8次，i从0~7
			if(LEDNuml==8){
				//重置状态
				LEDNuml = 0;
			}
             //1:1111 1110 2:1111 1101 3:1111 1011 4:1111 0111 ... 7:0111 1111 8:1111 1110
			P2 = ~(0x01<<LEDNuml);
			LEDNuml++;
			break;
```

先左移亮灯再右移动熄灯可以，但是先右移动熄灯再出来时会跳灯，不是从最左边出来？？？？

## 外设3：蜂鸣器

通过单片机的一个 IO 口控制板载无源蜂鸣器， 实现蜂鸣器控制 。

###  蜂鸣器介绍

**磁式蜂鸣器和压电式蜂鸣器在外形上都没有什么太大的差别是吗？ 主要在发声原理和内部构成上。 但是能那种能播放MP3音乐的扬声器不一样是吗？这种是只有一种声音那种吗？**

让我来帮你理解这几种发声元件的区别:

**磁式蜂鸣器和压电式蜂鸣器:**

- 外形确实比较相似,通常都是圆柱形
- 主要区别在内部原理:
  - 磁式是利用电磁感应,通过电流变化带动振膜发声
  - 压电式是利用压电陶瓷材料受电压变形来发声
- **它们一般只能发出固定频率的"嘀嘀"声,不能播放复杂的音乐**

**扬声器:**

- 外形和构造都与蜂鸣器有明显区别
- 内部有音圈、磁铁和较大的振膜
- 能播放各种频率的声音,所以可以播放音乐、语音等
- 通常体积也要大一些,因为需要较大振膜来重现不同频率声音

扬声器相当于是"全频段"发声设备,而蜂鸣器更像是"单音"设备,主要用于提示音、报警音等简单用途。



**蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型:**

压电式蜂鸣器主要由多谐振荡器、 压电蜂鸣片、 阻抗匹配器及共鸣箱、 外壳等组成。 多谐振荡器由晶体管或集成电路构成， 当接通电源后（1.5~15V 直流工作电压） ， 多谐振荡器起振,输出 1.5～5kHZ 的音频信号， 阻抗匹配器推动压电蜂鸣片发声。  

磁式蜂鸣器由振荡器、 电磁线圈、 磁铁、 振动膜片及外壳等组成。 接通电源后， 振荡器产生的音频信号电流通过电磁线圈， 使电磁线圈产生磁场， 振动膜片在电磁线圈和磁铁的相互作用下， 周期性地振动发声  。

一句话就可概括它们之间的区别， 想要压电式蜂鸣器发声， 需提供一定频率的脉冲信号； 想要电磁式蜂鸣器发声， 只需提供电源即可  

**开发板上使用的蜂鸣器是无源蜂鸣器， 属于压电式蜂鸣器类型**。 这里说的有源和无源， 并不是指电源的意思， 而是指蜂鸣器内部是否含有振荡电路， **有源蜂鸣器内部自带振荡电路， 只需提供电源即可发声**， 而**无源蜂鸣器则需提供一定频率的脉冲信号才能发声， 频率大小通常在 1.5-5KHz 之间**。  

**对于无源蜂鸣器， 如果改变频率就可以调节蜂鸣器音调， 产生各种不同音色、音调的声音。 如果改变输出电平的高低电平占空比， 则可以改变蜂鸣器的声音大小。**

对于有源蜂鸣器， 通常内部已经固定了频率， 对于调节频率或占空比可能改变不了蜂鸣器的音调和音量， 当然也有的有源蜂鸣器可以实现和无源蜂鸣器一样的效果。 



**“滴滴”还有音色可言？**

无源蜂鸣器确实可以通过调节输入信号来改变发声:

**频率控制音调:**

- 不同频率对应不同音高
- 比如可以用不同频率产生"哆来咪发索拉西"等音符
- 通常工作频率在2-5kHz范围内

**占空比控制音量:**

- PWM信号的占空比越大,声音越大
- 占空比越小,声音越小
- 可以实现渐强渐弱的效果

所以无源蜂鸣器其实可以:

- 播放简单的音乐旋律
- 制作各种提示音效
- 甚至可以组合出一些简单的音乐片段

但它和扬声器的区别是:

- 不能同时发出多个频率的声音(不能和弦)
- 音色比较单一,不能像扬声器那样还原复杂的音色



###  硬件设计

**要实现蜂鸣器的控制， 我们能否直接使用单片机的 IO 口驱动呢？ 答案是否定的， 因为 51 单片机 IO 口的驱动能力较弱（即使外接上拉电阻） ， 而蜂鸣器驱动需要约 30mA， 所以非常困难， 即使可以驱动， 那对于整个芯片的其它 IO 剩下驱动能力就更加弱甚至无法工作**

让我来解释这个驱动能力的问题:

**单片机IO口的局限:**

- 51单片机**每个IO口**的**最大输出电流一般只有10-20mA左右**
- 即使加了上拉电阻也无法提供更大电流
  - 上拉电阻还可以增强电流？

**蜂鸣器的需求:**

- 需要约30mA的驱动电流才能正常工作
- 这**超出了单片机IO口的直接驱动能力**

**问题后果:**

- 如果强行用IO口直接驱动:
  - 蜂鸣器声音可能很弱
  - IO口负担过重可能损坏
  - 其他IO口的工作电流会受影响
  - 整个单片机可能工作不稳定



解决方案是什么呢? 通常需要加装三极管或MOS管作为驱动电路:

- **IO口控制三极管开关**（**主要在控制**）
- **三极管承担主要电流负担**
- 这样就能安全地驱动蜂鸣器,同时保护单片机

这就像**用遥控器(IO口)来控制大功率设备(蜂鸣器),中间需要一个"继电器"(三极管)来承担大电流。**

所以我们不会直接使用 IO 口驱动蜂鸣器， 而是通过**三极管把电流放大后再驱动蜂鸣器**， 这样 51 单片机的 IO 口只需要提供不到 1mA 的电流就可控制蜂鸣器。所以我们也经常说到 51 单片机是用来做控制的， 而不是驱动。

我们开发板上的蜂鸣器模块电路如下图所示：  

![image-20241113194515830](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241113194515830.png)  

图中并没有使用三极管进行电流放大， 而是使用 ULN2003 芯片来驱动 ，现在暂时只需知道当 P25 输出高电平， BEEP 则输出低电平； 当 P25 输出低电平， BEEP 则输出高电平， 类似一个非门  。

开发板上使用的是无源蜂鸣器， 它需要一定频率的脉冲（高低电平） 才会发声， 因此需要**让 P25 脚以一定频率不断输出高低电平信号才能控制蜂鸣器发出声音**  。

#### P2端口共用问题

**我看了STC89C52RC的开发板原理图： 控制无源压电式蜂鸣器是通过"五线四项步进电机"连接到 51 单片机的 P2.5 管脚上的， 但是我之前学习时，控制led模块我记得P2端口上的八个寄存器都是控制led的高低电平的啊？ 还可以共用吗？如果到时候需要同时调用这两个不会出错？**

对于 51 单片机，P2 端口是一个 8 位的并行 I/O 口。如果同时连接了蜂鸣器和 LED 模块，它们共用 P2 的某些引脚，使用同一引脚时会产生冲突。

**蜂鸣器连接**：
蜂鸣器连接在 P2.5 上。当你控制蜂鸣器时，需要设置 P2.5 的高低电平。

**LED 模块连接**：
你的 LED 模块也是通过 P2.0~P2.7 连接。使用 LED 时，所有的灯会对应 P2 的不同引脚。如果你操作 P2.5 使其控制蜂鸣器，这同时也会影响 LED 模块上连接到 P2.5 的灯。

**解决方法：**

**使用位运算控制 P2 口的单个引脚**： 为避免影响 P2 的其他引脚，可以使用位运算只修改特定位，比如 P2.5。这样，你可以单独控制蜂鸣器而不改变 P2 的其他位，类似如下代码：

```c
// 只控制 P2.5
P2 |= 0x20;  // 设置 P2.5 为高电平
P2 &= ~0x20; // 设置 P2.5 为低电平
```

**其他引脚操作**： 你可以用同样的方法，单独操作 P2 的其他引脚来控制 LED。比如：

```c
P2 |= 0x01;  // 设置 P2.0 为高电平，点亮对应的 LED
P2 &= ~0x01; // 设置 P2.0 为低电平，熄灭对应的 LED
```

**重要提示：**

在程序中，需要注意在操作 P2 口某一位时不要直接赋值 `P2 = x;`，这样会覆盖 P2 的所有引脚状态，导致 LED 模块和蜂鸣器的状态都发生变化。

通过位运算精确控制，就能让 P2.5 控制蜂鸣器，而其他引脚仍可以正常控制 LED。

#### P2.5使用出现的问题

**当我修改P2.5时，单片机怎么知道我要使用是led还是蜂鸣器？**

单片机本身**无法直接“知道”**你是要控制 LED 还是蜂鸣器。P2.5 的高低电平会同时影响连接在这个引脚上的所有设备。因此，控制逻辑和硬件电路设计中必须明确区分这些设备的使用场景，避免冲突。

**问题核心**：

- **单片机只负责设置引脚的高低电平**。
- 如果 P2.5 同时连接了 LED 和蜂鸣器，当你设置 P2.5 高电平或低电平时，**LED 和蜂鸣器都会响应**，因为它们都受同一个引脚控制。

**解决方法**：

要解决这个问题，可以从**硬件设计**或**软件逻辑**两个方面来处理。

**开发板只看软件逻辑方面了**：

**硬件肯定没办法了，因为我买的是开发板，只能从软件方面下手了。 你的意思是没有办法避免？ 但是我的蜂鸣器需要不断的提供高低电平啊？ 难道我的led是跟着熄灭和亮灯？**

在你的场景下，确实会遇到蜂鸣器和 LED 共用 P2.5 引脚的问题。如果蜂鸣器需要持续产生高低电平来发声，而 LED 也连接到 P2.5，那 LED 将会同步响应这些电平变化，表现为**LED 闪烁**。

**无法完全避免**蜂鸣器和 LED 共用引脚的干扰。

通过**分时控制**或利用**视觉暂留效应**，可以在一定程度上减轻 LED 的闪烁感。



**我知道我使用led时，为什么蜂鸣器不响了？ 因为我使用led时，是持续的输入高电平或者低电平，而蜂鸣器需要不断的输入高低电平所以蜂鸣器没有反应？ 这么来看，当我使用LED时，不用担心蜂鸣器。但是使用蜂鸣器时，P2.5对应的灯一定会同时响应对吗？**

**LED 控制时：**

- **LED 控制**通常是通过设置一个引脚为**持续的高电平**或**低电平**来实现的，比如 P2.5 为高电平时，LED 就会亮，低电平时，LED 就会熄灭。
- 在这种情况下，LED 模块**不需要**连续的高低电平变化，它只是响应当前的电平状态。因此，当你控制 LED 时，蜂鸣器**不会有反应**，因为蜂鸣器通常需要连续的高低电平变化来发声。

**蜂鸣器控制时：**

- **蜂鸣器控制**通常是通过持续的高低电平切换来驱动的。例如，蜂鸣器需要不断地改变 P2.5 引脚的状态（高电平和低电平交替），才能发出声音。
- **LED 控制会受到影响**：当你在蜂鸣器工作时，P2.5 的高低电平变化会同时影响 P2.5 上连接的 LED，所以**LED 会同时闪烁**。这就是你提到的蜂鸣器和 LED 之间的冲突。

**总结：**

- **使用 LED 时，不用担心蜂鸣器**，因为 LED 只是响应持续的高低电平，而蜂鸣器需要频繁切换电平来发声。
- **使用蜂鸣器时，P2.5 上的 LED 一定会同时响应**，因为蜂鸣器的高低电平切换会导致 LED 闪烁。

在实际应用中，如果蜂鸣器和 LED 必须共用 P2.5 引脚，那么你可以采取一些控制策略（如分时控制或利用视觉暂留效应），来减少 LED 闪烁对整体效果的影响。

### 软件设计

让蜂鸣器发出声音， 一段时间后再关闭， 即让 P2.5管脚输出一定频率的脉冲信号（高低电平） 控制无源蜂鸣器。

```c
#include <REGX52.H>
#include "intrins.h"


typedef unsigned int u16; //对系统默认数据类型进行重命名
typedef unsigned char u8;

sbit BEEP=P2^5; //将 P2.5 管脚定义为 BEEP

/**
 * @brief 
 * 
 * @param ten_us 循环次数
 */
void delay_10us(u16 ten_us)
{
	while(ten_us--);
}

void main(){
	
	u16 i=2000;//char也可以啊，怎么不用char?,ascii码没那么大？
	while(1)
	{
		while(i--)//循环 2000 次
		{
			BEEP=!BEEP;//产生一定频率的脉冲信号
			delay_10us(100);
		} 
		i=0;//清零
		BEEP=0;//关闭蜂鸣器，共用的D6号LED灯因为持续低电平而亮灯
	}
}
```

**之前用小循环时，是使用char来的，这次为什么使用int?2000太大了？ascii没有？ 循环内取反这能输出不断的高低电平吗？**

1.**为什么使用 `int` 而不是 `char`？**

- `char` 在大多数编译器中通常是 8 位（即范围为 -128 到 127 或 0 到 255），而 `int` 一般是 16 位（在 16 位系统上通常是 16 位，范围为 -32768 到 32767 或 0 到 65535）。你提到的 `i = 2000;` 是一个大于 255 的数字，所以用 `char` 类型会不适合，因为它无法表示 2000（会溢出）。所以你使用 `u16`（即 `unsigned int`，16 位）来表示 2000，是正确的选择。
- **0~9的ascii码为48~57，这就意味着10次循环以内都可以使用char代替。超出就表示不了**

2.**这能输出不断的高低电平吗？**

- 是的，你的代码能够不断输出高低电平。每次进入 `while(i--)` 循环时，`BEEP=!BEEP;` 会切换 P2.5 上的电平状态，从而驱动蜂鸣器发声。每次切换后，程序会调用 `delay_10us(100)` 来延时 100 个 10 微秒单位，从而控制蜂鸣器发声的频率。大约造成 100 * 10 微秒的延时（即 1 毫秒），你可以根据需要调整延时，以控制蜂鸣器的频率。

**3.为什么用 `!BEEP` 而不是 `~BEEP`？**

- **逻辑反转**：`!` 只会将 `BEEP` 的值从“真”变成“假”或从“假”变成“真”，很适合用来控制像蜂鸣器那样需要**高电平和低电平交替**的操作。
- **按位操作**：如果使用 `~BEEP`，它会对 `BEEP` 中的每一位进行按位取反操作，产生的效果可能不是你想要的，因为 `BEEP` 是一个单一的引脚控制，而不是一个多位的数值。`~` 适用于需要操作每一位的场景。
- **这是赋值+逻辑非运算不是单独的一个运算符`=！`**

结论：

- `!BEEP` 用于对 `BEEP` 进行**逻辑取反**，适合控制引脚的高低电平。
- `~BEEP` 用于对 `BEEP` 的**每一位进行按位取反**，这对于单个引脚控制不适用。

#### 改进程序

要在你的程序中添加控制音量和音色的功能，可以通过调整 `delay_10us()` 函数中的延时值来改变蜂鸣器的频率，进而影响音色（频率）和音量（脉冲的周期）。下面是你程序的修改版，其中通过修改变量来控制音量和音色。

**主要修改点：**

1. **音色（频率）**：通过修改 `i` 和 `delay_10us()` 的参数来控制脉冲的频率。较小的 `i` 值和较短的延时会产生更高的频率，较大的值会产生较低的频率。
2. **音量**：通过调整脉冲的占空比（脉冲的持续时间和间隔时间比例）来控制音量。通过增加高电平和低电平的持续时间比例来调节音量。

```c
#include <REGX52.H>
#include "intrins.h"

typedef unsigned int u16;  // 对系统默认数据类型进行重命名
typedef unsigned char u8;

sbit BEEP = P2^5;  // 将 P2.5 管脚定义为 BEEP

/**
 * @brief 延时函数，控制脉冲的频率
 * 
 * @param ten_us 循环次数
 */
void delay_10us(u16 ten_us)
{
    while(ten_us--);
}

/**
 * @brief 主函数
 * 
 * 在此函数中，通过修改 `i` 和 `delay_10us()` 来控制音量和音色
 *音色是由频率决定的，这间接影响了周期T，严格在T/2处翻转高低电平才可以产生不同的音阶
 */
void main()
{

    while(1)
    {
        u16 frequency = 2000;  // 用于控制音色，数值越小音调越高
        u16 volume = 100;      // 用于控制音量，数值越大音量越低
        u16 i = frequency;  // 控制频率的变量
		
        // 循环控制脉冲的频率
        //延迟循环函数不太精准，只能听个响
        while(i--)
        {
            // 产生高低电平脉冲信号
            BEEP = !BEEP;  
            // 控制脉冲的占空比，调节音量
            //每一次自减的间隔就是一个T，减到8进入循环，改到高电平~~~减到7进入第二循环，改到低电平
            //应该是产生了一个方波，但是后面延迟函数改变了高电平或者低电平的持续时间，所以这个函数是有问题的
            delay_10us(volume); 
        }

        BEEP = 0;  // 关闭蜂鸣器
        delay_10us(5000);  // 稍作延迟，以免连续发出噪音
    }
}
```

**不能持续放出声音的原因：**

- **延时函数的不准确性**：
  - `delay_10us` 只是简单的循环延时，受编译器优化、系统主频的影响，无法精确到10微秒。而在方波信号中，精确的高低电平持续时间（即周期的精准性）对声音频率的稳定性至关重要。
- **逻辑上的方波生成不准确**
  - 在每次循环中，方波的高低电平切换由 `BEEP = !BEEP` 触发，**但延迟时间 `delay_10us(volume)` 不一致，使得每次高电平和低电平持续时间不同，从而破坏了方波的对称性，导致蜂鸣器发出的声音异常。**

**可以使用延时函数通过循环来模拟频率，但不推荐这样做**，尤其是在需要稳定、精准的频率输出时，比如驱动蜂鸣器持续发声。以下是原因和分析：

**CPU主频和优化的影响**

- 延时函数依赖 `while` 循环计数，其实际延时长度取决于 CPU 主频和编译器优化。
- 在某些情况下，编译器可能优化掉部分空循环，导致延时不准确。

**频率不稳定**

- 蜂鸣器需要一定范围的频率（通常在几百Hz到几kHz之间）才能发声。
- 使用循环延时的方式可能无法精确控制蜂鸣器的驱动频率，从而导致声音断续或无法发声。

**阻塞问题**

- **延时函数会阻塞 CPU，使其无法执行其他任务。**
- **在嵌入式系统中，通常需要让 CPU 处理其他任务或响应中断，这就要求延时方式非阻塞。**



##### 为什么推荐使用定时器

**定时器的优点：**

1. **精确控制**：定时器能够在硬件层面产生精确的周期性中断，避免了软件延时的误差。
2. **非阻塞**：**主程序可以继续执行其他任务，而蜂鸣器通过中断机制保持发声。**
3. **易于调节**：可以简单地修改定时器初值来改变发声频率。

#### 改进程序2

```c
#include <REGX52.H>

typedef unsigned int u16;  
typedef unsigned char u8;

sbit BEEP = P2^5;  // 定义蜂鸣器引脚

// 音调频率表(以周期计，单位为微秒)
//根据频率反推导各音阶周期值
//使用code关键字把数组存到flash中去
code u16 TONE_TABLE[] = {
	3822,   // 低音 do
	3405,   // 低音 re
	3034,   // 低音 mi
	2863,   // 低音 fa
	2551,   // 低音 so
	2273,   // 低音 la
	2025    // 低音 xi
};

//数组必须要int,因为里面数比较大
//但是下标没超过9，可以用char代替节约空间
// 当前播放的音调索引
u8 currentTone = 0;

void Timer0_Init()
{
	//按位与（AND） 和 按位或（OR） 的组合赋值运算符。它们的作用是对变量执行按位操作，然后将结果赋回给该变量。
	TMOD &= 0xF0;  // 清空定时器0模式位
	TMOD |= 0x01;  // 定时器0设置为模式1（16位定时器）
	ET0 = 1;       // 使能定时器0中断
	EA = 1;        // 使能全局中断
	TR0 = 1;       // 启动定时器
}

void Timer0_SetFrequency(u16 period)
{
	u16 reloadValue = 65536 - (period * 11.0592 / 12);  // 根据周期计算定时器重载值
	TH0 = reloadValue >> 8;  // 定时器初值高字节
	TL0 = reloadValue & 0xFF;  // 定时器初值低字节
}

void Timer0_ISR() interrupt 1
{
	static u8 toggle = 0;
	
	Timer0_SetFrequency(TONE_TABLE[currentTone]);  // 每次中断更新频率
	toggle = !toggle;
	BEEP = toggle;  // 翻转蜂鸣器电平
}

void main()
{
	Timer0_Init();
	
	while (1)
	{
		// 循环播放音调
		currentTone++;
		if (currentTone >= sizeof(TONE_TABLE) / sizeof(TONE_TABLE[0])) {
			currentTone = 0;  // 如果音调索引超出范围，则从头开始
		}
		
		// 延时一段时间后切换到下一个音调
        //i有语法错误？？？用int也不行？
		for (u16 i = 0; i < 10000; i++);
	}
}
```

**使用定时器控制方波**：

- 利用了定时器0中断来生成高精度的方波，确保每个周期的高低电平切换时间准确。

**音阶表的使用**：

- 通过 `TONE_TABLE` 定义了常见音阶的周期（以微秒为单位），便于实现不同音调的播放。

**代码结构清晰**：

- 中断服务函数负责蜂鸣器的高低电平切换，主循环保持简洁，方便后续扩展功能。

**主循环中可以扩展：**

- 例如可以通过按键切换音阶

- currentTone = (currentTone + 1) % 7;  // 切换音阶
- 延时模拟按键切换



##### code关键字

```
// 音调频率表(以周期计，单位为微秒)
code u16 TONE_TABLE[] = {
    3822,   // 低音 do
    3405,   // 低音 re
    3034,   // 低音 mi
    2863,   // 低音 fa
    2551,   // 低音 so
    2273,   // 低音 la
    2025    // 低音 xi
};
```

在单片机（尤其是像STC89C52RC这样的单片机）编程中，是否使用 `code` 关键字修饰数组，取决于你**希望数组存放在哪里以及如何访问它**。单片机的内存结构通常有不同的存储区域（如 RAM 和 Flash），而 `code` 关键字用于指定数组或变量存放在闪存（Flash）中。

- 作用：`code`关键字用于将数据存储在单片机的 程序存储区（Flash内存）中，而不是RAM。**Flash内存通常存储程序代码和只读数据（如常量数组、查找表等）**。这种方式常用在以下几种情况：
  - 存储 **常量数据**，例如音调频率表、字符串等。
  - 不会修改这些数据，因为Flash内存是不可写的（只能在编程时写入）。
  - **节省RAM的使用，避免把不需要修改的数据存放在更昂贵的RAM中。**

**不使用 `code` 关键字（默认存储在RAM）：**

- 如果你的数组数据是 **动态的**，即会在程序运行期间修改的，那么你应该将其存储在RAM中。此时，不需要使用 `code` 关键字。

- ```c
  u16 dynamicArray[10];
  ```

- 这种数组存储在RAM中，允许在程序运行时进行读写操作。

**总结使用 `code` 关键字的场景：**

- **使用 `code`**：当你定义的数组是 **常量** 或者 **查找表**，并且不需要修改它的内容时（例如音调表、波形数据、文本等），可以使用 `code` 关键字将它们放在 **Flash存储区**，节省RAM。
- **不使用 `code`**：当数组的内容需要修改时，或者数组数据是 **运行时变化** 的数据，则应存储在 **RAM** 中，而不需要 `code` 关键字。

 **是否必须使用 `code`？**

- **并非必须**：只有在你明确需要将数据放入 Flash 存储区时才需要使用 `code` 关键字。如果你的数据会动态变化或需要频繁操作，那么你应避免使用 `code`，而是将它存放在RAM中。
- **RAM和Flash的选择**：RAM速度快，但内存有限；Flash内存较大，但读取速度可能较慢，且不能随意修改。因此，选择放在RAM或Flash中取决于数据是否需要修改以及内存使用的权衡。



##### 定时器

这个 `Timer0_Init` 函数是用来初始化和配置单片机上的定时器0。它的目的是使能定时器0，并设置其工作模式。

1.**为什么不需要引入其他头文件？**

在STC89C52RC这种单片机开发中，通常使用的头文件是 `REGX52.H`，这个文件已经**包含了对硬件寄存器的定义，包括定时器相关的寄存器**。因此，你不需要另外引入其他头文件，只需要引入 `REGX52.H`，它会包含所有必要的定义和宏。

**2.硬件支持与自己定义函数**

单片机本身提供了硬件定时器支持，STC89C52RC（以及其他类似的单片机）有多个定时器/计数器。虽然硬件提供了定时器功能，但开发者仍然需要通过编程来配置和使用它们。定时器的配置通常涉及以下几个方面：

- 选择定时器的工作模式（例如，16位定时器、8位定时器等）。
- 配置定时器的初值（即定时器溢出时的计数值）。
- 配置定时器中断，以便在定时器溢出时触发中断服务程序。

因此，你需要定义函数来设置和启动定时器，以确保它按照你的需求工作。

**3.定时器相关的寄存器和变量**

- **TMOD (定时器控制寄存器)**：控制定时器的工作模式。对于定时器0，TMOD的低4位表示定时器0的工作模式。

  - **TMOD 的低4位** 控制定时器0的模式，最高位是控制定时器1的模式。

  - 模式1是16位定时器模式。

- **ET0 (定时器0中断使能位)**：使能定时器0的中断功能。如果设置为1，定时器0的溢出将触发中断。

- **EA (全局中断使能位)**：使能所有中断。如果设置为1，系统将响应所有中断请求，包括定时器中断。

- **TR0 (定时器0启动控制位)**：如果设置为1，定时器0将开始计数。如果设置为0，定时器0停止。

**4.通俗理解**

**定时器**可以理解为一个**计时器**，它的作用就是在特定的时间间隔后触发某些操作，或者周期性地执行某些任务。在单片机中，定时器通常用来实现精确的时间控制、生成延时、计数事件等功能。

可以将定时器类比为一个**时钟**，它每过一段时间就会“响铃”一次。这个时钟的“响铃”可以触发一些特定的操作。

假设我们有一个 **数字计时器**，它有如下几个重要的设置：

- **时钟频率**：这是计时器每秒“滴答”的次数。
- **时钟模式**：你可以选择它如何计时，比如**每秒**滴答一次，或者**每毫秒**滴答一次等。
- **启停控制**：你可以启动或停止这个计时器。

```c
void Timer0_Init()
{
    TMOD &= 0xF0;  // 清空定时器0模式位
    TMOD |= 0x01;  // 定时器0设置为模式1（16位定时器）
    ET0 = 1;       // 使能定时器0中断
    EA = 1;        // 使能全局中断
    TR0 = 1;       // 启动定时器
}
```

**`TMOD &= 0xF0;`**

- 还有“&=”这种运算符？

- 类比：这就像你在设置计时器之前，**清理掉了一些旧的设置**，确保开始时计时器没有任何干扰。
- `TMOD` 是**定时器**的控制**寄存器**，它的低4位控制定时器0的工作模式。`TMOD &= 0xF0` 清除了低4位（即定时器0的设置），为后面的配置做好准备。

**`TMOD |= 0x01;`**

- 类比：这相当于你设定计时器的“工作方式”，就像选择数字计时器是**按小时、分钟还是秒来计时**。
- `TMOD |= 0x01;` 表示将定时器0设置为 **模式1**，即16位定时器模式。这样定时器会计时16位的数据（即从0到65535），**每次计时到65535时，它就会溢出一次，重新开始计时。**

**`ET0 = 1;`**

- 类比：这就像你告诉计时器：“每次滴答一次（计时器溢出时），要提醒我（发出响铃声）”。
- `ET0 = 1;` 使能定时器0的中断，**这样每当定时器0计时到溢出时，它就会触发一个中断，程序会去执行相应的中断服务程序（就像响铃后触发某个操作）。**

**`EA = 1;`**

- 类比：这是像打开整个计时系统的“开关”，如果没有打开它，计时器就不会发出响铃（即使定时器中断被启用，它也不会被响应）。
- `EA = 1;` 使能全局中断，允许单片机响应所有中断请求，包括定时器0的中断。**它就像是一个总开关**，只有打开这个开关，定时器中断才能生效。

**`TR0 = 1;`**

- 类比：这是启动计时器的命令，相当于按下了计时器的“开始”按钮，**让它开始计时**。
- `TR0 = 1;` 启动定时器0，开始计时。此时定时器会开始运行，并按照配置的模式进行计时。





##### **音调的原理**

蜂鸣器通过方波驱动产生声音，方波的**频率决定音调**。每个音调对应一个固定的频率，**频率的倒数是周期**（单位为微秒）。

方波示例（占空比 50%）：

```c
高电平 |______|______|
低电平 |      |      |
时间   0      T/2    T
```

一个周期 T包括高电平时间 T_{high} = T/2  和低电平时间 T_{low} = T/2。定时器中断每隔一段时间触发，切换蜂鸣器的高低电平。

在产生方波时，**一个周期 T** 分为两个部分：

1. **高电平持续 T/2**
2. **低电平持续 T/2**

**核心原理：**

为了产生一个频率为 f=1/T的方波：

- 在 **每个 T/2** 的时间点，**反转电平**。
- 通过不断切换高低电平，蜂鸣器就能发出对应频率的声音。
- 音阶的固定频率**直接影响**了方波的**高低电平反转时间点 T/2**



##### **定时器控制频率**（此后面待整理）

利用**定时器中断**实现方波的高低电平切换，具体过程如下：

1. **音调周期表（`TONE_TABLE`）**
   - 每个音调的周期用微秒表示。
   - 例如：`do` 的周期是 3822 微秒，即频率约为 261.63 Hz。
2. **定时器中断实现周期控制**
   - 定时器每次计满后进入中断，软件累加一个计数器。
   - 当计数器累计到指定的音调周期值时（如 3822 微秒），翻转蜂鸣器电平，完成一个方波周期。

##### **程序模块功能**

(1) **主程序 `main`**

- 初始化定时器。
- 主循环中可以实现其他任务，比如按键调节音量、切换音调等。

(2) **定时器初始化 `Timer0_Init`**

- 配置定时器0为模式1（16位定时）。
- 加载初值 `TH0` 和 `TL0`，确保中断触发间隔为一定时间。

(3) **定时器中断 `Timer0_ISR`**

- 在中断中实现蜂鸣器高低电平的切换：
  1. **累加计数器**：每次中断执行时，累加微秒计数。
  2. **判断是否到达指定周期**：当计数器值等于或超过当前音调的周期时，翻转蜂鸣器电平，生成方波。
  3. **重置计数器**：完成一次周期后，计数器归零，准备下一次中断。

##### **示例分析**

- 蜂鸣器的方波信号：
  - 假设当前音调为 `do`，周期为 3822 微秒。
  - 定时器初值 `TH0` 和 `TL0` 设置为 1ms 的中断间隔。
  - 每1ms中断一次，计数器每次加1。
  - 当计数器累计到约3822 / 1000 ≈ 3.8次后，翻转蜂鸣器电平，完成一个周期。

##### **程序执行流程**

1. **主程序初始化**
   - 配置蜂鸣器引脚。
   - 初始化定时器，设置中断优先级。
2. **定时器中断**
   - 定时器每隔一小段时间（1ms）触发中断。
   - 在中断中根据音调周期表翻转蜂鸣器电平，生成稳定的方波信号。

#### 改进程序3

如果你能产生音阶，实际上可以通过调节音符的频率来生成简单的伴奏。你的代码中通过定时器产生了一个基础的音符频率，可以作为音阶的基础。要生成伴奏，你可以通过以下几个步骤来扩展：

- **添加更多音符**：通过调整 `TONE_TABLE[]` 来存储不同的音符频率。你已经定义了一些低音音符，但你可以添加其他音符（比如中音、高音等）来丰富音阶。

- **实现节奏控制**：伴奏的节奏可以通过调整每个音符的播放时长来控制。比如，可以在播放每个音符时设置一个定时器，控制音符的持续时间。

- **音符序列**：你可以定义一个音符序列（如一段简单的旋律），然后根据时间间隔依次播放这些音符，形成节奏和旋律。

- **播放多个音符**：通过更复杂的逻辑来切换不同音符的频率，可以实现类似和弦的效果，模拟简单的伴奏。

```c
#include <REGX52.H>
typedef unsigned int u16;
typedef unsigned char u8;
sbit BEEP = P2^5;

// 音符频率表(单位:微秒)
code u16 TONE_TABLE[] = {
    3822,   // 1 (低音do)
    3405,   // 2 (低音re)
    3034,   // 3 (低音mi)
    2863,   // 4 (低音fa)
    2551,   // 5 (低音so)
    2273,   // 6 (低音la)
    2025,   // 7 (低音xi)
    1911,   // 1. (中音do)
    1703,   // 2. (中音re)
    1517,   // 3. (中音mi)
    1432,   // 4. (中音fa)
    1276,   // 5. (中音so)
    1136,   // 6. (中音la)
    1012    // 7. (中音xi)
};

// 音符结构体定义
typedef struct {
    u8 tone;    // 音符音高(0-13对应低音do到中音xi)
    u16 rhythm; // 节拍长度(单位:ms)
} Note;

// 小星星简谱: 1 1 5 5 6 6 5 4 4 3 3 2 2 1
code Note SONG[] = {
    {0, 500}, {0, 500}, {4, 500}, {4, 500},
    {5, 500}, {5, 500}, {4, 750},
    {3, 500}, {3, 500}, {2, 500}, {2, 500},
    {1, 500}, {1, 500}, {0, 750},
    {255, 0}  // 结束标记
};

u16 current_note = 0;    // 当前音符索引
u16 note_duration = 0;   // 当前音符剩余时间
bit is_playing = 1;      // 播放状态

void Timer0_Init()
{
    TMOD &= 0xF0;
    TMOD |= 0x01;
    TH0 = 0xFC;
    TL0 = 0x18;
    ET0 = 1;
    EA = 1;
    TR0 = 1;
}

void Timer0_ISR() interrupt 1
{
    static u16 count = 0;
    static bit toggle = 0;
    
    if(is_playing && SONG[current_note].tone != 255) {
        count++;
        if(count >= TONE_TABLE[SONG[current_note].tone]) {
            count = 0;
            toggle = !toggle;
            BEEP = toggle;
            note_duration--;
        }
        
        if(note_duration == 0) {
            current_note++;
            if(SONG[current_note].tone != 255) {
                note_duration = SONG[current_note].rhythm;
            }
        }
    }
}

// 播放控制函数
void PlayControl(bit play_state)
{
    is_playing = play_state;
}

// 重置播放
void ResetPlay()
{
    current_note = 0;
    note_duration = SONG[0].rhythm;
    is_playing = 1;
}

void main()
{
    note_duration = SONG[0].rhythm;
    Timer0_Init();
    
    while(1)
    {
         if (SONG[current_note].tone == 255) // 如果到达结束标记
        {
            ResetPlay();  // 重置到第一个音符，开始新一轮播放
        }
        // 可以加入其他按键功能实现暂停/继续等
        // 在这里可以添加按键控制:
        // - 播放/暂停
        // - 重置播放
        // - 切换歌曲等功能
    }
}
```

1. 扩展了音阶范围：
   - 增加了中音区的音符
   - 现在可以演奏更丰富的曲目
2. 更灵活的音乐定义：
   - 使用结构体定义音符，包含音高和节拍
   - 可以方便地定义不同的曲目
   - 使用255作为结束标记
3. 播放控制功能：
   - 增加了播放/暂停控制
   - 添加了重置播放功能
   - 预留了扩展接口
4. 示例曲目：
   - 加入了"小星星"的简谱作为示例
   - 可以轻松替换为其他曲目

要进一步完善这个音乐播放器，你可以：

1. 添加按键控制逻辑
2. 存储多首曲目并支持切换
3. 添加音量控制（通过PWM调节）
4. 实现和弦效果（需要额外的蜂鸣器）
5. 添加LED显示当前播放状态

##### 实现原理

**基本原理**

- 蜂鸣器的发声原理是通过方波信号驱动，不同频率的方波产生不同的音调
- 每个音符都有特定的频率，我们通过控制方波周期来实现不同音高
- 通过控制发声持续时间来实现不同的节奏

**硬件设计**

- ```c
  sbit BEEP = P2^5;  // 蜂鸣器连接到P2.5口
  ```

- 使用STC89C52RC单片机的P2.5引脚输出驱动信号,采用无源蜂鸣器，需要我们提供方波信号

**音符频率表设计**

- ```c
  code u16 TONE_TABLE[] = {
      3822,   // 低音do (频率约262Hz)
      3405,   // 低音re (频率约294Hz)
      //...
  };
  ```

- 数组中存储的是每个音符对应的周期值(单位:微秒)

- 计算公式: 周期值 = 1000000/频率

- 使用code关键字将数据存储在程序存储器中

**定时器实现**

- ```c
  void Timer0_Init()
  {
      TMOD &= 0xF0;   // 设置定时器0为16位模式
      TMOD |= 0x01;
      TH0 = 0xFC;     // 定时1ms
      TL0 = 0x18;
      ET0 = 1;        // 开启定时器0中断
      EA = 1;         // 开启总中断
      TR0 = 1;        // 启动定时器
  }
  ```

- 使用定时器0生成精确的时间基准 。定时器设置为1ms中断一次

**音符播放实现**

- ```c
  void Timer0_ISR() interrupt 1
  {
      static u16 count = 0;
      static bit toggle = 0;
      
      if(is_playing && SONG[current_note].tone != 255) {
          count++;
          // 当计数达到音符周期时
          if(count >= TONE_TABLE[SONG[current_note].tone]) {
              count = 0;
              toggle = !toggle;     // 翻转输出电平
              BEEP = toggle;        // 输出到蜂鸣器
              note_duration--;      // 递减持续时间
          }
          
          // 当前音符播放完成
          if(note_duration == 0) {
              current_note++;       // 切换到下一个音符
              if(SONG[current_note].tone != 255) {
                  note_duration = SONG[current_note].rhythm;
              }
          }
      }
  }
  ```

- 在定时器中断中实现音符的播放

- 通过计数器实现精确的频率控制

- 通过持续时间控制音符的节奏

**音乐数据结构**

- ```c
  typedef struct {
      u8 tone;    // 音符
      u16 rhythm; // 节拍长度
  } Note;
  ```

- 使用结构体将音符和节奏信息组合在一起。便于定义和存储完整的乐曲

**播放控制**

- ```c
  void PlayControl(bit play_state)
  {
      is_playing = play_state;  // 控制播放状态
  }
  
  void ResetPlay()
  {
      current_note = 0;         // 重置到第一个音符
      note_duration = SONG[0].rhythm;
      is_playing = 1;
  }
  ```

- 提供基本的播放控制功能；可以暂停/继续播放；可以重置到开始位置

**时序关系:**

- 定时器每1ms中断一次
- 在中断中累加计数器，达到音符周期时翻转电平
- 每次翻转电平时递减音符持续时间
- 当音符持续时间为0时切换到下一个音符

**扩展性考虑:**

- 音符数据结构支持添加更多属性（如音量）
- 可以定义多首歌曲
- 预留了按键控制接口
- 可以添加LED显示等功能

通过这样的设计，我们实现了一个简单但完整的音乐播放系统。系统可以准确地控制音高（通过频率）和节奏（通过持续时间），从而播放出完整的音乐作品。

##### 总结

1.通过方波信号使蜂鸣器发出声音，方波信号通过一个T周期的T/2处改变高低电平产生。 

2.而音阶是有频率的，由此可以得到周期T（即频率倒数），由此可以生成不同音阶的方波。 

3.通过持续这一些具有音阶的方波可以产生音乐的节奏。 

4.原来确定T/2位置我使用延迟循环函数实现，但是不准确。后面改成了更精确的定时器

**方波信号产生音阶的原理**:

```c
高电平  ----┐    ┌----┐    ┌----
            |    |    |    |
低电平      └----┘    └----┘
            
            ←  T →
            ← T/2→
```

- 一个完整周期T = 1/频率
- 在T/2处翻转电平，就能产生占空比为50%的方波
- 例如：中音A(440Hz)的周期T ≈ 2273微秒，所以每1136.5微秒翻转一次电平

**为什么使用定时器比延时函数更精确**:

```c
// 延时函数方式（不推荐）
void playTone(u16 freq) {
    u16 delay = 500000/freq;  // 计算T/2
    while(1) {
        BEEP = !BEEP;
        Delay(delay);         // 软件延时不准确
    }
}

// 定时器方式（推荐）
void Timer0_ISR() interrupt 1 {
    if(count >= TONE_TABLE[note_index]) {
        count = 0;
        BEEP = !BEEP;        // 精确的硬件定时
    }
}
```

主要原因：

1. 延时函数受到以下因素影响：
   - 系统时钟误差
   - 指令执行时间波动
   - 中断干扰
   - 其他任务影响
2. 定时器的优势：
   - 硬件定时，精度高
   - 独立于CPU运行
   - 可以处理其他任务
   - 中断优先级保证实时性

##### 音量控制

**PWM调制方式** (推荐)，工作原理:

```c
最大音量(100%占空比):
高  ----┐    ┌----┐    ┌----
        |    |    |    |
低      └----┘    └----┘

中等音量(50%占空比):
高  --┐ ┌--┐ ┌--┐ ┌--┐ ┌--
      | | | | | | | | | |
低    └-┘ └-┘ └-┘ └-┘ └-

最小音量(10%占空比):
高  -┐  ┌-┐  ┌-┐  ┌-┐  ┌-
     |  |  |  |  |  |  |  |
低   └--┘  └--┘  └--┘  └--
```

主要区别：

1. PWM方式:
   - 软件实现,不需要额外硬件
   - 可以实现更细腻的音量控制
   - 需要较高的PWM频率(>20kHz)避免啸叫
   - 会占用一些CPU资源
2. 在实际应用中：
   1. 如果追求音质和控制精度,建议用PWM方式
   2. 如果追求简单可靠,建议用分压电阻方式
   3. 也可以两种方式结合使用
3. 需要注意的是：
   1. PWM频率要足够高,避免产生可听见的噪声
   2. PWM占空比变化要平滑,避免突变产生杂音
   3. 分压电阻的阻值要适当,太大会影响声音效果

**节奏我也是通过定时器不断产生相同音阶来实现。但是音量应该怎么控制呢？**

- 蜂鸣器的音量与驱动方波的占空比有关。通常情况下，方波的占空比为 50%（即高电平和低电平均分时间）。但如果你改变占空比，比如让高电平的时间更短，则音量会下降。



**调整高电平持续的时间，会不会影响一个周期T的时间，导致改变了音阶？**

你提到的关键点非常重要：**调整高电平持续时间是否影响周期 T**。在简单的实现中，确实需要小心避免这种情况。

在生成音阶的方波时，周期 T 是由目标频率决定的。调整占空比（高电平持续时间）时，如果不小心改变了一个完整周期的时间，就会导致音高发生变化，这是我们不希望看到的。

如果目标是通过改变占空比来控制音量，则需要调整 ThighT_{high} 和 TlowT_{low}，但确保它们之和始终等于一个周期 T。



**但是需要在T/2处实现高低电平反转才能产生方波啊？**

你说得很对！要产生标准的方波，必须在周期 T 的 **T/2** 处进行高低电平反转。如果在控制音量时只调整占空比，不严格按照 T/2T 切换高低电平，就可能导致方波的频率发生变化，进而影响音阶。

正确的音量控制方法与方波生成

要同时实现**音阶精确**和**音量控制**，可以采用以下方法：

1. **分离音频方波与音量控制**

为了确保音高不变，可以通过以下方式实现：

- **音频信号（固定方波）**：严格在 T/2T/2T/2 处切换高低电平。
- **音量控制（模拟 PWM 调节）**：**用另一个定时器**或逻辑控制占空比，控制高低电平持续的时间，但不改变基础方波的频率。

方法一：定时器嵌套

1. **定时器 1**：用于产生基础方波，确保在 T/2切换。
2. **定时器 0**：用于调节占空比（音量控制）。

```c
#include <reg52.h>

sbit Buzzer = P2^0;  // 蜂鸣器连接到 P2.0

unsigned int halfPeriod = 0;  // T/2
unsigned char dutyCycle = 50;  // 占空比 (0-100)

void Timer0_ISR(void) interrupt 1  // 控制占空比
{
    static unsigned char counter = 0;

    counter++;
    if (counter < dutyCycle)
        Buzzer = 1;  // 持续高电平
    else
        Buzzer = 0;  // 持续低电平

    if (counter >= 100)
        counter = 0;
}

void Timer1_ISR(void) interrupt 3  // 控制基础方波
{
    TH1 = (65536 - halfPeriod) >> 8;
    TL1 = (65536 - halfPeriod) & 0xFF;

    Buzzer = ~Buzzer;  // 每 T/2 翻转一次
}

void main()
{
    TMOD = 0x11;  // 定时器 0 和 1 都用模式 1
    EA = 1;       // 开总中断
    ET0 = 1;      // 启用定时器 0 中断
    ET1 = 1;      // 启用定时器 1 中断

    TR0 = 1;      // 启动定时器 0
    TR1 = 1;      // 启动定时器 1

    halfPeriod = 500;  // 假设 1kHz 方波，半周期 500us

    while(1)
    {
        // 主循环可动态调整 dutyCycle 控制音量
        // dutyCycle = 30; // 改变占空比，降低音量
    }
}
```



**我的开发板有三个定时器，但是原理还没懂，什么叫一个产生音阶，一个调整音量？ 改变的不是同一个方波吗？**

1.**方波的两个维度：音阶和音量**

蜂鸣器发声是通过驱动**方波信号**实现的。这个方波具有两个核心属性：

- **音阶（频率）**：方波的频率决定音高（即音阶）。频率越高，音高越高。
- **音量**：音量与方波的**幅值（信号强度）和占空比**有关，简单地说，占空比决定了声音的响度。

2.**音阶与音量的独立性**

**音阶（频率）** 和 **音量（幅值/占空比）** 是可以独立控制的。

理解这个独立性：

- **音阶控制：**
  方波的周期 T 决定频率 f=1/T​。要保持特定的音高，你需要确保方波每个周期内在**固定的 T/2 处反转高低电平**。
- **音量控制：**
  音量是基于**方波高电平持续的比例（占空比）**来实现的。通过改变占空比，可以调整蜂鸣器“响”的时间比例，从而模拟音量的增减。**但这一操作不应该影响方波的频率（即音高）。**

3.**两个定时器的角色划分**

如果**用一个定时器同时控制音高和音量，就容易导致问题**：
改变占空比的同时，可能会改变方波的周期，导致音阶发生偏移。因此，分开处理音阶和音量是更理想的做法。

**第一个定时器：控制方波的频率（音阶）**

确保在周期 T 的中点 T/2 处切换电平，以生成准确的方波频率。

**第二个定时器：控制音量（占空比）**

在生成的方波基础上，通过控制每个周期内方波的高电平持续时间，改变占空比，进而控制蜂鸣器的音量。

4.**原理解释**

假设我们用两个定时器来实现：

1. **定时器 1** 负责音阶：
   这个定时器负责严格按照 T/2T/2T/2 切换高低电平，以保证方波的频率正确，从而发出准确的音高。
2. **定时器 0** 负责音量：
   这个定时器基于 PWM 原理，将蜂鸣器的方波信号“调制”。通过在某些周期内只输出低电平，或部分时间输出高电平，达到音量调节的目的。

**定时器 1：生成方波，控制音高**

负责音阶生成，每 T/2T/2T/2 反转一次电平，频率保持不变：

```c
void Timer1_ISR(void) interrupt 3
{
    TH1 = (65536 - halfPeriod) >> 8;
    TL1 = (65536 - halfPeriod) & 0xFF;
    Buzzer = ~Buzzer;  // 高低电平反转，生成方波
}
```

**定时器 0：控制占空比，调节音量**

通过 PWM 的方式，在方波基础上动态调整占空比：

```c
void Timer0_ISR(void) interrupt 1
{
    static unsigned char counter = 0;

    counter++;
    if (counter < dutyCycle)  // dutyCycle 决定高电平持续时间
        Buzzer = 1;
    else
        Buzzer = 0;

    if (counter >= 100)
        counter = 0;
}
```

**两者结合的效果**

- **定时器 1** 确保生成固定频率的方波，不改变音高。
- **定时器 0** 在此基础上，通过控制方波的高低电平比例，调整占空比，从而调节音量。

**关键点总结**

- **音阶控制：** 确保方波的周期 T 恒定。
- **音量控制：** 在不改变周期 T 的前提下，动态调整高低电平时间比例（占空比）。



**有没有形象的类比？ 使用一个定时器严格在T/2处翻转电平产生方波。 根据T的不同这就已经产生声音和音阶了啊？ 你的意思是产生方波之后，再单独使用另一个定时器把调整高电平的持续时间并保持总T时间不变，就可以控制音量了？ 如果使用只使用一个定时器的话，不可能产生方波的同时又调整高电平的持续时间的？**

类比：**敲钟和遮盖**：

想象你在一座寺庙里敲钟，钟的音高和响度的控制就像我们用蜂鸣器产生声音的过程。

1. **敲钟的频率（音阶）**

你每隔固定时间（例如 1 秒）敲一次钟，钟声的**频率**就取决于你敲钟的速度。这个频率对应于声音的**音高**（音阶）。

- **方波的周期 TTT** 类似于你敲钟的间隔时间。
- **周期 T/2T/2T/2** 则是敲钟动作的一半时间，敲下去发出声音，放开回弹静音，形成高低电平的交替。

只要你严格按照固定的时间间隔敲钟，就能产生稳定的音高。



2. **遮盖钟声（音量控制）**,方波已经在T/2严格翻转，且T没变，这时再改变高电平持续时间是没有问题的？

**在使用第二个定时器调整高电平持续时间时，只要总的周期 T 保持不变，就不会影响音高（音阶）。这正是实现音量控制的关键。**

但有时候，钟声可能太响，需要让它听起来更柔和。怎么办？
假设你**在敲钟之后，用一块布盖住钟的一部分时间，这样即使敲钟的频率不变，钟声传出来的响度也会减弱。**

- 这块布就像我们用**另一个定时器**来调整音量。
- 你可以在一部分时间里完全遮盖钟声（低电平），另一部分时间里让钟声正常发出（高电平）。
- 遮盖时间的比例（占空比）决定了钟声有多响，这对应音量的调节。

重要的是：**敲钟的频率不变，钟的音高不会因此改变。**

**核心对比**

- **定时器 1（敲钟频率）**：严格在 T/2T/2T/2 处翻转电平，确保方波周期 TTT 不变，音阶固定。
- **定时器 0（布的遮盖）**：调整高电平持续的时间比例，控制音量。

这两个动作是**相互独立**的，一个负责音高，另一个负责音量。





**为什么只用一个定时器不行？**

如果你只用一个定时器同时控制音阶和音量，问题在于：

1. 你需要让定时器在**T/2T/2T/2 处精确翻转电平**来保证音高。
2. 同时还需要动态调整高电平的持续时间来控制音量。

这两个需求是矛盾的：

- **要保证音高**，周期 TTT 和 T/2T/2T/2 必须固定。
- **要控制音量**，高电平的时间要变长或变短。

如果只用一个定时器来同时满足这两点，就无法保证**音阶频率**和**占空比**独立调节。这会导致音高和音量的混乱：一旦调整占空比，方波的周期也会改变，从而改变音高。



##### 方波信号原理示意图

![image-20241114145410369](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241114145410369.png)

这个图展示了：

1. 两种频率的方波：
   - 红色：高频方波（如高音Do），周期短，频率高
   - 青色：低频方波（如低音Do），周期长，频率低
2. 关键参数：
   - T：一个完整的周期
   - T/2：半周期，在这个点翻转电平
   - 高电平和低电平：蜂鸣器的开关状态
3. 频率与音高的关系：
   - 频率越高（周期越短），音调越高
   - 频率越低（周期越长），音调越低
4. 计算方法：
   - 周期T = 1/频率
   - 翻转时间点 = T/2
   - 例如：中音A(440Hz)
     - T = 1/440 ≈ 0.002273秒 = 2273微秒
     - 翻转点 = 2273/2 ≈ 1136.5微秒

通过定时器精确控制这个翻转时间点，就能产生稳定的音调。不同的翻转频率会产生不同的音调，从而实现音乐旋律的播放。

需要注意的是，实际中要考虑：

1. 定时器的精度
2. 中断处理的时间延迟
3. 其他任务对时序的影响

这些都会影响到音调的准确性。因此使用硬件定时器而不是软件延时是很重要的。

**产生音阶以后，是通过延迟时间来产生节奏吗？ 还是不断产生相同音阶（比如高音Do一秒）来产生节奏？**

是通过**持续产生相同音阶来实现节奏**的。我来画个示意图说明：

![image-20241114145928284](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241114145928284.png)

这个图展示了节奏的实现原理：

1. 持续产生方波:

   - 高音Do：持续产生高频方波500ms
   - 中音Sol：持续产生中频方波1000ms
   - 低音Re：持续产生低频方波250ms

2. **实现方式**:

   1. ```c
      void Timer0_ISR() interrupt 1 {
          static u16 count = 0;
          static bit toggle = 0;
          
          if(is_playing && SONG[current_note].tone != 255) {
              count++;
              // 产生特定频率的方波
              if(count >= TONE_TABLE[SONG[current_note].tone]) {
                  count = 0;
                  toggle = !toggle;
                  BEEP = toggle;
                  note_duration--;    // 控制持续时间
              }
              
              // 当前音符播放完毕，切换到下一个音符
              if(note_duration == 0) {
                  current_note++;
                  note_duration = SONG[current_note].rhythm;
              }
          }
      }
      ```

3. **关键点**:

   - 不是用延时来产生节奏
   - 而是通过计数器控制每个音符的持续时间(**通过定时器来实现**)
   - 在持续时间内不断产生对应频率的方波
   - 时间到后立即切换到下一个音符的频率

4. **这样设计的优点：**

   1. 声音连续，没有断续
   2. 可以精确控制节奏
   3. 不会阻塞程序执行
   4. 可以实现复杂的音乐效果



**通过计数器控制每个音符的持续时间？ 会不会有误差？为什么不通过定时器呢？**

实际上我们是通过定时器来实现的！让我详细解释一下：

![image-20241114150525398](C:\Users\admin\Desktop\个人博客\嵌入式相关博客\51单片机学习\51单片机.assets\image-20241114150525398.png)

实际工作原理是这样的：

1. **定时器设置**:

```c
void Timer0_Init() {
    TMOD &= 0xF0;
    TMOD |= 0x01;    // 16位定时器模式
    TH0 = 0xFC;      // 设置定时初值
    TL0 = 0x18;      // 定时1ms
    ET0 = 1;         // 开启定时器中断
    EA = 1;          // 开启总中断
    TR0 = 1;         // 启动定时器
}
```

2.**定时器中断处理**:

```c
void Timer0_ISR() interrupt 1 {
    static u16 tone_count = 0;  // 音调计数器
    
    // 音调控制（产生方波）
    if(is_playing && SONG[current_note].tone != 255) {
        tone_count++;
        if(tone_count >= TONE_TABLE[SONG[current_note].tone]) {
            tone_count = 0;
            BEEP = !BEEP;  // 翻转电平
        }
        
        // 持续时间控制
        note_duration--;   // 每1ms递减一次
        if(note_duration == 0) {  // 音符播放完毕
            current_note++;  // 切换到下一个音符
            if(SONG[current_note].tone != 255) {
                note_duration = SONG[current_note].rhythm;
            }
        }
    }
}
```

3. **精确时序控制**:

   - 定时器每1ms触发一次中断

   - `note_duration` 以毫秒为单位

   - 如果要播放500ms的音符，就将 `note_duration` 设为500

   - 每次中断递减一次，到0时切换音符

4. **为什么这样更准确**:

   - 使用硬件定时器保证精确的1ms基准时间
   - 不依赖CPU指令执行时间
   - 不受其他任务影响
   - 可以同时处理音调和节奏

5. **时序示意**:

```c
1ms    1ms    1ms    1ms    1ms
 ↓      ↓      ↓      ↓      ↓
[定时器中断]→[定时器中断]→[定时器中断]→...
    ↓          ↓          ↓
递减计数    递减计数    递减计数
检查是否为0  检查是否为0  检查是否为0
```

这样设计的优点：

1. 时序精确，误差极小（依赖于晶振精度）
2. CPU负担小
3. 可以同时处理多个定时任务
4. 代码结构清晰

所以总的来说，我们是用定时器来实现精确的节奏控制的，而不是简单的计数器。这确保了音乐播放的时序准确性。
