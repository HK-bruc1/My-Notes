# 智能锁项目相关面试

## 项目怎么做的

- **项目功能**
- **项目流程**
- **项目架构**
  - **状态机扫描**

**项目功能：**

项目是**标准库函数开发的**一个日常居家使用的智能文件柜，主要包括**密码，指纹，射频卡和远程APP**四种开锁方式。

结合一块**LCD彩色屏**和**语音模块**做了**管理员的人机交互界面**，实现了对密码，指纹，射频卡的具体管理以及屏幕亮度和语音模块的音量设置。



**项目大体框架**：

就是在主函数中的while(1)中实现**四种开锁方式的轮询**以及利用**状态机扫描**根据**BS8116的按键扫描值**进入各个页面以及子级页面。



**项目流程：**

就是搭建了项目的大致框架之后，利用LCD屏幕将各页面呈现出来后，根据具体页面的需求实现各个功能后放到框架中进行单元测试。

- 比如主界面的显示包括密码，指纹的图案以及**RTC**时间。

- 比如密码的修改，指纹和射频卡的注册，删除，识别功能。



### 密码开锁是怎么实现的？

开锁动作是异步的，不知道什么时候会开锁。所以密码开锁功能放在了**主循环中**的**默认主界面**里高速轮询，以便可以及时响应。

默认上电后是，主页面中的四种开锁方式是被高速轮询的。但是首次进入主界面，密码开锁函数会去AT24C04中指定位置读取一个字节数据来判断是否是第一次开机。

- 如果是第一次开机的话，会进入设置系统密码逻辑，经过两次密码检查后，开机标志位和用户密码存回到AT24C04中。并返回主界面
  - 密码不一致会重新进入该页面，因为开机标志位没有修改依旧进入设置系统密码逻辑

- 如果不是第一次开机的话，就是正常的开锁方式轮询，输入密码后会从AT24C04中提取密码对比
  - 一致就会修改页面状态从而进入到管理员的界面（只有密码开锁才会进入）
  - 不一致的话语音模块会提示，然后清空输入缓存（输入次数置0）重新载入该页面重复该操作。


### 密码管理的方案是什么？怎么实现的？

因为按键值有很多个界面都要使用，所以通过参数的形式将按键扫描的值传递到每个正在使用的页面。

通过密码解锁会进入管理员界面，通过按键值修改页面状态进入密码管理界面。

密码管理页面就直接进入到修改密码逻辑了，修改后的密码会回存到AT24C04中。

### 指纹开锁是怎么实现的？

开锁动作是异步的，不知道什么时候会开锁。指纹开锁函数是在主循环中的默认页面里高速轮询的。但是要在系统设置管理密码后，才会高速轮询。手指按下后感应上电引脚会输出高电平，MCU通过这个信号退出低功耗模式。开始采集指纹特征并进行对比，使用串口的接收中断和空闲中断进行数据的接收以及判断数据传输是否完成，根据标志位解析MG200回传的数据包，通过数据包返回的状态值进行指纹开锁。

#### MG200模块

指纹开锁依赖于MG200电容式指纹传感器模块实现。模块集成了指纹的采集、注册、比对、储存、删除等功能，最多可以存储100个指纹信息，它通过TTL电平的RS232接口与单片机通信（**手册说明了使用串口为 3.3V 的 TTL 电平通信，还规定了串口配置**）。

有四个比较重要的引脚：

1. 串口通信的接收和发送引脚
2. 感应上电信号引脚（**手指触摸指纹传感器时输出高电平**）
3. 程序控制的高低功耗引脚（**进入低功耗模式，整个模块只有感应上电信号工作**）。

##### 通信协议的配置

- 串口的两个引脚配置为复用模式
- 感应上电引脚配置通用输入
- 高低功耗引脚配置推挽输出
- 串口数据的接收开启接收中断和空闲中断
  - 每一次接收中断触发后清除标志位，取出数据寄存器中的值，缓冲区移动一个位置
  - 等到空闲中断触发时，一次数据传输就完成了

##### 针对通信协议封装了什么函数

1. 原来的标准库函数中，只有**发送一个字节函数**，没有等待发送寄存器为空的操作，所以为了实现多字节发送时数据覆盖，二次封装了一个发送一个字节函数
   1. 等待发送寄存器为空时，再发送

2. 利用封装的发送一个字节函数再次封装了发送多字节函数。

##### 针对MG200封装了什么函数

**只针对MG200模块，综合的逻辑在对应的界面函数中，包括注册指纹的双端存储，指纹的双端删除等**

1. 发送指令函数
   1. 有固定的数据包格式
   2. 发送7个字节数据，其中前三个是固定的，后四个分别包含：指令码，指令码所带的参数以及校验和

2. 在发送指令函数的基础上对mg200各功能做了封装
   1. 比如抓取指纹，删除指纹，对比指纹等等。
3. 解析mg200返回的数据包函数
   1. 死等MG200回传数据包
   2. 然后按照固定的格式进行解析，获取操作指令的结果
      1. 比如指纹采集成功，指纹删除成功等

4. 指纹模块的注册函数
   1. 当手指触摸到指纹模块时，感应上电引脚会输出高电平，然后模块退出低功耗模式，并发送采集指纹指令
   2. 使用了一个累加变量，完成三次指纹的采集
   3. 这里使用定时中断事件设计了一个超时检测，如果超过5秒就会开始指纹的注册
   4. 抓取指纹成功之后，发送注册指令，解析对应的数据包后，判断是否注册成功


**BUG:**

MG200在上电后，回偷发数据，导致串口接收完成标志位提前置位，从而导致MG200回传数据包解析错误。

这里发送指令后，会将接收完成标志位重新清除，MG200回传数据包后，触发空闲中断后重新置位接收完成标志位。

#### RS232通信

**产品使用RS232通信协议，通过TTL电平转换芯片，输出都是TTL电平（比如0和3.3V）与外部通信。 也就是说外部需要能识别TTL电平，同时遵守RS232协议才能与产品通信。 而MCU的串口控制器可以识别TTL电平，通过配置可以实现RS232协议与产品通信。 简单来说就是RS232通信本质上还是串口通信，MCU使用串口配置即可**

- 产品内部使用了 **RS232 通信协议** 来组织数据。

- 通过 **TTL 电平转换芯片**，将标准的 RS232 电平转换为了 **TTL 电平**（例如 0V 和 3.3V）。

- 因此，产品对外通信的信号是 **TTL 电平** 的。

- 外部设备（例如 MCU）需要能够识别 **TTL 电平** 的信号，并且按照 **RS232 通信协议** 的规则（例如波特率、数据位、校验位等）进行通信，才能与该产品正常交互。

- **MCU 的串口控制器** 本身就可以识别 TTL 电平。通过软件配置 MCU 串口的参数，使其符合 RS232 通信协议的要求，MCU 就可以与该产品进行通信。

- **本质上来说，在这种情况下，RS232 通信是通过 MCU 的串口功能实现的，只需要正确配置串口参数即可。**

### 指纹管理的方案是什么？怎么实现的？

- 注册
- 识别指纹对应ID删除
  - 本质上还是识别出指纹对应的ID
  - 根据ID来删除
- 根据按键值选择ID进行删除
- 删除所有用户



1. 首先维护一个保存所有指纹ID用户的全局数组，在此基础上实现指纹的管理。

2. 注册就是向MG200发送注册指令，解析返回的数据包后根据注册状态决定用户重新注册还是注册成功在LCD上显示对应ID。**注册成功后，会同步到AT24C02中**。
3. 识别指纹删除ID本质上还是根据ID去删除用户指纹
   1. 先采集用户指纹，MG200会对比自己保存的指纹中是否有该指纹，有就会返回对应ID，没有语音会提示用户。
   2. 最后用户按下确认键在统一gm200与本地同步删除。

#### AT24C02怎么做的

**用什么通信，针对通信封装了什么函数？**

使用软件IIC通信，封装了基本的时序函数：

- 起始信号，停止信号，发送ACK应答和NO_ACK不应答，检测ACK和NO_ACK
- 发送一个字节函数，接收一个字节函数



**针对AT24C02封装了哪一些函数？**

- 某个地址空间写入一个字节数据
- 某个地址空间读取一个字节数据
- 某个地址空间读取多个字节数据
  - 地址会自动递增，无上限

- 页写功能函数
  - 只能页内地址自增。

- 利用页写封装的连续跨页写函数
  - 先判断是否跨页，不跨页的话，直接调用页写函数。
  - 如果跨页的话，先把本页写完，手动翻页后继续页写。

#### AT24C02的内部结构是怎么组织的？

比如容量是256个字节的话，内部地址为0~255。可以指定某一个地址读取或者写入。

连续读取的话，地址会自动递增，只需要指定地址和读取个数即可。

但是连续写的话，他是按页来组织的，连续写都在一个页之内的话，地址也可以自动递增。但是跨页不行，自己实现跨页写函数。

#### IIC通信介绍

**介绍IIC通信？**

- 相对于串口通信来说的话，他是同步串行半双工通信协议，可以实现一主多从通信。

- **双线制:** 只需要两条线进行通信：

  - **SDA (Serial Data):** 用于传输数据。

  - **SCL (Serial Clock):** 用于同步数据传输。

- **寻址机制:** 每个连接到 IIC 总线上的设备都有一个唯一的地址，主设备通过地址来选择与之通信的从设备。
- **支持应答机制:** 每一个字节传输后，接收方会发送一个应答信号来告知发送方数据是否成功接收。
  - 比如发送从机地址
  - 传输一个字节数据




**数据帧格式？**

IIC 的数据传输是以**字节**为单位进行的，每个字节后会跟一个应答位。

一般数据帧结构：

- 起始信号
- 从机设备地址
  - 地址最后一位的0和1表示主机是要读还是写操作
- 检测从机发过来的ACK
  - 发送完地址和读/写位后，主设备释放 SDA 线，由从设备拉低 SDA 线表示应答 (ACK)。如果从设备没有应答（例如，地址不存在），则 SDA 线会保持高电平（Not Acknowledge - NACK）。
- 数据部分
  - 在应答位之后，开始传输实际的数据字节。数据传输总是以 8 位（一个字节）为单位。
- 应答ACK
  - 每个数据字节传输完毕后，接收方（主设备或从设备）都需要发送一个应答位给发送方。
- 传输完成后，发送停止信号。



**通信过程？**

主设备向从设备写数据：

1. 主设备发送**起始位**。
2. 主设备发送**从设备地址（7位或10位）和写位 (0)**。
3. 主设备**接收来自从设备的应答位 (ACK)。**
4. 主设备发送要**写入的数据字节**。
5. 主设备**接收来自从设备的应答位 (ACK)。**
6. **重复步骤 4 和 5，直到所有数据发送完毕。**
7. 主设备**发送停止位**。

主设备从从设备读数据：

1. 主设备发送起始位。
2. 主设备发送从设备地址和读位 (1)。
3. 主设备接收来自从设备的应答位 (ACK)。
4. 从设备开始发送数据字节。
   1. 主设备会释放SDA线，高阻态

5. 主设备接收到每个数据字节后，发送应答位 (ACK) 给从设备，表示继续接收。
6. 当主设备不需要更多数据时，发送非应答位 (NACK) 给从设备。
7. 主设备发送停止位。



**IIC主机是如何接收（感知）从机数据的？**

三种通信协议是如何接收数据的：

**串口的接收方式主要有两种：**

- **轮询 (Polling):** 主机不断检查接收数据寄存器中是否有新的数据到达。这种方式比较简单，但会消耗主机的处理器资源，因为需要不断地检查。
- **中断 (Interrupt):** 当有新的数据到达时，接收硬件会发出一个中断信号给主机。主机接收到中断后，才会去读取数据。这种方式更有效率，因为主机在没有数据到达时可以执行其他任务。

**SPI**

SPI 是全双工的，数据的发送和接收都是由主机完全掌控。在 SPI 通信中，接收数据通常发生在主机发送数据的同时。当主机通过 MOSI (Master Out Slave In) 线发送一个位的数据给从机时，从机也会同时通过 MISO (Master In Slave Out) 线将一个位的数据发送给主机。因此，主机在发起传输的同时，也就接收来自从机的数据。

**I²C**

关于 I²C，您的疑问在于主机如何感知从机想要发送数据。与 SPI 不同，**I²C 并没有一个专门的信号线让从机主动通知主机。**在标准的 I²C 通信中，**数据的传输总是 Master 发起的**。

以下是主机从 I²C 从机接收数据的典型流程：

1. **Master 发送起始 (START) 信号：** Master 会在 SDA (Serial Data Line) 线上产生一个由高电平到低电平的跳变，同时 SCL (Serial Clock Line) 维持在高电平。这个信号通知所有连接在 I²C 总线上的从机，通信即将开始。

2. **Master 发送从机地址 (Slave Address) 和读取位：** Master 会紧接着起始信号发送 7 位或 10 位的从机地址，并在最后一个位设置为“读取”位 (通常是逻辑 1)。

3. **从机响应 (Acknowledge, ACK)：** 被寻址到的从机在接收到正确的地址和读取位后，会在下一个时钟周期将 SDA 线拉低，发送一个 ACK 信号给 Master。如果没有从机响应，Master 会知道没有对应的从机存在。

4. **Master 产生时钟并接收数据：** Master 开始产生时钟信号。在每个时钟周期中，被寻址到的从机会将一个位的数据放到 SDA 线上。Master 在 SCL 为高电平时读取 SDA 线上的数据。

5. **从机传送数据字节 (Byte)：** 这个过程会重复进行，**从机每次传送一个字节 (8 个位) 的数据。**

6. Master 发送应答 (ACK) 或非应答 (Not Acknowledge, NACK)：

    在接收到每个字节的数据后，Master 可以选择发送 ACK 或 NACK。

   - **ACK:** 表示 Master 希望继续接收下一个字节的数据。Master 会在下一个时钟周期将 SDA 线拉低。
   - **NACK:** 表示 Master 不再需要接收更多数据。Master 会在下一个时钟周期将 SDA 线保持在高电平。

7. **Master 发送停止 (STOP) 信号：** 当 Master 完成数据接收后，会在 SCL 维持在高电平时，在 SDA 线上产生一个由低电平到高电平的跳变。这个信号通知所有从机，本次通信结束。

在 I²C 中，**Master 总是主动发起读取操作**。Master 并不会等待从机主动告知要发送数据。如果 Master 需要从某个从机获取数据，**它必须主动发送包含该从机地址和读取指令的消息来启动数据传输。**

**总结**

- **主机主动发起：** I²C 主机接收数据是由主机主动启动数据传输过程的。

- **发送起始信号和地址：** 主机首先发送起始信号，然后发送目标从机的地址以及读取位。

- **等待从机 ACK：** 主机需要等待从机发送应答信号 (ACK) 来确认从机已收到地址并准备好发送数据。

- **释放 SDA 并读取数据：** 收到 ACK 后，主机释放 SDA 线，并开始在 SCL 线的每个高电平期间读取 SDA 线上的电平信号，从而接收从机发送的数据位。

- **字节传输和 ACK/NACK：** 每成功接收一个字节的数据后，主机需要发送一个应答 (ACK) 或非应答 (NACK) 信号给从机。

  - 发送 ACK 表示主机希望继续接收下一个字节的数据。

  - 发送 NACK 表示主机不再需要接收更多数据。

- **发送停止信号：** 当主机完成数据接收（通常是在发送 NACK 后）时，会发送停止信号来结束本次 I²C 通信。



**异步通信与同步通信的区别**

**异步通信 (如 UART):** 的确因为不知道数据何时到达，所以需要通过轮询接收数据寄存器的状态或者开启接收中断来实时监测是否有数据到达。这种方式的特点是通信双方不需要共享同一个时钟信号，而是通过起始位、数据位、校验位和停止位等约定好的格式来同步每个字节的数据传输。

**同步通信 (如 I²C 和 SPI):** 的核心特点就是**通信双方共享一个时钟信号**，通常由主机提供。数据在时钟信号的特定时序（例如上升沿或下降沿）被发送和接收。

- **I²C:** 正如您所说，无论是读操作还是写操作，数据的传输都是在 SCL 线的特定时机完成的。主机通过控制 SCL 的时钟频率和时序来同步数据的传输。
- **SPI:** SPI 的全双工特性也依赖于时钟信号的同步。在主机提供的时钟信号的驱动下，主机在发送数据的同时，从机也在同步地发送数据。



### 射频卡开锁是怎么实现的？

使用的是RFID射频识别，读写器的型号是RC522和s50型号的卡片实现。对应的开锁函数是写在默认主界面中轮询的。

开锁校验是卡片注册id和卡内指定扇区数据组成。当卡片靠近时，会读取到卡片序列号和对应扇区数据。程序会检查卡片序列号对应的ID是否注册过，注册过再核对固定的扇区密码后核查扇区数据是否对应实现开锁。

#### RC522读写器和S50卡片

使用软件模拟SPI协议进行通信，比较重要的引脚：

- SPI通信相关引脚：
  - MOSI (Master Out Slave In) - 主设备数据输出，从设备数据输入
  - MISO (Master In Slave Out) - 主设备数据输入，从设备数据输出
  - SCK (Serial Clock) - SPI时钟信号
  - SDA/SS/NSS (Slave Select) - 片选信号，用于选择与哪个从设备通信
- 控制引脚：
  - RST - 复位引脚

#### 针对通信协议封住了什么函数

- SPI通信引脚初始化
  - CS--推挽输出
  - SCL--推挽输出
  - MOSI--推挽输出
  - RST--推挽输出
  - MISO--浮空输入

- 封装了收发一体一个字节函数，时钟极性和相位是11模式
  - 空闲时钟为高
  - 数据在第二个跳变沿被采集
  - 循环的发送每一位
  - 使用位运算给新的接收一位数据腾出位置。
  - 每次都发最高位

#### 针对RC522封装了什么函数？

- 从MFRC522的某一寄存器读一个字节数据
- 向MFRC522的某一寄存器写一个字节数据
- 复位RC522
- RC522芯片内部包含了大约40多个寄存器，配置比较繁琐，所以都是移植的
  - 开启天线，寻卡，读取选中卡片的卡序列号等等

#### **S50卡片的内部构造？**

卡片总容量为1KB(1024字节)，这些存储空间被组织为16个扇区(Sector)，每个扇区包含4个块(Block)，每个块有16字节(16 Bytes)。

扇区和块的具体结构如下:

1. 扇区结构:
   - 每个扇区由4个块组成(编号为0-3)
   - 每个扇区的第4个块(即块3)为扇区尾块，**存储密钥和访问控制位**
   - 扇区0的块0包含卡片制造商信息，通常是只读的
2. **特殊块**:
   - 扇区0的块0(绝对块地址0)包含:
     - UID(唯一识别码)，通常4字节
     - 制造商数据
     - 校验信息
   - 每个扇区的块3包含:
     - 密钥A(6字节)
     - 访问控制位(4字节)
     - 密钥B(6字节)

**RC522访问S50卡片时，需要校验扇区密码，校验成功后才能对扇区进行读取操作。**

### 射频卡的管理方案是什么？怎么实现的？

全局维护一个已注册卡片用户的二维数组u8 picc[9] [4];，维护最多9个用户id,以及每个id下4个字节的卡片序列号。

- **卡片的注册**

进入对应的注册界面后，程序会先从AT24C02中去读一个已注册卡片用户的二维数组。然后遍历二维数组拿到已注册个数，达到9个就语音播报，无法注册。

卡片靠近时，拿到卡片序列号，然后遍历二维数组，检查此二维数组是否注册过这个卡片，如果有则语音播报注册重复。如果没有，则在遍历二维数组拿到空闲的可用ID写入，然后再存入将整个二维数据存回AT24C02，完成注册。

- **指定id卡片删除**

通过按键扫描传入的参数值，去二维数组把对应用户id下的序列号全部覆盖0xff,用作删除标记。然后存回AT24C02，重新载入该页面。

- **识别卡片id后统一删除**

使用一个临时数组保存已经识别到的卡片ID，等用户按下确认时，根据临时数组去二维数组对应位置写0xff，然后回存到AT24C04即可。

- **删除所有卡片**

把整个二维数组全部写入0xff，存回at24c04中。



### APP开锁是怎么实现的？

这里利用ESP32充当WiFi模块，刷入AT固件使用MQTT协议与云端通信，实现开锁指令的下发。

单片机使用串口与ESP32通信，使用串口中断接收数据，并解析数据实现开锁操作。

云平台提供了APP的实现，通过配置，可以使APP下发指令。

#### MQTT协议

MQTT是一种轻量级的发布/订阅消息传输协议，云平台集成了MQTT协议，只要使用ESP32的AT指令订阅对应格式，就可以收到来自云平台下发的数据。同时还可以上报数据。开门后延迟一段时间会自动关门，这里为了同步云平台的数据，上报了一次关门数据。

**服务质量(QoS)**：

- QoS 0：最多发送一次，不保证送达
- QoS 1：至少发送一次，可能重复
- QoS 2：**恰好发送一次，保证送达且不重复**

#### ESP32的使用

ESP32作为WiFi和MQTT的客户端使用。刷入AT固件通过串口就可以实现通信。

参照ESP32官方网站的示例写的

**封装了什么函数**：

- 利用串口的接收中断和空闲中断接收数据

- ESP32 发送指令并判断是否接收到期望的回应信号
  - 操作成功会响应OK
  - 利用定时中断实现了超时等待
- 切换模式
  - 数据传输模式还是设置模式
    - WiFi设置，重连设置，MQTT的订阅设置，重连设置
- ESP32初始化配置函数
  - 串口初始化
  - WiFi设置相关
  - WiFi重连设置
  - TCP相关初始配置
  - 设置ESP32为客户端模式
- 上报关门数据
- 解析ESP32回传数据包函数
  - 回传的数据格式是固定的格式
  - 解析字符串就可以了
  - 开门指令解析
  - WiFi状态检查解析
  - MQTT状态检查逻辑
  - 解析ESP32回传的时间数据
- 设置ESP32的WiFi时间
  - 连接SNTP服务器获取网络时间到ESP32的RTC中
  - 设置一下SNTP时间同步的间隔，一个小时同步到ESP32的RTC一次

### 语音模块怎么实现的

是思泽公司的语音模块，里面内置了40段固定的音频，每个音频都有固定的命令参数，要通过他给的通信协议，将命令参数通过IO模拟的形式发送过去，模块识别到命令参数，就会根据命令参数进行对应的语音播报。

通过IO口输出不同的固定时间的电平信号就可以代表0和1。就两个引脚，一个是表示引脚是否处于繁忙状态的，另一个就相当于数据线。



### LCD彩色屏是怎么实现的？

- 显示原理

- 使用什么协议通信？

- 封装了什么函数？

- 显示字符，汉字，图片
- 字库方案
- 图片上显示字符，汉字

#### 基本信息

比较重要的引脚：

- SPI的四根线
- RES复位引脚
- 背光灯引脚
- DC命令还是数据选择线

#### 彩色原理

每一个像素点是RGB三原色混合而成，所以可以显示各种颜色。

RGB又分为了：

- RGB565
  - 各原色使用几位二进制表示
  - R使用5位，G使用6位，B使用5位
  - 总计两个字节，可以表示一个像素点颜色信息。
  - 每一个像素点使用16位标识颜色，也就是说可以表示65536种颜色。
- RGB666
- RGB888

#### 实验

中英文字符，数字，图片显示在LCD显示屏上。

- 字符与汉字取模出来的是该点是否需要打点（是否需要填充颜色）。

- 图片取模出来就是可以直接传递进入的颜色值。

##### 程序设计

软件模拟SPI：

- SPI软件相关引脚初始化
- 封装了一个字节收发一体函数

LCD屏幕的相关程序：

- LCD屏幕所用到的IO口初始化程序
- 复位程序
- 发送命令函数
- 发送命令参数函数
  - 主要是标准例程是分开封装的，所以这里也是分开封装。
- 发送数据函数
- LCD屏幕初始化程序
  - spi初始化程序
  - LCD屏幕所用到的IO口初始化程序
  - 复位程序
  - LCD屏幕标准参数设置驱动程序移植
  - 开背关灯
    - 使用PWM控制亮度。
- 清屏函数
  - 先确定填充颜色的区域大小，X方向的起始坐标和结束坐标，Y方向的起始坐标和结束坐标。
  - 发送设置颜色命令，每个像素点发送颜色值过去。
    - 16位二进制数据
  - 发送设置XY的起始和结束坐标位置，再发送命令参数（起始坐标和结束坐标）
- 局部填充某种颜色
  - 是自定义颜色
    - 直接传递颜色值
  - 是图片颜色
    - 找到对应像素点的图片颜色值（图片取模数组中偏移到对应的位置）
- 打点函数
  - 精确到一个像素点的颜色
  - 汉字与字符取模出来都是该点是否需要打点（填充颜色），其他不是目标点则利用打点函数填充背景色，从而显示出汉字或者字符来。

##### 显示字符

- 16x16像素大小的字符，实际占用像素为16x8,高不变，宽减半。
  - 高需要16行，宽只需要8列。
  - 那么一个字符的模数组元素就要16个u8元素。
    - 横向刷屏的话
  - 模数据数组是u8类型
- 计算目标字符与字符数组中第一个元素的偏移量
  - 根据偏移量就可以计算出目标字符在模数组中的起始位置
  - 取出16个元素来，调用打点函数，来决定该像素点是否需要打点（填充颜色），就可以显示出字符

##### 显示汉字

- 计算要显示的汉字与字库数组中的首个汉字的偏移个数
- 汉字占用两个字节，*`hz==table[2*n]  && *(hz+1)==table[2*n+1]`
  - 字库数组是一维字符数组，存的是字符串，拆开对比两个字节是否相等
- 拿到n就是偏移个数
- 如果大小为16，那么像素实际占用就是高为16，宽为16。就是说一个汉字占用模数组元素就要32个u8元素。
- 一行的需要两个字节元素，所以取出来的数据需要拼凑一下，拼凑为16位的数据
- 然后再逐个打点判断

##### 显示混合字符串

传入一个字符串，遍历字符串。逐个判断是字符还是汉字

- 字符和ASCII码要小于汉字的编码。
- 如果是字符，就调用显示字符函数
- 偏移字符串指针以及偏移Y轴位置
  - 汉字就偏移两个位置
  - Y轴的偏移根据大小来

##### 显示图片

根据屏幕的大小对图片进行取模，取模后的模数据就是像素点的颜色值，两个元素控制一个像素点的颜色值，所以需要拼凑一下，然后直接写入16位数据。



### RTC时间怎么做的？

- 网络时间的获取是通过ESP32的AT指令连接WiFi后再连接SNTP服务器实现时间的获取。
- 这个时间会先保存到ESP32的RTC中。那么stm32的RTC时间就是通过AT指令获取ESP32中的时间。利用定时中断实现时间的周期同步与校准。

#### RTC如何配置

在STM32中，**RTC (Real-Time Clock)** 是一个**专门用于精确跟踪时间的独立外设**。

**它不仅仅是一个普通的定时器，而是一个更高级、功能更完善的计时系统，可以实现以下功能：**

- **专门用来计时的：** 这是RTC最基本的功能。它可以精确地记录当前的时间，包括时、分、秒。
- **充当万年历的：** 是的，RTC通常可以跟踪日期，包括年、月、日，甚至星期几。这意味着它可以像一个万年历一样工作，自动处理闰年等复杂情况。

**与普通的定时器相比，STM32的RTC具有以下关键特性，使其非常适合时间相关的应用：**

- **独立时钟源：** RTC通常拥有独立的低速时钟源，例如32.768 kHz的晶振。这个独立的时钟源即使在主系统时钟停止或切换时也能继续运行，保证了时间的持续性。这对于需要在低功耗模式下保持时间的应用非常重要。
- **低功耗设计：** RTC通常被设计成低功耗模块，即使在主电源断开的情况下，也可以通过备用电池或电容供电继续运行，保持时间的准确性。
- **备份域：** STM32的RTC通常位于备份域中。备份域是一块独立的存储区域，即使在系统复位或主电源掉电的情况下，其内容也能被保留。这使得RTC的配置和时间数据在掉电后不会丢失。

RTC配置：

1. PWR寄存器使能
2. PWR_CR的DBP位**解除对备份域写访问**
3. 使能内部低速时钟
4. 等待时钟就绪
5. 将RTC的时钟源选择为**内部低速时钟**
6. 使能RTC
7. 解除RTC本身的写保护
8. 进入初始化模式
9. 设置时间与日期
10. 退出初始化模式
11. 打开RTC写保护

在 STM32 中，备份域（Backup Domain）包含 RTC 和相关的寄存器。默认情况下，备份域是受保护的，只有在明确解除备份域写保护后，才能对其进行修改。

1. **进入初始化模式**：
   - RTC 的时间和日期寄存器默认是只读的，即使解除备份域和 RTC 的写保护，也不能直接修改这些寄存器。
   - 调用 `RTC_EnterInitMode()` 后，RTC 进入初始化模式，此时可以对时间和日期寄存器进行写操作。
2. **退出初始化模式**：
   - 修改完成后，需要调用 `RTC_ExitInitMode()` 退出初始化模式，RTC 才能正常运行。
3. **获取编译时间和日期**
   - 代码中使用了编译器提供的宏 `__TIME__` 和 `__DATE__`，它们分别表示代码编译时的时间和日期。
   - 星期是通过计算得出来的。

使用标准库的函数，可以获取时间和日期。创建对应的结构体接收一下，转换为字符串，使用LCD的显示字符串即可。



### 按键扫描是怎么实现的？

按键扫描使用BS8116电容触摸按键实现，经过查阅官方手册BS8116的话，有16个触摸按键，使用IIC通信。

- 外部设备通过I2C通信可以读取键值、设置按键感度、设置选项。
- 除了IIC接口的四个引脚，剩下15个引脚作为按键输入使用。还有一个作为输出，可以用来指示是否有按键按下。

#### 使用什么协议通信

使用模拟的IIC，封装了什么函数：

- [IIC的基本时序以及传输函数](####AT24C02怎么做的)

#### 针对BS8116封装了什么函数

- BS8116初始化

  1. IIC的IO口初始化
  2. BS8116的输出引脚的IO口的初始化
  3. BS8116设置寄存器配置函数调用
     1. 配置来自需求以及手册参考
     1. 按键的灵敏度，按键唤醒功能，IRQ是用作按键还是检查使用

- BS8116还需要封装一个设置寄存器的函数，需要一次性写22个字节

- 读取21个寄存器值的函数

  1. 用于检测是否配置成功

- 为了读取BS8116的按键状态还需要封装一个读取按键寄存器值的函数

  1. **BS8116** 的键值寄存器是 **16 位**，用于存储当前检测到的按键状态。

     当 **IRQ** 触发（表示检测到按键按下或松开），**BS8116** 会通过 **I²C 接口** 发送 **两个字节（16 位）** 的数据。
     这个 **16 位数据** 采用 **位映射** 的方式，每一位代表一个按键的状态：

     - **某个位为 1**：表示对应的按键被按下。
     - **某个位为 0**：表示对应的按键松开或未按下

  2. 根据寄存器的值映射到实际的物理按键标识上

- BS8116读键值
  - 发送键值寄存器的地址
  - 读取16位数据，根据键值映射到对应的按键上
- BS8116按键扫描
  - 跟物理按键扫描一个思路，不过判断是否有按键按下通过IRQ判断

### W25Q64的使用

W25Q64是用来存储字库数据的，对于小数据量、高频率写入的应用，AT24C02可能更合适；对于大数据量、中等频率写入的应用，W25Q64配合适当的磨损平衡策略会更好。

W25Q64是一款常用的SPI Flash存储芯片，容量为64Mbit（8MB）

#### W25Q64的内部结构

**扇区级组织**：

- 整个芯片被分为128个**块(Block)**
- 每个块又被细分为16个**扇区(Sector)**

**页(Page)级组织**：

- 每个扇区又被划分为16个**页(Page)**
- 每个页大小为256字节

**读取操作**：可以从任意地址开始，连续读取任意数量的数据

**写入操作**：以页为单位进行，每次最多写入256字节

**擦除操作**：

- 扇区擦除(4KB)
- 块擦除(64KB)
- 芯片擦除(整个芯片)

**重要特点**

擦除是必须的：写入前必须先擦除相应区域（擦除后所有位都变为1）

写入只能将1改为0，不能将0改为1（这就是为什么需要擦除）

扇区是最小的擦除单位

页是最小的编程（写入）单位



#### 使用什么通信？

使用硬SPI通信，封装了什么函数：

- 收发一体一个字节函数
  - 等到发送寄存器为空就可以写入数据
  - 等到接收数据寄存器不为空就可以读取数据
  - 这里使用的是判断数据寄存器

- w25q64初始化配置
  - SPI的IO初始化配置
  - 片选线配置
  - 解除写保护
- 写使能
- 读w25q64状态寄存器的值
- 写w25q64状态寄存器，解除写保护
- 往w25q64中写数据 页写（可以跨页写）
- 从w25q64中读数据
- 擦除传入地址的所在扇区
- 擦除传入地址的所在块区
- 芯片擦除
- 多块擦除

**解除写保护和写使能为什么不冲突？**

写保护 (Write Protection)

- 是一种**持久性**的安全机制
- 保护特定存储区域不被意外或恶意写入
- 通常通过设置状态寄存器中的特定位来实现
- 一旦设置写保护，即使发送了写使能命令，受保护区域也不能被写入
- 必须先解除写保护，才能对受保护区域进行写操作

写使能 (Write Enable)

- 是一种**临时性**的操作许可
- 每次写入或擦除操作前都需要执行
- 通常通过发送特定命令(如W25Q64的0x06命令)来实现
- 写入或擦除操作完成后会自动清除
- 是防止意外写入的一道保险措施

执行写操作的逻辑顺序是：

1. 确保目标区域没有写保护(如果有，需要先解除)
2. 发送写使能命令
3. 执行实际的写入或擦除操作

#### 字库烧录的逻辑

封装了一个字库更新函数，里面有按键扫描，检测到指定按键按下，就执行W25Q64的块擦除函数，开启字库更新标志位。

此函数在初始化时会被调用，程序正常进入，只是没有屏幕显示不了字体了。使用串口助手向MCU发送数据，串口的接收中断中判断是否开启了字库更新标志位，那么就调用W25Q64的写数据函数，接收一个字节就写入一个字节，偏移一个地址。

直接使用内核提供的软件复位函数。

如果没有在一开始更新字库标志位的话，串口助手发送数据的话，就是正常的接收。



### 关于看门狗

独立看门狗(IWDG)的实现步骤如下：

1. 初始化**低速内部时钟**：
   - 开启LSI时钟源 `RCC->CSR |= (1U<<0)`
   - 等待时钟稳定 `while(!(RCC->CSR & (1U<<1)))`
   - [低速内部时钟](####RTC如何配置)
2. 配置看门狗：
   - 解除写保护 `IWDG->KR = 0x5555`
   - 设置分频系数为128 `IWDG->PR = 5` (LSI 32kHz/128 = 250Hz)
   - 设置重装载值为2500 `IWDG->RLR = 2500` (超时时间≈10秒)
   - 将重装载值重载到计数器 `IWDG->KR = 0xAAAA`
3. 启动看门狗：
   - 启动看门狗 `IWDG->KR = 0xCCCC`
4. 定时喂狗：
   - 在主程序中定期调用 `iwdg_feed()` 函数
   - 喂狗操作 `IWDG->KR = 0xAAAA`

此函数在初始化被调用，在进入主循环一开始会被调用一次。

### while(1)

高速轮询特定任务的执行条件

- 周期性检查WiFi的状态
- 自动关门程序
- 自动从ESP32获取时间到stm32,一个小时获取一次
- **都通过标志位来判断是否执行该任务。**

ESP32的数据解析也在主函数中

- 还是要看对应标志位

### 有没有遇到什么问题？怎么解决的？

- 指纹模块偷发数据
  - 做指纹低功耗时的问题
  - 需要解析回传数据包都是靠标志位，偷发不做处理的话，就会收不到正确数据包。

### 问题一

**使用串口与ESP32使用AT指令通信时，我在中断服务函数中实现数据的接收与处理。但是实际会出现数据处理时，会出现问题。但是我把数据处理放在中断服务函数外，这样数据处理就没有问题了，这是为什么？**

### 解决一

刚开始怀疑是底层驱动出现问题。

后面又去看**官方手册的示例**，发现配置没有问题。

还有**配置和命令**给AI检测了一下看是否有语法和逻辑性错误。

单独通过串口助手发送AT指令发现ESP32回传的数据没有问题。

后面再定位到中断服务函数中，确定数据解析逻辑没有问题后。

发现是数据解析时，运用到了大量的字符串操作非常耗时（**包括WiFi连接周期性检测，MQTT连接周期性检测，开门指令的解析，ESP32回传的时间数据解析**），导致数据没有解析完就被更高优先级的中断打断了，导致数据处理错误。后面还是保持中断快进快出的原则，中断服务函数中只接收数据。数据解析单独封装成一个函数，放在主循环中。使用标志位来决定是否执行。

## 外设使用通信协议总结

- IIC
  - 按键（BS8116）软
  - 用户存储（AT24C02）软
- SPI
  - LCD屏幕 软
  - RC522 软
  - W25Q64 硬
- 串口
  - ESP32 硬
  - MG200 硬
- 自定义时序
  - 语音模块