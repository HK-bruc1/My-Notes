# 动态静态函数库的制作

在C语言中，静态库和动态库的区别？使用`#include<>`以及用户自己写的头文件的函数`#include""`是静态库还是动态库？

在C语言中，静态库和动态库是两种不同的库文件类型，它们在编译和运行时的处理方式有所不同。

## 静态库和动态库的区别

**静态库（Static Library）**

- 定义：静态库在编译时被链接到可执行文件中，库中的**代码会被直接复制到最终的可执行文件中**。
- 文件扩展名：
  - Windows 系统：.lib
  - Unix-like 系统（如 Linux）：.a
- 优点：
  - 生成的可执行文件是自包含的，**不依赖外部库文件，因此部署简单**。
  - 运行时无需加载额外的库文件，启动速度较快。
- 缺点：
  - **因为库代码被嵌入，可执行文件体积较大。**
  - **如果静态库有更新，必须重新编译整个可执行文件**。

**动态库（Dynamic Library）**

- 定义：动态库在程序运行时被加载和链接，库代码作为一个独立的文件存在，**不会被复制到可执行文件中**。
- 文件扩展名：
  - Windows 系统：.dll
  - Unix-like 系统（如 Linux）：.so
- 优点：
  - 可执行文件体积较小，因为**不包含库代码**。
  - 多个程序可以共享同一个动态库文件，节省磁盘空间。
  - **更新动态库时，只需替换库文件，无需重新编译可执行文件**。
- 缺点：
  - **运行时需要加载库文件，启动速度可能较慢**。
  - 如果动态库文件丢失或版本不匹配，程序可能无法运行。

### 总结区别

| 特性     | 静态库               | 动态库         |
| -------- | -------------------- | -------------- |
| 链接时机 | 编译时               | 运行时         |
| 代码嵌入 | 是（嵌入可执行文件） | 否（独立文件） |
| 文件大小 | 较大                 | 较小           |
| 依赖性   | 无外部依赖           | 依赖外部库文件 |
| 更新方式 | 需重新编译程序       | 只需替换库文件 |

------

### \#include<>和#include""与静态库、动态库的关系

两者的作用

- \#include<>：通常用于包含系统提供的头文件，例如 C 标准库的 <stdio.h>、<stdlib.h> 等。这些头文件由编译器或操作系统提供。
- \#include""：通常用于包含用户自己编写的头文件，例如 "myheader.h"，这些文件一般位于项目目录中。

**与库类型的无关性**

无论是使用 #include<> 还是 #include""，它们都**只负责包含头文件（.h 文件）**。头文件通常包含：

- 函数声明
- 宏定义
- 类型定义

**头文件本身并不决定程序使用的是静态库还是动态库。库的类型（静态或动态）是在链接阶段决定的，取决于你链接时指定的库文件（例如 .lib、.a 表示静态库，.dll、.so 表示动态库）。**

### 举例说明

1. 使用 #include <stdio.h>：
   - 你包含了标准输入输出函数的声明（如 printf）。
   - 在链接时，编译器会自动链接 C 标准库（**可能是静态库或动态库，取决于系统和编译选项**）。
   - 例如，在 Linux 上可能是动态链接 libc.so，在某些嵌入式系统中可能是静态链接 libc.a。
2. 使用 #include "myheader.h"：
   - 假设 myheader.h 中声明了一个函数 my_function()。
   - 你需要在链接时提供 my_function() 的实现，可以是：
     - 静态库：libmycode.a（需用 -lmycode 链接）
     - 动态库：libmycode.so（同样用 -lmycode 链接，但运行时加载）
   - 具体是静态还是动态，取决于你编译和链接时选择的库文件类型。

结论

- \#include<> 和 #include"" 只是告诉编译器函数的声明，属于编译阶段。
- 静态库还是动态库，由链接阶段指定的库文件决定，与 #include 的方式无关。
- 在C语言中，静态库和动态库的区别在于：
  - 静态库在编译时嵌入可执行文件，独立性强但文件较大；
  - 动态库在运行时加载，文件小且可共享但依赖外部文件。
- 对于 #include<> 和 #include""，它们只是用来包含头文件，提供函数声明，不决定是静态库还是动态库。实际使用的库类型由链接阶段的库文件和编译选项决定，因此用户自己写的头文件函数既可以链接到静态库，也可以链接到动态库，完全取决于你的项目配置。

## 与Windows下双击运行exe文件的类比

在Windows中，双击运行exe文件是否需要额外依赖，与其链接方式有关：

- 静态链接的exe：
  - 如果一个exe文件是静态链接的，**所有需要的代码（包括静态库）都已经被打包到exe文件中。**
  - 双击运行时，不需要额外的DLL（动态链接库）文件即可执行。
  - 这类似于Linux中静态链接的可执行文件，运行时无需下载依赖。
- 动态链接的exe：
  - 许多Windows程序依赖于DLL文件，例如Microsoft Visual C++运行时库。
  - 如果这些DLL文件已经在系统中（比如通过系统安装或软件安装程序提供），用户双击exe即可运行，无需额外操作。
  - 但如果缺少DLL，用户需要手动下载或安装依赖，这类似于Linux中动态链接的程序。

因此，Linux中的静态库和动态库与Windows下的情况有一定相似性：

- **静态链接（无论是Linux还是Windows）类似于“双击即可运行，不用下载依赖”的情景。**
- **动态链接则可能需要确保依赖库已安装，否则无法运行。**

## 为什么Linux中有些命令需要先下载依赖？

在Linux中，许多命令或程序是动态链接的，原因在于动态链接的诸多优势（减小文件体积、易于更新、节省内存）。这意味着这些程序运行时依赖系统中已安装的共享库。如果所需的动态库缺失，就会出现类似于“command not found”或“library not found”的错误。

- 一个程序可能依赖某个特定的库（如libsomepackage）。

- 如果系统中没有这个库，你需要先通过包管理器安装它，例如在Ubuntu上运行：

```
sudo apt install libsomepackage
```

- 安装后再执行命令，程序才能正常运行。

这种“先下载依赖”的情况在Linux中很常见，因为：

1. 系统设计倾向动态链接：Linux发行版通常使用共享库来优化资源使用。
2. 模块化管理：依赖库通过包管理器（如apt、yum）分发，用户只需安装即可解决问题。

### 总结

- 静态库：编译时将代码嵌入可执行文件，运行时无需依赖外部库，类似Windows中完全独立的exe。
- 动态库：运行时加载，依赖外部共享库，类似Windows中需要DLL支持的exe。
- Linux vs Windows：Linux中动态链接更普遍，许多命令需要先安装依赖才能运行；而Windows中，开发者可能选择静态链接让exe更独立，但动态链接也常见。
- 依赖问题：Linux中动态链接程序如果缺少库，需手动安装依赖，这与Windows中缺少DLL的情况类似。

## 自己制作动态库和静态库

用户制作的动态库或者静态库在本地环境中都可以视为“库”，关键在于程序是如何调用这些库的。调用方式主要分为两种：打包编译（静态链接） 和 动态加载调用（动态链接）。

### 打包编译（静态链接）

- 定义：在编译程序时，將静态库（通常是.a文件）中的代码直接嵌入到最终的可执行文件中。
- 特点：
  - 可执行文件包含了静态库中的所有函数和数据。
  - 运行时无需依赖外部库文件，程序完全独立。
  - 文件体积通常较大，因为库的代码已经被打包进去。
- 使用场景：
  - 适合需要程序独立运行、不依赖外部环境的场景。
  - 适合库内容更新不频繁的情况。

操作示例：

- 在编译时使用-l选项指定静态库，例如：

- ```
  gcc main.c -lstaticlib -o program
  ```

编译完成后，program 是一个独立的可执行文件。

### 动态加载调用（动态链接）

- 定义：在程序运行时动态加载动态库（通常是.so文件），可执行文件中只包含对库的引用，而不是库的全部代码。

- 特点：

  - 可执行文件体积较小，因为它不包含库的代码。
  - 运行时需要依赖外部的动态库文件。
  - 动态库更新后，无需重新编译程序，只需替换库文件即可。

- 使用场景：

  - 适合多个程序共享同一个库，节省系统资源。
  - 适合库频繁更新的情况，便于维护。

- 操作示例：

  - 编译时使用-l选项指定动态库，例如：

  - ```
    gcc main.c -ldynamiclib -o program
    ```

  - 运行时，系统会自动加载动态库，或者程序可以通过特定函数（如dlopen）手动加载。

**总结**

- 库的类型：无论是静态库（.a）还是动态库（.so），在本地环境中都可以被程序使用。
- 调用方式：
  - 静态链接：通过打包编译，将库代码嵌入程序，运行时无需外部依赖。
  - 动态链接：通过动态加载，在运行时调用库，依赖外部库文件。
- 选择依据：根据你的程序需求决定：
  - 如果追求独立性和稳定性，选静态链接。
  - 如果注重体积小、共享性或易更新，选动态链接。

### 制作库

**要制作一个库（无论是动态库还是静态库）并在程序中使用它，需要经过几个步骤：编写源文件和头文件、编译源文件、生成库文件，最后在程序中调用库时使用特定命令编译。下面我将详细说明如何实现一个简单的功能函数，并制作静态库和动态库。**

#### 编写源文件和头文件

假设我们要实现一个简单的加法功能的库，包含一个加法函数 add。

头文件：mylib.h

头文件声明函数原型，供其他程序使用。

```
#ifndef MYLIB_H
#define MYLIB_H

int add(int a, int b);

#endif /* MYLIB_H */
```

- \#ifndef 和 #endif 防止头文件被重复包含。

- int add(int a, int b) 是我们要实现的函数声明。



源文件：mylib.c

源文件包含函数的具体实现。

```
#include "mylib.h"

int add(int a, int b) {
    return a + b;
}
```

- \#include "mylib.h" 引入头文件，确保函数声明一致。
- 函数 add 简单地返回两个整数的和。

#### 编译源文件

将源文件编译成目标文件（.o），这是生成库的基础。

```
gcc -c mylib.c -o mylib.o
```

- -c：只编译，不链接，生成目标文件。
  - **不链接库，源文件中也没有main。**

- mylib.o：输出的目标文件名。

#### 生成库文件

**制作静态库**

静态库以 .a 为扩展名，使用 ar 命令生成。

```
ar rcs libmylib.a mylib.o
```

- r：将目标文件插入库中。

- c：如果库不存在则创建。

- s：为库创建索引。

- libmylib.a：静态库文件名，习惯上以 lib 开头。

**制作动态库**

动态库以 .so 为扩展名，使用 gcc -shared 命令生成。

```
gcc -shared -o libmylib.so mylib.o
```

- -shared：指定生成动态库（共享库）。

- -o libmylib.so：输出动态库文件名，习惯上以 lib 开头。

#### 在程序中调用库

假设有一个主程序 main.c，需要使用库中的 add 函数。

```
#include <stdio.h>
#include "mylib.h"

int main() {
    int result = add(3, 4);
    printf("Result: %d\n", result);
    return 0;
}
```

#### 使用静态库编译

编译时需要指定静态库的路径和名称。

```
gcc main.c -L. -lmylib -o program_static
```

- -L.：指定库文件所在的路径（这里是当前目录 .）。

- -lmylib：链接静态库 libmylib.a，注意 -l 后只写库名（去掉 lib 前缀和 .a 后缀）。

- -o program_static：输出可执行文件名。

```
./program_static
```

#### 使用动态库编译

编译时同样需要指定动态库的路径和名称。

```
gcc main.c -L. -lmylib -o program_dynamic
```

- -lmylib：链接动态库 libmylib.so，规则同静态库。

- -o program_dynamic：输出可执行文件名。

运行程序前，需确保动态库在系统路径中。如果动态库在当前目录，可以设置环境变量：

```
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
```

运行程序

```
./program_dynamic
```

#### 总结

**libmylib.a 和 libmylib.so 的本质**

- 是的，它们相当于包含各种目标文件的集合：
  - libmylib.a（静态库）和 libmylib.so（动态库）都是由一个或多个目标文件（.o 文件）编译生成的。
  - 这些目标文件通常包含函数或变量的实现，库只是将它们打包成一个整体，方便程序使用。
- libmylib.a（静态库）：
  - 静态库是一个归档文件（archive），由多个目标文件组成。
  - 在程序编译时，链接器会从 libmylib.a 中提取需要的代码（例如某个函数的实现），并将这些代码直接嵌入到最终的可执行文件中。
  - 特点：函数代码以静态的方式包含在可执行文件中，程序运行时不需要额外的外部库支持。
- libmylib.so（动态库）：
  - 动态库是一个共享对象（shared object），也由目标文件编译而成，但以共享的形式存在。
  - 在程序编译时，链接器不会将 libmylib.so 中的代码嵌入可执行文件，而是只记录对这个库的引用。
  - 在程序运行时，操作系统会动态加载 libmylib.so，将库中的函数代码映射到程序的内存中，供程序调用。
  - 特点：函数代码以共享的方式存在，允许多个程序共享同一个库，节省内存和磁盘空间。
- 总结：
  - libmylib.a 和 libmylib.so 都是目标文件的集合，但它们的链接和使用方式不同：
    - 静态库在编译时嵌入代码。
    - 动态库在运行时加载代码。

#### 编译时指定库还是目标文件？

在程序编译时，通常是指定库，而不是直接指定库中的目标文件名。以下是具体说明：

使用静态库编译

假设你有一个程序 main.c，需要使用 libmylib.a 中的函数：

```
gcc main.c -L. -lmylib -o program_static
```

- -L.：告诉编译器在当前目录（.）查找库文件。
- -lmylib：指定链接的静态库 libmylib.a（-l 后面跟的是库名，去掉 lib 前缀和 .a 后缀）。
- 链接器行为：链接器会从 libmylib.a 中提取需要的目标文件，并将代码嵌入到 program_static 中。

关键点：你只需要指定库名 -lmylib，不需要列出具体的目标文件名（比如 mylib.o），链接器会自动处理。



使用动态库编译

假设同样的程序 main.c，需要使用 libmylib.so 中的函数：

```
gcc main.c -L. -lmylib -o program_dynamic
```

- -L.：指定库文件路径。
- -lmylib：指定链接的动态库 libmylib.so。
- 链接器行为：链接器不会嵌入代码，而是记录对 libmylib.so 的引用，程序运行时由操作系统加载库。

关键点：同样只需要指定库名 -lmylib，不需要具体目标文件名。

- 编译时通常指定库：使用 -l<库名> 指定 libmylib.a 或 libmylib.so，链接器会自动处理。
- 不指定目标文件名：除非特殊情况，直接指定 .o 文件的方式很少使用。

### 库的命名规范

在Linux系统中，当你从第一个目标文件（如 .o 文件）创建库时，库名并不是完全可以随便取的。虽然理论上你可以给库文件起任何名字，但为了让系统、编译器和链接器（如 gcc）能够正确识别和使用这个库，通常需要遵循一定的命名规范。以下是具体说明：

**库的命名规范**

Linux系统中，库的命名遵循以下规则：

- 静态库：
  - 文件名通常以 lib 开头，后面跟上自定义的库名，最后以 .a 作为后缀。
  - 示例：libmylib.a，其中 mylib 是你定义的库名。
- 动态库：
  - 文件名同样以 lib 开头，后面是自定义的库名，最后以 .so 作为后缀（有时还会带版本号，如 .so.1.0）。
  - 示例：libmylib.so，其中 mylib 是库名。

这种命名方式并不是强制性的，但它是Linux系统中的惯例，原因在于链接器（如 ld 或 gcc）会根据这种格式来查找库文件。

#### 为什么建议用 lib + 库名 + 特定后缀？

- 链接器的行为：
  - 当你在编译或链接程序时使用 -l 选项（例如 gcc main.c -lmylib -o program），链接器会自动在系统路径中查找名为 libmylib.a（静态库）或 libmylib.so（动态库）的文件。
  - **如果你的库名不以 lib 开头，比如直接叫 mylib.a，链接器无法通过 -lmylib 找到它，你必须手动指定完整文件名（如 gcc main.c mylib.a -o program），这会失去 -l 选项的便利性。**
- 一致性和可移植性：
  - 遵循 lib + 库名 + .a 或 .so 的命名规则，可以确保你的库在不同的项目或系统中更容易被识别和使用，避免不必要的麻烦。

## 注意事项

假设我用同一个目标文件都生成了同库名的静态库和动态库， 我在调用时，会出错吗？

假设你已经用目标文件（例如 mylib.o）生成了静态库 libmylib.a 和动态库 libmylib.so，并且它们位于当前目录（.）下。你的编译命令是：

```
gcc main.c -L. -lmylib -o program_static
```

链接器的工作原理

- 在使用 gcc 编译时，-L. 告诉链接器在当前目录查找库文件。
- -lmylib 表示链接名为 mylib 的库，链接器会自动在指定路径中寻找 libmylib.so 或 libmylib.a。
- 链接器的默认行为：
  - 如果动态库（libmylib.so）和静态库（libmylib.a）同时存在，链接器会优先选择动态库。
  - 这是因为动态链接是Linux系统中的默认偏好。

你的情况

- 因为你生成了 libmylib.so 和 libmylib.a，并且它们都在当前目录（由 -L. 指定）。
- 链接器执行时：
  1. 首先查找 libmylib.so，发现存在。
  2. 使用 libmylib.so 进行动态链接。
  3. 不会考虑 libmylib.a，除非动态库不存在。

是否会出错？

- 不会出错：
  - 链接器会顺利找到 libmylib.so 并完成动态链接。
  - 编译命令会成功生成可执行文件 program_static。
- 注意事项：
  - 尽管可执行文件名叫 program_static，它实际上是动态链接的（依赖 libmylib.so）。
  - 运行时需要确保 libmylib.so 在系统可找到的路径中（例如通过 LD_LIBRARY_PATH 设置）。

如何强制使用静态库？

如果你希望在这种情况下使用静态库 libmylib.a，而不是动态库，可以尝试以下方法：

- 方法1：使用 -static 选项（全局静态链接）

- ```
  gcc -static main.c -L. -lmylib -o program_static
  ```

  - 这会强制所有库（包括系统库如 libc）都使用静态链接，生成完全静态的可执行文件。

- 方法2：直接指定静态库文件

- ```
  gcc main.c libmylib.a -o program_static
  ```

  - 直接指定 libmylib.a，链接器会明确使用静态库。

### 指定库的位置

默认情况下，如果不指定路径，libmylib.a 会被创建在当前工作目录中。但是，你完全可以通过在库文件名中添加路径来指定它的存放位置。

如何指定路径

- 使用绝对路径：
  比如，你想把库文件存放在 /home/user/libs/ 目录下，可以这样写：

- ```
  ar rcs /home/user/libs/libmylib.a mylib.o
  ```

- 使用相对路径：
  如果你想把库文件存放在当前目录的上级目录下的 libs 文件夹中，可以这样写：

- ```
  ar rcs ../libs/libmylib.a mylib.o
  ```

### 指定库地址的调用命令

- -L. 表示链接器在当前目录（.）查找库文件。

- 如果库文件不在当前目录，你需要将 -L. 替换为 -L 加上库文件所在的实际路径，例如 -L/home/user/libs。

**多个库路径**
如果你的程序依赖多个库，位于不同路径，可以使用多个 -L 选项，例如：

```
gcc main.c -L/path1 -L/path2 -lmylib -lanotherlib -o program
```

