# P16_shell脚本

## 前置

**Linux中，shell终端命令与shell脚本的区别是什么？**

Linux中，shell终端命令和shell脚本之间有明显的区别：

**Shell 终端命令 (Shell Terminal Commands)**

- **定义:** 指的是你在 Linux 系统的命令行终端（通常是 Bash、Zsh 等 shell）中**直接输入并立即执行**的命令。
- **执行方式:** 当你输入一个命令并按下回车键后，shell 会立即解析并执行这个命令。
- 用途:主要用于交互式的操作，例如：
  - 浏览文件和目录 (`ls`, `cd`, `pwd`)
  - 创建、复制、移动和删除文件和目录 (`mkdir`, `cp`, `mv`, `rm`)
  - 查看文件内容 (`cat`, `less`, `head`, `tail`)
  - 运行程序 (`./program`, `command`)
  - 管理进程 (`ps`, `kill`)
  - 配置系统 (`ifconfig`, `ip addr`)
- 特点:
  - **即时性:** 输入后立即执行。
  - **交互性:** 通常是为了完成用户当前需要的一个或多个操作。
  - **临时性:** 命令执行完毕后，其效果通常仅限于本次会话。
  - **简单性:** 一般是单个命令或简单的命令管道组合。

**Shell 脚本 (Shell Script)**

- **定义:** 指的是包含**一系列 shell 命令**的文本文件。这些命令按照文件中编写的顺序依次执行。
- **执行方式:** 你需要先将这些命令写入一个文件（通常以 `.sh` 为扩展名），然后通过特定的方式（例如 `bash script.sh` 或 `./script.sh`）来**执行整个文件中的命令序列**。
- 用途:主要用于自动化任务、批量处理、创建可重用的工具等，例如：
  - 自动备份文件
  - 定时执行特定任务（通过 `cron` 等工具调用脚本）
  - 安装和配置软件
  - 系统监控和维护
  - 构建和部署应用程序
- 特点:
  - **持久性:** 命令被保存在文件中，可以重复执行。
  - **自动化:** 可以一次性执行多个命令，无需人工干预。
  - **复杂性:** 可以包含控制结构（如 `if` 语句、`for` 循环、`while` 循环）、变量、函数等，实现更复杂的逻辑。
  - **可重用性:** 编写好的脚本可以被多次调用和分享。

**总结主要区别:**

| 特征         | Shell 终端命令                               | Shell 脚本                             |
| ------------ | -------------------------------------------- | -------------------------------------- |
| **输入方式** | 直接在终端输入                               | 写入文本文件                           |
| **执行方式** | 输入后立即执行                               | 通过解释器（如 `bash`）执行整个文件    |
| **用途**     | 交互式操作，快速执行单个或少量命令           | 自动化任务，批量处理，创建可重用工具   |
| **持久性**   | 临时性，命令执行完毕后效果通常仅限于本次会话 | 持久性，命令保存在文件中，可以重复执行 |
| **复杂性**   | 一般较为简单，单个命令或简单管道组合         | 可以包含复杂的控制结构、变量和函数     |
| **可重用性** | 通常不直接重用                               | 可以被多次调用和分享                   |



**终端有很多类型是吗？ 比如bash?sh?rbash? 相当于用来解释shell脚本文件的？**

虽然我们经常笼统地说“终端”，但实际上存在不同类型的**shell**，它们可以作为你与操作系统交互的界面，并且也负责解释执行shell脚本文件。

**终端 (Terminal Emulator):**

- 这通常指的是你看到的图形界面应用程序，它提供一个窗口让你输入命令并查看输出。例如，GNOME Terminal、Konsole、iTerm2 等。**它们本身并不解释命令，而是将你的输入传递给底层的 shell。**

**Shell:**

- **Shell 是一个命令解释器 (command interpreter)**。**它接收你输入的命令（无论是直接在终端输入还是来自脚本文件），然后将其翻译成操作系统能够理解的指令并执行。**
- **`bash` (Bourne-Again SHell):** 这是目前 Linux 系统中最常用和默认的 shell。它功能强大，提供了很多扩展和便利的功能。
- **`sh` (Bourne Shell):** 这是 Unix 系统上最早出现的 shell 之一。在许多现代 Linux 系统中，`/bin/sh` 往往是一个指向 `bash` 或其他兼容 shell（如 `dash`）的符号链接。它通常更符合 POSIX 标准。
- **`rbash` (Restricted Bash):** 这是 `bash` 的一个受限版本。它的功能被限制，例如不允许执行 `cd` 命令、修改环境变量等。这通常用于创建更安全或受控的环境。
- **其他 Shell:** 除了 `bash`、`sh` 和 `rbash`，还有其他 shell，例如 `zsh` (Z Shell)、`fish` (Friendly Interactive Shell) 等，它们各自有不同的特性和优点。

**Shell 脚本的解释:**

- 当你运行一个 shell 脚本时，你需要告诉系统使用哪个 shell 来解释执行这个脚本中的命令。

- 通常在 shell 脚本的第一行会使用 Shebang (`#!`) 来指定解释器。

   例如：

  - `#!/bin/bash`  表示使用 `bash` 来执行这个脚本。
  - `#!/bin/sh`   表示使用 `sh` （通常是 `bash` 或 `dash`）来执行这个脚本。
  - `#!/usr/bin/env python3`  这表示使用 `python3` 解释器来执行这个脚本（虽然不是 shell 脚本，但原理类似）。

- 如果你不指定 Shebang，系统可能会使用当前用户的默认 shell 来执行脚本。



**总结来说，终端是由图形化界面应用程序提供的。终端接收ls命令后，会传递给底层的shell解释器。 所以shell命令和shell脚本都是解释型语言，不用编译？**

- **终端**（更精确地说是终端模拟器）确实是由图形化界面应用程序提供的。

- 当你在终端输入 `ls` 命令后，终端会将这个命令传递给**底层的 shell 解释器**（例如 `bash`）。

**shell 命令和 shell 脚本都是解释型语言，通常不需要显式的编译过程。**

以下是更详细的解释：

- **解释型语言 (Interpreted Language):** 解释型语言的代码在运行时由解释器逐行读取并执行。Shell 就是一个解释器。当你输入一个命令或运行一个脚本时，shell 会一行一行地解析这些命令，然后调用相应的系统功能来执行它们。
- **无需编译 (No Compilation):** 与编译型语言（如 C、C++、Go 等）不同，shell 脚本在执行之前不需要先被编译成机器码。编译型语言需要一个单独的编译步骤，将源代码转换成计算机可以直接执行的二进制文件。

**因此，当你运行一个 shell 脚本时，shell 会作为解释器，逐行读取脚本中的命令并执行。你在终端直接输入的命令也是由 shell 解释器立即执行的。**

这种解释执行的特点使得 shell 脚本编写和调试起来相对方便快捷，但也可能在某些情况下导致执行效率不如编译型语言。



**shell命令可以直接在终端输入命令，如果编写shell脚本的话，是不是有一些语法？不是直接写一行一行的命令吧？**

虽然最简单的 shell 脚本可能就是一行行的命令，但要编写更强大、更灵活的脚本，你需要使用特定的**语法**。

**是的，编写 shell 脚本不仅仅是直接写一行一行的命令，它还涉及到一系列的语法规则，让你能够实现更复杂的逻辑和控制流程。**

你可以把 shell 脚本看作是一种简单的编程语言，它基于 shell 命令，并在此基础上添加了编程语言的特性。



**ls -r 与git status他们在bash中的执行过程是一样的吗？ 比如前者先找到ls可执行文件，然后根据-r参数找到ls下不同的分支逻辑执行，后者也是如此吗？ 那他们是不是都是shell执行的？**

`ls -r` 和 `git status` 在 Bash 中的执行过程在顶层是相似的：Bash 找到并执行相应的可执行文件，并将参数传递给它们。关键的区别在于 `ls` 和 `git` 这两个程序本身的功能和内部实现逻辑完全不同，导致它们根据接收到的参数执行不同的操作并产生不同的输出。但它们都依赖于 Bash 来启动和管理它们的执行。

### 总结

**1.终端 (Terminal):**

- 是用户与操作系统进行交互的界面。通常由一个**图形化界面程序**（也称为终端模拟器，例如 GNOME Terminal, Konsole, iTerm2 等）提供一个窗口。

**2. Shell 命令解释器 (Shell):**

- 是一个程序，负责接收用户在终端输入的命令（包括单个命令和脚本中的命令），并将其翻译成操作系统能够理解的指令并执行。
- 存在多种不同的 shell，例如 **Bash** (Bourne-Again SHell，Linux 系统中最常用和默认的 shell 之一), **Sh** (Bourne Shell), **Zsh**, **Fish** 等。

**3. Shell 命令 (Shell Commands):**

- 是用户直接在终端输入的指令，用于执行特定的操作。
- 例如：`ls -r` (列出目录内容并反向排序), `cd` (切换目录), `mkdir` (创建目录) 等。
- 执行过程：
  - Bash 解析命令和参数。
  - Bash 在系统的 `PATH` 环境变量中查找对应的可执行文件（例如 `ls`）。
  - Bash 启动该可执行文件，并将参数（例如 `-r`）传递给它。
  - 可执行文件根据参数执行相应的逻辑。

**4. **外部程序 (以 Git 为例):

- 像 `git` 这样的程序是**独立开发和编译的可执行文件**。
- **Git 命令**（例如 `git status`）实际上是调用 `git` 这个程序并传递不同的子命令（例如 `status`）作为参数。
- 执行时，Bash 找到 `git` 可执行文件，并将 `status` 作为参数传递给 `git` 程序，由 `git` 程序内部根据 `status` 参数的逻辑执行。
- 从 Bash 的角度来看，执行 `git status` 和执行 `ls -r` 的过程类似：找到可执行文件并传递参数。

**5. Shell 脚本 (Shell Scripts):**

- 是一个包含一系列 Shell 命令的文本文件，用于自动化执行一系列任务。
- 可以通过不同的 Shell 命令解释器（例如 Bash, Sh）逐行解释并执行。
- 脚本的第一行通常使用 Shebang (`#!/bin/bash` 或 `#!/bin/sh` 等）来指定使用哪个解释器。
- Bash 会读取脚本文件，并按照顺序逐行执行其中的命令。脚本中可以使用变量、控制结构（如 `if`, `for`）和函数等来实现更复杂的逻辑。

**6. Git Bash:**

- 是 Git for Windows 提供的一个软件包。
- 它包含 **Bash shell** 和 **Git 工具**。
- 为 Windows 用户提供了一个 **类似 Linux 的 Bash 环境**。
- 用户可以在 Git Bash 中执行标准的 Shell 命令和 Shell 脚本。
- 同时，Git Bash 也预装了 Git 工具，可以直接在 Bash 环境中使用 `git` 命令进行版本控制操作。

**Git 工具确实可以看作是 Linux 中用户自定义的编译好的可执行文件。**

**相似之处：**

- **预先编译:** Git 的核心工具（例如 `git` 命令本身以及其各种子命令背后调用的程序）都是用 C 语言等编写并预先编译好的可执行文件。这与 Linux 用户自己编写代码（比如用 C 或 C++），然后通过编译器将其编译成可执行文件的过程是类似的。
- **用户调用:** 无论是 Git 工具还是用户自定义的编译程序，都是通过在 Shell 终端输入其名称（加上可能的参数）来调用的。
- **执行特定任务:** Git 工具专注于版本控制相关的任务，而用户自定义的程序可以执行任何他们编程实现的功能。
- **不属于 Shell 内建命令:** 它们都不是 Shell 自身提供的内置命令（例如 `cd` 或 `pwd`），而是**独立的外部可执行程序**。

**不同之处（细微的差别）：**

- **来源:** Git 工具是由 Git 团队开发和编译的，而用户自定义的程序是用户自己编写和编译的。
- **安装方式:** Git 工具通常通过系统包管理器（如 `apt`、`yum`）或专门的安装包进行安装，而用户自定义的程序可能需要手动编译和放置到合适的目录下。
- **用途范围:** Git 工具专注于版本控制，而用户自定义的程序用途非常广泛。

**你将 Git 工具比作 Linux 中用户自定义的编译好的可执行文件是非常准确的。它们在 Bash 中的执行方式和原理是相同的：Bash 找到这些可执行文件，并将你提供的参数传递给它们，然后由这些程序自身来完成具体的任务。**

**而 Git Bash 提供的 Bash 环境，使得 Windows 用户能够像在 Linux 系统上一样，方便地调用和使用这些预编译好的 Git 工具，以及执行标准的 Shell 命令和脚本。**

## shell脚本介绍

Linux是一个开源的操作系统，不同的组织机构开发了不同的 Shell，常见的 Shell 有 sh、bash、csh、tcsh、ash 等。其中bash shell 是 Linux 的默认 shell。

Shell 是一个程序，一般都是放在/bin或者/usr/bin目录下。在Linux上查看Shell的命令为：cat /etc/shells。

查看linux默认的shell命令：$ echo $SHELL

### 制作&使用Shell脚本步骤

**第一步：添加Shebang行 (强烈建议)**

在你的脚本文件的第一行添加Shebang行，用于指定执行该脚本的解释器。这是最佳实践，确保脚本使用预期的解释器运行。

```bash
#!/bin/bash
或者，更具可移植性的写法：
#!/usr/bin/env bash
```

`#!/bin/bash`:  明确指定使用 `/bin/bash` 解释器。

`#!/usr/bin/env bash`: 在系统的环境变量 `PATH` 中查找 `bash` 解释器，这种方式更灵活，因为 `bash` 的实际安装路径可能不同。

**第二步：创建并编写脚本文件**

使用文本编辑器（例如 `vim`、`nano`、`gedit` 等）创建一个新的文件，并以 `.sh` 作为后缀（虽然不是强制的，但有助于识别文件类型）。

```bash
vim xx.sh
```

在打开的文件中，输入你的Shell脚本代码。脚本内容应该根据你的具体需求来编写，可以包括：

- 变量定义
- 命令调用
- 流程控制语句 (如 `if`、`for`、`while` 等)
- 函数定义
- 注释 (使用 `#` 符号添加单行注释，解释代码的作用)

**第三步：给脚本文件添加可执行权限**

默认情况下，新创建的文件可能没有执行权限。你需要使用 `chmod` 命令为脚本文件添加可执行权限。

```bash
chmod u+x xx.sh
```

`chmod`:  修改文件权限的命令。

`u+x`:  给文件所有者 (user) 添加执行 (execute) 权限。

你也可以使用数字权限模式，例如 `chmod 755 xx.sh` (赋予所有者读、写、执行权限，赋予组用户和其他用户读和执行权限)。

**第四步：运行脚本文件**

有几种方法可以运行你的Shell脚本：

1. **在当前目录下执行 (常用):**

```bash
./xx.sh
```

`./` 表示当前目录。如果你的脚本不在 PATH 环境变量包含的目录中，你需要使用 `./` 来显式指定。

2. 指定解释器执行 (不需要可执行权限):

```bash
sh xx.sh
或者
bash xx.sh
```

这种方式会显式地调用 `sh` 或 `bash` 解释器来执行你的脚本，即使脚本本身没有可执行权限也可以运行。

3. **使用完整路径执行:**

如果你的脚本不在当前目录，你可以使用脚本的完整路径来执行它。

```bash
/path/to/your/script/xx.sh
```

## 基本语法

### shell命令基本格式

Shell 命令的基本格式如下：

- command [选项] [参数]

举例：

- ls 

- ls -l

- ls -al

- ls -l 1.txt

说明：

- []：代表可有可无，不同命令有不同要求。

- 选项：带-或者--，大多数都是- ,查看选项可以用： man 命令，比如：man ls
- windows上的命令行，一般都是--
- 标准shell命令的话，参数都带-
- git命令不带，参数带空格 

### 基本规则

**Shebang 行 (强烈推荐):**

- 脚本的第一行通常以 `#!` 开头，后跟解释器的路径。
- 推荐使用 `#!/bin/bash` 或更通用的 `#!/usr/bin/env bash`。
- 用于指定执行脚本的解释器。

**命令分隔和换行:**

- 通常，每个命令占据脚本的一行。
- 如果需要在同一行执行多个命令，可以使用分号 `;` 将它们分隔开。

**脚本执行和错误处理:**

- Shell 脚本是解释型语言，无需编译。
- 通过 `chmod +x your_script.sh` 添加可执行权限。
- **错误处理建议:** 为了在命令执行失败时立即停止脚本，建议在脚本开头添加 `set -e`。默认情况下，脚本会继续执行。

**注释:**

- 除了第一行的 Shebang，任何以 `#` 开头的行都是注释，用于解释代码。

### 变量

Shell语言中变量的分类：系统变量和用户自定义变量

#### 系统变量

系统变量是由 Shell 环境预先定义好的变量，用于存储系统信息、用户环境、Shell 状态等。这些变量**通常是只读的，或者其值由 Shell 自动维护。**

**使用：**

- 可以直接在脚本中使用系统变量，通常以 `$` 符号开头。例如：`$HOME`，`$PATH`。

**注意事项：**

- **命名规则：** 系统变量通常使用大写字母，并用下划线 `_` 分隔单词。
- **只读性：** 某些系统变量是只读的，不能在脚本中直接修改其值。
- **含义固定：** 每个系统变量都有其预定义的含义，不要随意假设或更改其用途。

**常见系统变量示例：**

| 变量名          | 含义                                                         | 示例                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `$HOME`         | 当前用户的主目录的路径。                                     | `echo "当前用户的主目录是：$HOME"`                           |
| `$PWD`          | 当前工作目录的路径。                                         | `echo "当前工作目录是：$PWD"`                                |
| `$USER`         | 当前登录用户的用户名。                                       | `echo "当前登录用户是：$USER"`                               |
| `$SHELL`        | 当前用户使用的 Shell 的路径。                                | `echo "当前使用的 Shell 是：$SHELL"`                         |
| `$PATH`         | 系统搜索可执行文件的路径列表，用冒号 `:` 分隔。              | `echo "系统的 PATH 环境变量是：$PATH"`                       |
| `$IFS`          | 内部字段分隔符，用于分隔命令行参数、单词等，默认为空格、制表符和换行符。 | `echo "内部字段分隔符是：'$IFS'"`                            |
| `$?`            | 上一个执行的命令的退出状态。通常，`0` 表示成功，非零值表示失败。 | `command_that_might_fail; echo "上一个命令的退出状态是：$?"` |
| `$#`            | 传递给脚本的命令行参数的个数。                               | `echo "传递给脚本的参数个数是：$#"`                          |
| `$*`            | 传递给脚本的所有命令行参数，作为一个字符串。                 | `echo "所有命令行参数是：$*"`                                |
| `$@`            | 传递给脚本的所有命令行参数，每个参数都被双引号括起来，保留参数的独立性。 | `echo "所有命令行参数是：$@"`                                |
| `$0`            | 当前脚本的文件名。                                           | `echo "当前脚本的文件名是：$0"`                              |
| `$1`, `$2`, ... | 传递给脚本的第一个、第二个等命令行参数。                     | `echo "第一个参数是：$1"`                                    |
| `$$`            | 当前 Shell 进程的进程 ID (PID)。                             | `echo "当前 Shell 进程的 PID 是：$$"`                        |
| `$!`            | 上一个在后台运行的命令的进程 ID (PID)。                      | `command & echo "后台运行命令的 PID 是：$!"`                 |

```bash
#!/bin/bash

echo "当前用户是：$USER"
echo "当前工作目录是：$PWD"
echo "当前脚本的文件名是：$0"
echo "传递给脚本的参数个数是：$#"
echo "所有参数（作为一个字符串）：$*"
echo "第一个参数是：$1"
```

#### 自定义变量

**使用：**

1. **定义变量：**
   - 变量名 `=` 变量值
   - **注意：** 等号 `=` 两边不能有空格。
   - 变量名通常使用小写字母，可以用下划线 `_` 分隔单词，但不能以数字开头。
2. **使用变量：**
   - 在变量名前加上 `$` 符号来引用变量的值。
   - 可以使用 `${变量名}` 的形式，**尤其是在变量名后紧跟着其他字符时，为了避免歧义**

**注意事项：**

- **作用域：** 默认情况下，自定义变量的作用域仅限于当前 Shell 脚本或 Shell 会话。如果需要在子 Shell 中使用，需要使用 `export` 命令将其导出为环境变量。
- **类型：** **Shell 中的变量本质上都是字符串。即使你赋值为数字，Shell 也将其视为字符串**。如果需要进行数值计算，需要使用特定的命令（如 `expr`、`awk`、`bc` 等）。
- 赋值方式：
  - 直接赋值：`name="John Doe"`
  - 从命令输出赋值：`current_date=$(date)` 或 `current_date=\`date``
  - 从用户输入赋值：`read -p "请输入您的姓名：" name`

```bash
#!/bin/bash

# 定义变量
name="Alice"
age=30
city="New York"

# 使用变量
echo "姓名：$name"
echo "年龄：${age}岁"
echo "城市：$city"

# 从命令输出的结果中赋值
current_time=$(date "+%Y-%m-%d %H:%M:%S")
echo "当前时间：$current_time"

# 从用户输入赋值
read -p "请输入您的爱好：" hobby
echo "您的爱好是：$hobby"

# 数值计算（需要使用特定命令）
num1=10
num2=5
sum=$(expr $num1 + $num2)
echo "10 + 5 = $sum"
```

### 算术运算

在Shell脚本中，进行算术运算有几种常用的方法：

1. **`expr` 命令:**
   - `expr` 是一个外部命令，用于求表达式的值。
   - 操作符和操作数之间需要用空格隔开。
   - 乘法 `*` 需要转义为 `\*`，否则会被解释为文件名通配符。
   - 只能进行整数运算。

```bash
result=$(expr 1 + 2)
echo "1 + 2 = $result"

result=$(expr 5 \* 3)
echo "5 * 3 = $result"
```

2. **`$(())` 语法:**
   - 这是Bash推荐的算术扩展语法。
   - 操作符和操作数之间**可以没有空格**。
   - **乘法 `*` 不需要转义**。
   - 可以进行整数运算。

```bash
result=$((1 + 2))
echo "1 + 2 = $result"

result=$((5 * 3))
echo "5 * 3 = $result"
```

3. **`$` 语法:**
   - 与 `$(())` 类似，也是一种算术扩展语法。
   - 操作符和操作数之间**可以没有空格**。
   - **乘法 `*` 不需要转义**。
   - 可以进行整数运算。

```bash
result=$[1 + 2]
echo "1 + 2 = $result"

result=$[5 * 3]
echo "5 * 3 = $result"
```

4. **`let` 命令:**
   - `let` 命令用于**执行一个或多个算术表达式**。
   - **变量赋值可以直接在 `let` 命令中进行**。
   - 操作符和操作数之间**可以没有空格**。
   - 可以进行整数运算。

```bash
let "a = 1 + 2"
echo "1 + 2 = $a"

let "b = 5 * 3"
echo "5 * 3 = $b"
```

**常用的算术运算符**

| 运算符 | 描述         |
| ------ | ------------ |
| `+`    | 加法         |
| `-`    | 减法         |
| `*`    | 乘法         |
| `/`    | 除法（取整） |
| `%`    | 取模（余数） |
| `**`   | **幂运算**   |
| `++`   | **自增**     |
| `--`   | **自减**     |
| `=`    | 赋值         |
| `+=`   | 加法赋值     |
| `-=`   | 减法赋值     |
| `*=`   | 乘法赋值     |
| `/=`   | 除法赋值     |
| `%=`   | 取模赋值     |

#### 注意事项

**整数运算:** Shell脚本默认进行整数运算。如果需要进行浮点数运算，可以使用 `bc` 或 `awk` 等工具。

```bash
# 整数除法
result=$((5 / 2))
echo "5 / 2 = $result"  # 输出 2

# 使用 bc 进行浮点数运算
result=$(echo "scale=2; 5 / 2" | bc)
echo "5 / 2 = $result"  # 输出 2.50
```

**空格:**

- 在使用 `expr` 命令时，操作符和操作数之间必须有空格。
- 在使用 `$(())`、`$` 和 `let` 命令时，空格不是必需的，但为了代码可读性，建议在操作符两侧添加空格。

**变量:** 在算术运算中可以使用变量。Shell变量存储的是字符串，但在算术运算上下文中，它们会被自动转换为数字（如果可以转换）。

```bash
num1=10
num2=5
result=$((num1 + num2))
echo "$num1 + $num2 = $result"
```

**转义:** 在 `expr` 命令中，乘号 `*` 需要转义为 `\*`，因为 `*` 在Shell中是通配符。

**运算符优先级:** 算术运算符遵循标准的优先级规则（例如，乘法和除法优先于加法和减法）。可以使用括号 `()` 来改变运算的优先级。

```bash
result=$((2 + 3 * 4))
echo "2 + 3 * 4 = $result"  # 输出 14

result=$(((2 + 3) * 4))
echo "(2 + 3) * 4 = $result"  # 输出 20
```

**除数为零:** 避免除数为零的情况，否则会导致错误。

**非数字输入:** 如果参与运算的变量包含非数字字符，可能会导致错误。在进行算术运算之前，最好确保变量包含的是有效的数字。

#### 浮点数运算格式

`area=$(echo "scale=2; $pi * $radius * $radius" | bc)` 这个格式在Shell脚本中使用 `bc` 进行浮点数运算时是一种常见的固定模式，但其中也有可变的部分。

**固定部分：**

- **`area=$(...)`**:  这部分是 Shell 的**命令替换**语法。它表示将括号 `(...)` 中命令的输出结果赋值给变量 `area`。这部分是固定的，用于捕获 `bc` 命令的输出。
- **`echo "` 和 `"`**: `echo` 是 Shell 的内置命令，用于输出字符串。双引号 `""` 用于将后面的内容作为一个字符串参数传递给 `echo`。这部分也是相对固定的，**用于构建传递给 `bc` 的命令字符串**。
- **`scale=`**: 这是 `bc` 命令的一个**内置变量**，用于**设置计算结果的小数点后的位数**。`scale=` 本身是固定的语法。
- **`;`**: 在 `bc` 命令中，分号 `;` 用于分隔多个命令。在这里，它分隔了设置 `scale` 的命令和执行算术运算的命令。这是一个固定的分隔符。
- **`\*`**: 这是乘法运算符，在 `bc` 中是固定的。
- **`|`**: 这是 Shell 的**管道符**，用于将前一个命令（`echo` 的输出）的**标准输出**作为后一个命令（`bc`）的**标准输入**。这是一个固定的 Shell 语法。
  - **标准流管道的用法**
- **`bc`**: 这是调用 **Basic Calculator** 这个命令行计算器的命令，是固定的。

**可变部分：**

- **`2`**: 这是 `scale` 变量的值，表示计算结果保留两位小数。你可以根据需要更改这个数字来控制精度。例如，`scale=5` 会保留五位小数。
- **`$pi`**: 这是一个 Shell **变量**，它应该在脚本的其他地方被赋值为 π 的近似值（例如 `pi=3.14159`）。这个变量名和它的值是可变的。你可以使用不同的变量名或者更精确的 π 值。
- **`$radius`**: 这也是一个 Shell **变量**，它应该在脚本的其他地方被赋值为圆的半径。这个变量名和它的值是可变的。你可以使用不同的变量名来表示不同的数值。
- **`$radius \* $radius`**: 这是要执行的算术表达式。你可以根据需要更改这个表达式来执行不同的浮点数运算。例如，你可以计算 `"$pi * $radius"`（圆的周长的一半），或者更复杂的表达式。

这个格式的骨架是固定的，用于将一个包含 `bc` 命令和表达式的字符串通过管道传递给 `bc` 计算并获取结果。而真正参与计算的数值（通过 Shell 变量传递）以及计算的精度（通过 `scale` 设置）是可变的部分。

### 输入与输出

**Shell脚本主要使用 `echo`命令进行输出。**

**`echo` 命令**

- **语法:** `echo [选项] [字符串 ...]`
- **使用:**
  - 用于在终端上显示文本信息。
  - 可以输出一个或多个字符串，字符串之间用空格分隔。
  - 默认情况下，`echo` 会在输出的末尾添加一个换行符。
- **常用选项:**
  - `-n`:  取消输出末尾的换行符。
  - -`e`:  启用对反斜杠转义字符的解释。常用的转义字符包括：
    - `\n`: 换行
    - `\r`: 回车
    - `\t`: 水平制表符
    - `\\`: 反斜杠自身
    - `\"`: 双引号
    - `\'`: 单引号

```c
#!/bin/bash

name="World"

# 简单输出
echo "Hello, $name!"

# 不换行输出
echo -n "Please enter your age: "
read age
echo "You are $age years old."

# 使用转义字符
echo -e "This is line 1.\nThis is line 2."
echo -e "Name:\t$name"
echo -e "The path is: /home/user/file" # 不需要转义斜杠
echo -e "Outputting a double quote: \""
echo -e 'Outputting a single quote: \'' # 在单引号内输出单引号需要转义
```

**注意事项:**

- 变量可以直接在双引号 `""` 包裹的字符串中展开。
- 单引号 `''` 包裹的字符串会原样输出，不会进行变量展开或转义字符的解释。
- 在需要使用转义字符时，务必加上 `-e` 选项。

**输出重定向**

可以将命令的输出重定向到文件，而不是显示在终端上。

- **`>`**: 将命令的输出重定向到指定文件。如果文件不存在则创建，如果文件已存在则**覆盖**其内容。

```bash
echo "This will be written to output.txt" > output.txt
ls -l > file_list.txt
```

- **`>>`**: 将命令的输出追加到指定文件的末尾。如果文件不存在则创建，如果文件已存在则在末尾添加内容。

```bash
echo "This will be appended to output.txt" >> output.txt
date >> log.txt
```



**Shell脚本主要使用 `read` 命令从用户获取输入或从文件中读取数据。**

**`read` 命令**

- **语法:** `read [选项] [变量名 ...]`
- **使用:**
  - 从标准输入（通常是键盘）读取一行文本，并将其分割成单词（默认以空格、制表符或换行符分隔），然后将每个单词赋值给指定的变量。
  - 如果只指定一个变量名，则整行输入都会赋值给该变量。
- **常用选项:**
  - `-p 提示信息`: 在读取输入之前显示指定的提示信息。
  - `-t 秒数`: 设置读取输入的超时时间，如果在指定时间内没有输入，`read` 命令将返回一个非零的退出状态。
  - `-n 字符数`: 只读取指定数量的字符后就结束读取，即使没有按下回车键。
  - `-s`: 静默读取，即用户输入的内容不会显示在终端上（常用于输入密码）。
  - `-a 数组名`: 将读取到的单词存储到指定的数组中。

```bash
#!/bin/bash

# 读取用户输入到单个变量
read -p "Enter your name: " name
echo "Hello, $name!"

# 读取用户输入到多个变量（以空格分隔）
read -p "Enter your first and last name: " firstname lastname
echo "Your full name is: $firstname $lastname"

# 设置超时时间
if read -t 5 -p "Enter something within 5 seconds: " input; then
  echo "You entered: $input"
else
  echo "Timeout! You didn't enter anything."
fi

# 静默读取密码
read -s -p "Enter your password: " password
echo # 输出一个换行符，避免密码直接显示在下一行
echo "Password entered (not shown): $password"

# 读取到数组
read -a colors -p "Enter some colors separated by spaces: "
echo "You entered the following colors:"
for color in "${colors[@]}"; do
  echo "- $color"
done
```

**`read -a colors -p "Enter some colors separated by spaces: "`**: 这是核心的输入命令。

- **`read`**: 这是 Shell 内置的命令，用于从标准输入读取一行文本。
- **`-a colors`**: 这是一个选项，告诉 `read` 命令将读取到的内容视为一系列的单词，并将这些单词存储到一个名为 `colors` 的**数组**中。数组是 Shell 中一种可以存储多个值的变量类型。
- **`-p "Enter some colors separated by spaces: "`**: 这是一个选项，用于在读取输入之前显示一个提示信息给用户。用户会在终端看到 "Enter some colors separated by spaces: "。

**工作方式：** 当脚本执行到这一行时，它会等待用户在终端输入一些文本，然后按下回车键。`read` 命令会按照空格、制表符或换行符将用户输入的文本分割成多个独立的“单词”。然后，它会将这些单词依次存储到名为 `colors` 的数组的各个元素中。

**`echo "You entered the following colors:"`**: 这行代码使用 `echo` 命令在终端上输出一段提示信息，告诉用户接下来将显示他们输入的颜色。

**`for color in "${colors[@]}"; do ... done`**: 这是一个 `for` 循环，用于遍历数组 `colors` 中的所有元素。

- `for color in "${colors[@]}"`:
  - **`for color in ...`**:  这是一个标准的 `for` 循环结构，它会迭代 `in` 关键字后面的列表。在每次迭代中，当前列表中的元素会被赋值给变量 `color`。
  - `${colors[@]}`: 这是访问数组 colors中所有元素的一种特殊语法。
    - `colors`:  代表数组的名称。
    - `[@]`:  表示获取数组中所有元素的列表。使用双引号 `""` 包裹 `"${colors[@]}"` 是一个良好的习惯，它可以防止在数组元素包含空格时出现意外的分割。
  - 因此，这个 `for` 循环会依次将 `colors` 数组中的每个元素赋值给变量 `color`。
- **`do`**:  标记循环体的开始。
- **`echo "- $color"`**: 在循环的每一次迭代中，这行代码会使用 `echo` 命令输出一个短横线 `-` 后面跟着当前数组元素的值（存储在变量 `color` 中）。
- **`done`**: 标记循环体的结束。

**注意事项:**

- 如果 `read` 命令后面没有指定变量名，读取到的内容会存储在 Shell 的特殊变量 `REPLY` 中。

**输入重定向**

可以将文件的内容作为命令的输入。

- **`<`**: 将指定文件的内容作为命令的标准输入。

```bash
# 将 file.txt 的内容作为 cat 命令的输入并输出到终端
cat < file.txt

# 将 data.txt 的每一行读取到 while 循环中
while read line; do
  echo "Processing line: $line"
done < data.txt
```

### 关系运算符

关系运算符用于比较两个值之间的关系，并根据比较结果返回真（true）或假（false）。在Shell脚本中，关系运算符通常用在条件判断语句（如 `if`、`elif`）中来控制程序的流程。

Shell脚本中的关系运算符可以分为两类：**数值关系运算符**和 **字符串关系运算符**。

**数值关系运算符**

这些运算符用于比较两个数值的大小。它们通常与 `test` 命令（或其等价形式 `` 和 Bash 特有的 `[]`）一起使用。

**语法和运算符 (使用 Bash 特有的 `[]`)：**

在 Bash 中，`[]` 提供了更强大的条件判断功能，并且在处理数值比较时也更方便。

| 运算符 | 描述     | 示例                  |
| ------ | -------- | --------------------- |
| `==`   | 等于     | `[[ "$a" -eq "$b" ]]` |
| `!=`   | 不等于   | `[[ "$a" -ne "$b" ]]` |
| `>`    | 大于     | `[[ "$a" -gt "$b" ]]` |
| `>=`   | 大于等于 | `[[ "$a" -ge "$b" ]]` |
| `<`    | 小于     | `[[ "$a" -lt "$b" ]]` |
| `<=`   | 小于等于 | `[[ "$a" -le "$b" ]]` |

```bash
#!/bin/bash

num1=10
num2=5

if [[ "$num1" -eq "$num2" ]]; then
  echo "$num1 等于 $num2"
else
  echo "$num1 不等于 $num2"
fi

if [[ "$num1" -gt "$num2" ]]; then
  echo "$num1 大于 $num2"
fi

if [[ "$num1" -le "$num2" ]]; then
  echo "$num1 小于等于 $num2"
else
  echo "$num1 大于 $num2"
fi
```

**注意事项 (数值关系运算符)：**

- **仅用于整数比较:** 这些运算符只能用于比较整数。**如果需要比较浮点数，需要使用其他工具，如 `bc` 或 `awk`。**
- **操作数必须是整数:** 确保参与比较的变量或值是整数类型。如果包含非数字字符，可能会导致错误。
- **空格很重要 ():** 在使用 `test` 命令或` 时，运算符和操作数之间必须有空格。例如，`[ "$a" -eq "$b" ]` 是正确的，而 `["$a"-eq"$b"]` 是错误的。
- **变量引用:** 建议将变量用双引号 `""` 包裹起来，以防止因变量值包含空格或特殊字符而导致意外的行为。例如，`[ "$a" -eq 10 ]`。



**字符串关系运算符**

**语法和运算符 (使用 Bash 特有的 `[]`)：**

在 `[]` 中，字符串比较的语法更直观。

| 运算符 | 描述              | 示例                       |
| ------ | ----------------- | -------------------------- |
| `==`   | 等于              | `[[ "$str1" == "$str2" ]]` |
| `!=`   | 不等于            | `[[ "$str1" != "$str2" ]]` |
| `<`    | 小于 (按字典顺序) | `[[ "$str1" < "$str2" ]]`  |
| `>`    | 大于 (按字典顺序) | `[[ "$str1" > "$str2" ]]`  |
| `-z`   | 字符串长度为零    | `[[ -z "$str" ]]`          |
| `-n`   | 字符串长度不为零  | `[[ -n "$str" ]]`          |

```bash
#!/bin/bash

str1="hello"
str2="world"
str3=""

if [[ "$str1" == "$str2" ]]; then
  echo "$str1 等于 $str2"
else
  echo "$str1 不等于 $str2"
fi

if [[ "$str1" != "$str2" ]]; then
  echo "$str1 不等于 $str2"
fi

if [[ "$str1" < "$str2" ]]; then
  echo "$str1 小于 $str2"
fi

if [[ -z "$str3" ]]; then
  echo "str3 是空字符串"
fi

if [[ -n "$str1" ]]; then
  echo "str1 不是空字符串"
fi
```

**注意事项 (字符串关系运算符)：**

- **区分大小写:** 字符串比较默认是区分大小写的。
- **空格很重要 ():** 同样，在使用 `test` 或` 时，运算符和操作数之间需要有空格。
- **变量引用:** 强烈建议将变量用双引号 `""` 包裹起来，以防止因变量值包含空格而导致错误。例如，`[ "$str1" = "some string" ]`。
- **`-z` 和 `-n`:** 这两个运算符用于检查字符串的长度是否为零。

**Bash 特有的 `[]` 的优势：**

- **不需要转义 `<` 和 `>`:** 在字符串比较时，可以直接使用 `<` 和 `>`，而不需要转义。
- **不需要引用变量:** 在 `[]` 中，通常不需要像在 `` 中那样为了安全起见而引用变量（除非变量值包含模式匹配的特殊字符，并且你希望按字面量比较）。
- **支持模式匹配:** `[]` 支持使用 `==` 运算符进行简单的模式匹配（使用 `*`、`?` 等通配符）。

### 选择结构

**if结构**

在 `if` 中，当方括号内的条件为真时，`test` 命令会返回退出状态 `0`，这会被 `if` 语句视为真，并执行 `then` 后面的代码块。

**为什么会这样设计？**

Shell 的设计哲学是围绕着执行命令展开的。它的主要任务是启动和管理进程。因此，将条件判断与命令的执行结果（通过退出状态来表示）紧密结合是很自然的：

- **方便地检查命令执行结果：** 你可以直接在 `if` 语句中执行一个命令，并根据其是否成功（退出状态是否为 0）来决定下一步的操作。例如：

- ```bash
  if grep "pattern" file.txt; then
    echo "Pattern found in file."
  else
    echo "Pattern not found."
  fi
  ```

- **统一的真假判断方式：** 无论是文件测试、字符串比较还是执行其他命令，最终的真假都通过命令的退出状态来体现，这提供了一种统一的判断方式。

- **`[]` 的出现：**

  Bash 等更现代的 Shell 引入了 `[]` 结构，它在某些方面更接近其他编程语言的 `if` 判断：

  - 支持更复杂的布尔逻辑，可以直接使用 `&&`、`||` 和 `!`。
  - 提供了更多的比较操作符（如 `==`、`!=`、`<`、`>` 用于字符串比较）。
  - 避免了一些由于单词分割和文件名扩展可能导致的问题。

- 尽管如此，即使在使用 `[]` 时，其底层的机制仍然是基于命令的退出状态，只不过 Bash 对其进行了封装和增强，使其用起来更方便和直观。

**所以本质上shell脚本中的if [] 中，要当作命令来看对吗？执行成功返回0，被判断为真，从而进入if结构？**

**本质上，Shell 脚本中的 `if` 确实要当作一个命令来看待。**

更准确地说：

- `[` 是一个命令（也可以认为是 `test` 命令的一个别名）。
- `[ ... ]` 内部的内容是这个命令的参数，用于描述需要进行判断的条件。
- 当 `[` 命令执行完毕后，它会返回一个**退出状态码（Exit Status）**。
- **如果 `[` 命令评估内部的条件为真，它会返回退出状态码 `0`。**
- **如果 `[` 命令评估内部的条件为假，它会返回一个非零的退出状态码（通常是 `1`）。**

`if` 语句正是通过检查紧随其后的命令（在这里是 `[` 命令）的退出状态码来判断条件是否成立的：

- 如果退出状态码是 `0`，`if` 语句就认为条件为真，并执行 `then` 后面的代码块。
- 如果退出状态码是非零值，`if` 语句就认为条件为假，并跳过 `then` 后面的代码块（或者执行 `elif` 或 `else` 块中的代码）。

**因此，你可以将 `if` 看作是执行了一个名为 `[` 的命令，这个命令根据你提供的条件判断真假，并通过其退出状态码将结果告知 `if` 语句。**

```bash
#!/bin/bash

read -p "请输入您的分数: " score

if [[ "$score" -ge 90 ]]; then
    echo "优秀 (A)"
elif [[ "$score" -ge 80 ]]; then
    echo "良好 (B)"
elif [[ "$score" -ge 70 ]]; then
    echo "中等 (C)"
elif [[ "$score" -ge 60 ]]; then
    echo "及格 (D)"
else
    echo "不及格 (F)"
fi
```

**`case` 语句**

`case` 语句用于根据一个变量的值匹配不同的模式，并执行相应的代码块。它通常用于处理多个离散的选项。

```bash
#!/bin/bash

read -p "请选择一个选项 (a, b, c): " choice

case "$choice" in
    a)
        echo "您选择了选项 a"
        ;;
    b)
        echo "您选择了选项 b"
        ;;
    c)
        echo "您选择了选项 c"
        ;;
    *)
        echo "无效的选项"
        ;;
esac
```

**使用:**

- `case variable in`:  指定要匹配的变量。
- `pattern1)`、`pattern2)` 等:  定义要匹配的模式。模式可以使用通配符（如 `*`、`?`、``）。
- `commands`:  与匹配的模式关联的命令。
- `;;`:  双分号用于终止当前模式对应的命令块，并跳出 `case` 语句。如果忘记写 `;;`，程序会继续执行下一个模式的命令块（fall-through），这通常不是期望的行为。
- `*)`:  这是一个可选的默认模式，用于匹配所有前面模式都不匹配的情况。它通常放在最后。
- `esac`:  标记 `case` 语句的结束。

**注意事项 (选择结构)：**

- `condition` 的形式 (`if` 语句):
  - `if` 后面跟的是一个命令。**如果该命令的退出状态为 0，则认为条件为真；否则为假。**
  - 通常使用 `test` 命令 (``) 或 Bash 特有的 `[]` 来进行条件判断。
  - `和 `[]` 内部的语法规则有所不同，例如，在` 中使用 `<` 和 `>` 进行字符串比较时需要转义 (`\<` 和 `\>`)，而在 `[]` 中则不需要。
  - 建议使用 `[]`，因为它更强大且不容易出错，尤其是在处理字符串比较时。
- **`then` 关键字:** `then` 关键字通常与 `if` 在同一行，用分号 `;` 分隔，或者另起一行。
- **`fi` 关键字:** 每个 `if` 语句块都必须以 `fi` 结尾。
- **`elif` 和 `else` 是可选的:** `if` 语句可以只有 `if` 部分，也可以有 `if-else`，或者 `if-elif-...-else` 的形式。
- **缩进:** 为了提高代码的可读性，建议在 `if`、`elif`、`else` 和 `case` 语句块内的 `commands` 部分使用缩进。
- `case` 语句的模式:
  - 模式是按顺序匹配的，一旦找到一个匹配的模式，就会执行相应的命令块，然后跳出 `case` 语句。
  - 可以使用 `|` 符号在同一个模式下匹配多个值，例如：`a|b)`。
  - `*)` 模式应该放在最后，作为默认匹配项。
- **退出 `case` 语句 (`;;`):** 务必在每个模式的命令块后加上 `;;` 来终止执行，否则会继续执行下一个模式的命令块。
- **变量引用:** 在条件判断中引用变量时，通常建议使用双引号 `""` 包裹变量，以防止因变量值包含空格或特殊字符而导致意外的行为。

### 逻辑运算

Shell 脚本中常用的逻辑运算符有以下几种：

| 运算符 | 含义   | 适用场景                                                     |
| ------ | ------ | ------------------------------------------------------------ |
| `&&`   | 逻辑与 | 当 `&&` 两边的命令或条件都为真（退出状态为 0）时，整个表达式才为真。 |
| `||`   |        | 逻辑或                                                       |
| `!`    | 逻辑非 | 对一个命令或条件的真假取反。如果命令或条件为真，则 `!` 运算后为假，反之亦然。 |
| `-a`   | 逻辑与 | 通常与 `test` 或 `[` 命令一起使用，用于**连接多个文件属性判断条件**。 |
| `-o`   | 逻辑或 | 通常与 `test` 或 `[` 命令一起使用，用于**连接多个文件属性判断条件**。 |

**注意：**

- `&&` 和 `||` 是 Shell 的控制流操作符，它们会**根据左边命令的退出状态来决定是否执行右边的命令。**
- `-a` 和 `-o` 是 `test` 命令或 `[` 命令的选项，用于在单个 `test` 或 `[` 语句中组合多个文件属性相关的条件判断。

逻辑运算通常与条件判断语句（如 `if`、`elif`、`while`、`until`）以及 `test` 命令或 `[` 命令一起使用。

```bash
command1 && command2  # 如果 command1 执行成功（退出状态为 0），则执行 command2
command3 || command4  # 如果 command3 执行失败（退出状态非 0），则执行 command4

if condition1 && condition2; then
  # 当 condition1 和 condition2 都为真时执行这里的代码
  echo "Both conditions are true"
fi

if condition3 || condition4; then
  # 当 condition3 或 condition4 至少一个为真时执行这里的代码
  echo "At least one condition is true"
fi

if ! condition5; then
  # 当 condition5 为假时执行这里的代码
  echo "Condition 5 is false"
fi
这里的 `condition` 可以是命令的执行结果（根据其退出状态判断真假）或者使用 `test` 命令或 `[` 命令进行条件判断。

test -f file1.txt -a -d directory2  # 判断 file1.txt 是否存在且是一个文件，并且 directory2 是否存在且是一个目录
[ -r file3.txt -o -w file3.txt ]   # 判断 file3.txt 是否可读或者可写
注意：
在使用 [ 命令时，[ 后面和 ] 前面需要有空格。
-a 和 -o 通常用于连接文件属性相关的判断，对于更复杂的逻辑判断，推荐使用 && 和 || 结合多个 test 或 [ 语句。
```

`[]` 是 Bash 中更强大的条件判断结构，它提供了更多的功能，并且在某些情况下更不容易出错。在 `[]` 中，可以直接使用 `&&`、`||` 和 `!` 进行逻辑运算，而不需要额外的 `test` 或 `[` 命令。

```bash
if [[ -f file1.txt && -d directory2 ]]; then
  echo "file1.txt exists and is a file, and directory2 exists and is a directory"
fi

if [[ "$var" == "value1" || "$var" == "value2" ]]; then
  echo "Variable is either value1 or value2"
fi

if [[ ! -e file3.txt ]]; then
  echo "file3.txt does not exist"
fi
```

**注意事项**

1. **空格的使用：** 在使用 `[` 命令时，务必注意 `[` 后面和 `]` 前面需要有空格。例如 `[ -f file.txt ]` 是正确的，而 `[-f file.txt]` 是错误的。`test` 命令没有这个要求，但为了统一风格，通常也会在条件之间加上空格。在 `[]` 中，空格的使用相对宽松，但为了可读性，建议在运算符两侧加上空格。
2. **引用变量：** 当在条件判断中引用变量时，为了避免因变量值包含空格或特殊字符而导致错误，通常建议使用双引号将变量括起来，例如 `"$variable" == "some value"`。
3. **命令的退出状态：** `&&` 和 `||` 的行为依赖于命令的退出状态。退出状态为 0 表示成功（真），非 0 表示失败（假）。

### 循环结构

#### for循环

`for` 循环用于遍历一个列表或者执行固定次数的操作。

格式一：遍历列表

```bash
for variable in item1 item2 ... itemN
do
  # 循环体：在这里执行需要重复的操作
  command1
  command2
  ...
done
```

- `variable`: 循环变量，在每次迭代中会依次取列表中的一个值。

- `in item1 item2 ... itemN`: 指定要遍历的列表，列表中的元素之间用空格分隔。

- `do`: 标志循环体的开始。

- `done`: 标志循环体的结束。

格式二：C 风格的 `for` 循环 (Bash 特有)

```bash
for (( initial_value; condition; increment ))
do
  # 循环体
  command1
  command2
  ...
done
```

- `initial_value`: 循环变量的初始值。
- `condition`: 循环继续执行的条件，只要条件为真就继续循环。
- `increment`: 在每次循环结束后，循环变量的增量或减量。

**使用注意事项：**

- **列表中的空格：** 如果列表中的某个元素包含空格，需要用双引号或单引号将该元素括起来，以确保它被视为一个整体。
- **变量作用域：** **在 `for` 循环中定义的变量通常在循环结束后仍然存在于脚本的当前作用域中。**
- `break` 和 `continue`：
  - `break`: 用于立即跳出当前循环，执行 `done` 后面的代码。
  - `continue`: 用于跳过当前迭代的剩余部分，直接进入下一次迭代。

```bash
#!/bin/bash

files="file1.txt file2.log report.csv"

for f in $files; do
  echo "正在处理文件：$f"
  if [ -f "$f" ]; then
    echo "$f 是一个普通文件。"
  else
    echo "$f 不是一个普通文件。"
  fi
done
```

示例 3：C 风格的 `for` 循环

```bash
#!/bin/bash

for (( i=0; i<5; i++ )); do
  echo "当前计数：$i"
done
```

#### **`while` 循环**

`while` 循环会在指定的条件为真时持续执行循环体中的代码。

```bash
while condition
do
  # 循环体
  command1
  command2
  ...
done
```

- `condition`: 循环继续执行的条件。只要这个条件为真（命令的退出状态为 0），循环就会继续执行。
  - **只要这条命令执行成功，返回值为0，循环就会继续执行**

- `do`: 标志循环体的开始。

- `done`: 标志循环体的结束。

**使用注意事项：**

- **循环条件：** 务必确保循环条件最终会变为假，否则会导致无限循环。
- **条件判断：** `while` 循环的条件通常使用 `test` 命令 (``) 或 `[]` 进行判断。
- **`break` 和 `continue`：** 同样可以使用 `break` 和 `continue` 来控制循环的流程。

示例 1：读取文件内容直到遇到特定行

```bash
#!/bin/bash

file="data.txt"
count=0

while read line; do
  count=$((count + 1))
  echo "第 $count 行：$line"
  if [[ "$line" == "END" ]]; then
    echo "找到结束标记，退出循环。"
    break
  fi
done < "$file"
```

1.**`< "$file"` 的作用：输入重定向**

- `<` 是 Shell 中的**输入重定向操作符**。
- `"$file"` 指定了要作为输入来源的文件名（使用双引号是为了防止文件名中包含空格或特殊字符导致问题）。
- `done < "$file"` 的意思是将文件 `$file` 的内容**重定向**到 `while` 循环的标准输入（stdin）。

**2. `while read line` 的工作方式**

- `while read line` 是一个常见的 Shell 循环结构，用于逐行读取文件的内容。
- `read line` 命令会尝试从其标准输入读取一行文本，并将其赋值给变量 `line`。
- 只要 `read` 命令成功读取到一行（即没有到达文件末尾），它的退出状态就是 `0`（真），`while` 循环就会继续执行。
- 当 `read` 命令到达文件末尾时，它会返回一个非零的退出状态（假），`while` 循环就会终止。

**3. 为什么 `< "$file"` 写在 `done` 后面？**

- **作用域：** 将输入重定向放在 `done` 后面，意味着这个重定向作用于**整个 `while` 循环**。也就是说，在 `while` 和 `done` 之间的所有命令（包括 `read line`）都会从文件 `$file` 的标准输入中读取数据。
- **清晰的逻辑：** 这种写法清晰地表明了整个循环的目的是处理来自特定文件的输入。



示例 2：等待某个文件出现

```bash
#!/bin/bash

filename="output.log"
#判断条件只依赖于命令的返回值，0就是成功，非0就是失败。
# ! 会在文件不存在的情况下把 [ -f "$filename" ] 返回的 1 变成 0，从而使得 while 循环的条件为真，并进入循环结构。
while ! [ -f "$filename" ]; do
  echo "等待文件 $filename 生成..."
  sleep 5
done

echo "文件 $filename 已生成，继续处理。"
```

#### `until` 循环

`until` 循环与 `while` 循环类似，但它的循环体会在指定的条件为假时持续执行，直到条件变为真时才停止。

```bash
until condition
do
  # 循环体
  command1
  command2
  ...
done
```

- `condition`: 循环继续执行的条件。**只要这个条件为假（命令的退出状态非 0），循环就会继续执行。**
- `do`: 标志循环体的开始。
- `done`: 标志循环体的结束。

**使用注意事项：**

- **循环条件：** 务必确保循环条件最终会变为真，否则会导致无限循环。
- **条件判断：** `until` 循环的条件通常使用 `test` 命令 () 或 `[]` 进行判断。
- **`break` 和 `continue`：** 同样可以使用 `break` 和 `continue` 来控制循环的流程。

示例 1：不断尝试连接服务器直到成功

```bash
#!/bin/bash

server="example.com"

until ping -c 1 "$server" > /dev/null 2>&1; do
  echo "无法连接到 $server，正在重试..."
  sleep 10
done

echo "成功连接到 $server。"
```

示例 2：等待用户输入特定的值

```bash
#!/bin/bash

expected_input="quit"
user_input=""

until [[ "$user_input" == "$expected_input" ]]; do
  read -p "请输入 '$expected_input' 以退出: " user_input
  if [[ "$user_input" != "$expected_input" ]]; then
    echo "输入错误，请重试。"
  fi
done

echo "程序退出。"
```

刚开始为假，知道用户输入quit为止。

**循环结构的通用注意事项**

- **无限循环：** 这是初学者常犯的错误。请务必检查你的循环条件，确保它们最终会使循环终止。可以使用 `Ctrl+C` 强制终止正在运行的脚本。
- **循环变量：** 注意循环变量在循环内外的作用域，避免命名冲突。
- **性能：** 在处理大量数据或进行复杂操作时，循环可能会影响脚本的性能。可以考虑使用更高效的工具或命令来处理数据（例如 `awk`、`sed`、`find` 等）。
- **可读性：** 使用适当的缩进和注释来提高循环结构的可读性，方便理解和维护。
- **避免在循环内执行不必要的操作：** 将可以在循环外部完成的操作移到循环外面，以提高效率。

选择哪种循环结构取决于你的具体需求：

- **`for` 循环：** 当你需要遍历一个已知的列表或者执行固定次数的操作时。
- **`while` 循环：** 当你需要根据一个条件持续执行循环，直到条件变为假时。
- **`until` 循环：** 当你需要根据一个条件持续执行循环，直到条件变为真时。

### 函数

在 Shell 脚本中，你可以使用两种主要的语法来定义函数：

**语法一：使用 `function` 关键字**

```bash
function function_name {
  # 函数体：在这里编写函数要执行的代码
  command1
  command2
  ...
}
```

语法二：更简洁的语法（推荐）

```bash
function_name () {
  # 函数体
  command1
  command2
  ...
}
```

- `function_name`: 你为函数指定的名称，遵循 Shell 变量的命名规则（通常使用小写字母和下划线）。

- `{}`: 包含函数体的代码块。

**函数调用**

要调用一个已经定义的函数，只需要在脚本中直接使用函数名即可：

```bash
function_name
```

**函数返回值**

Shell 函数主要通过以下两种方式“返回”值：

**1. 使用 `return` 语句返回退出状态**

- `return` 语句用于从函数中退出，并可以返回一个**整数值**作为函数的退出状态码。
- 退出状态码的范围是 0-255。**按照惯例，`0` 表示成功，非零值表示失败或错误**。
- 你可以使用 `$?` 特殊变量来获取上一个命令（包括函数调用）的退出状态。

```bash
my_function () {
  # ...
  if [ some condition ]; then
    return 0  # 表示成功
  else
    return 1  # 表示失败
  fi
}

my_function
if [ $? -eq 0 ]; then
  echo "函数执行成功。"
else
  echo "函数执行失败。"
fi
```

**注意：** `return` 语句主要用于指示函数的执行状态，而不是返回任意类型的数据。

**通过标准输出返回值**

- 函数可以通过 `echo` 或其他输出命令将结果输出到标准输出。
- 你可以使用命令替换 `$(...)` 或反引号 ``...`` 来捕获函数的标准输出作为变量的值。

```bash
get_message () {
  message="Hello from the function!"
  echo "$message"
}

result=$(get_message)
echo "函数返回的消息是：$result"
```

**函数参数**

你可以向 Shell 函数传递参数，这些参数在函数内部可以通过特殊变量 `$1`、`$2`、`$3` 等来访问，分别代表传递给函数的第一个、第二个、第三个参数，以此类推。

- `$0`: 代表脚本自身的名称。
- `$#`: 代表传递给函数的参数个数。
- `$@` 或 `"$*"`: 代表传递给函数的所有参数，`"$*"` 会将所有参数作为一个字符串处理（用空格分隔），而 `$@` 会将每个参数作为一个独立的字符串处理，通常推荐使用 `"$@"`。

```bash
greet () {
  local name="$1"  # 获取第一个参数
  local greeting="Hello, $name!"
  echo "$greeting"
}

greet "Alice"  # 调用函数并传递参数 "Alice"
greet "Bob"    # 调用函数并传递参数 "Bob"
```

**局部变量**

在函数内部使用 `local` 关键字声明的变量是局部变量，它们只在函数的作用域内可见。这有助于避免函数内部的变量与脚本中其他地方的变量发生冲突。

```c
my_function () {
  local my_local_var="This is local"
  echo "Inside function: $my_local_var"
  global_var="This is global (modified)" # 如果没有用 local 声明，会修改全局变量
}

global_var="Initial global value"
my_function
echo "Outside function: $global_var"
echo "Outside function (local var): $my_local_var" # 这里将无法访问 my_local_var
```

**函数作用域**

- 默认情况下，在脚本中定义的函数是全局的，可以在脚本的任何地方调用（但需要在定义之后）。
- 使用 `local` 关键字声明的变量只在函数内部可见。

**使用注意事项**

1. **定义在前，调用在后：** 通常情况下，你需要在使用函数之前先定义它。虽然 Bash 在某些情况下允许在定义之前调用函数，但为了代码的可读性和避免潜在问题，建议将函数定义放在脚本的前面部分。
2. **函数名唯一性：** 在同一个脚本中，函数名必须是唯一的。
3. **参数传递：** **调用函数时，参数之间用空格分隔。如果参数本身包含空格，需要用引号（单引号或双引号）将参数括起来。**
4. **返回值处理：** 根据函数的功能，选择合适的返回值方式（退出状态或标准输出）。如果需要返回复杂的数据结构，通常会考虑使用标准输出，并可能需要进行额外的处理（例如使用 `awk` 或 `sed` 解析输出）。
5. **局部变量的使用：** 尽可能在函数内部使用 `local` 关键字声明变量，以提高代码的模块化和可维护性，避免意外修改全局变量。
6. **函数库：** 对于大型脚本或需要在多个脚本中使用的函数，可以考虑将它们放在单独的文件中（通常称为函数库），然后在需要使用的脚本中通过 `source` 命令或 `.` 命令引入这些函数。
7. **递归函数：** Shell 函数也支持递归调用，但需要注意递归的深度，避免栈溢出等问题。

#### 示例

```bash
#!/bin/bash

print_header () {
  echo "-------------------------"
  echo "  脚本执行信息"
  echo "-------------------------"
}

print_header
echo "开始执行主要任务..."
# ... 脚本的主要逻辑 ...
print_header
echo "主要任务执行完毕。"
```

示例 2：带参数的函数，计算两个数的和

```bash
#!/bin/bash

add () {
  local num1="$1"
  local num2="$2"
  local sum=$((num1 + num2))
  echo "The sum of $num1 and $num2 is: $sum"
}

add 10 20
add 5 15
```

示例 3：返回退出状态的函数，检查文件是否存在

```bash
#!/bin/bash

check_file_exists () {
  local filename="$1"
  if [ -f "$filename" ]; then
    return 0  # 文件存在
  else
    return 1  # 文件不存在
  fi
}

file_to_check="my_data.txt"
check_file_exists "$file_to_check"

if [ $? -eq 0 ]; then
  echo "文件 '$file_to_check' 存在。"
else
  echo "文件 '$file_to_check' 不存在。"
fi
```

